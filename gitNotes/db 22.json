{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/smile.png","path":"images/smile.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar_2.gif","path":"images/avatar_2.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.DS_Store","hash":"460c137531b172d678da3fd76c462c86fb5d4570","modified":1596005020124},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1595935344690},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1595935344689},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1595935344690},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1595935344690},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1595935344690},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1595935344690},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1595935344691},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1595935344691},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1595935344691},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1595935344691},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1595935344691},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1595935344692},{"_id":"themes/next/_config.yml","hash":"8ca8da13f4249c0d68aea68e96c58228df66f92e","modified":1604055818111},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1595935344692},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1595935344692},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1595935344712},{"_id":"source/.DS_Store","hash":"bcf6d50122d51dc902d77d5b01d9ffc975f89194","modified":1600397049751},{"_id":"source/CNAME","hash":"012e2c960e6590e339af6e0b980233583b178c8f","modified":1596272966525},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1595935344690},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1595935344690},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1595935344690},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1595935344690},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1595935344695},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1595935344710},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1595935344711},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1595935344711},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1595935344711},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1595935344711},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1595935344711},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1595935344712},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1595935344692},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1595935344692},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1595935344693},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1595935344693},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1595935344693},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1595935344693},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1595935344693},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1595935344693},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1595935344693},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1595935344694},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1595935344694},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1595935344694},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1595935344694},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1595935344694},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1595935344694},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1595935344695},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1595935344712},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1595935344713},{"_id":"themes/next/source/.DS_Store","hash":"17bb53c35137ebfd9ca1e7e1554acab03b301abb","modified":1596072478586},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1595935344806},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1595935344807},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1595935344807},{"_id":"source/about/index.md","hash":"2d7e70746cd45ec9d38467b29b0b0f4b99fa05b2","modified":1595987406708},{"_id":"source/categories/index.md","hash":"1b87b5e655ba8858f2e12c6e6e40b7c54e73fc62","modified":1595987414660},{"_id":"source/_posts/.DS_Store","hash":"68a39638df271c21c26b9d1dd8a6589d574825ea","modified":1603974007134},{"_id":"source/_posts/Array.md","hash":"38fdcc41411323ad5d7cc0f084433d176edb2435","modified":1604054189153},{"_id":"source/_posts/Backtracking.md","hash":"445cae531e025587216c71947f8859859099fe54","modified":1604053394398},{"_id":"source/_posts/Basic-Knowledge.md","hash":"e47e777967a1a458a1f566e732565a83ca1d1d5b","modified":1603968845048},{"_id":"source/_posts/Binary-Search.md","hash":"4181555a11609da4b530f7bf1b0e93b178f72694","modified":1603968990469},{"_id":"source/_posts/Binary-Tree.md","hash":"11ba15b40d35001495f02c75b6a0f578aa888980","modified":1604053382477},{"_id":"source/_posts/Dynamic-Programming.md","hash":"edb9cb98ddd7ffbf21714d87598512e25b5b89f7","modified":1603969049548},{"_id":"source/_posts/Greedy-Algorithm.md","hash":"1f61d1ce4239f7da099bceca8b26ac653b33f646","modified":1603969059445},{"_id":"source/_posts/JavaScript-Notes.md","hash":"17d9f8da3eea9d5b5b807fc3a822cefa66302c07","modified":1604052285868},{"_id":"source/_posts/Linked-list.md","hash":"d54aa1da3ef6af4048f1ba0d8b5f0e31eeb4d5d6","modified":1603968909426},{"_id":"source/_posts/Sort.md","hash":"65237a91589dbc924c8df66d4a5fca4b35c8fb59","modified":1603969002108},{"_id":"source/_posts/String.md","hash":"b7e07bdf5e70d8c43f565f3b7ef88a2634bd49f5","modified":1603969009953},{"_id":"source/_posts/Two-Pointers.md","hash":"7b074f02f7f61f1b24ddeefc71d0e902483b717a","modified":1603969022118},{"_id":"source/_posts/Vue-Learning.md","hash":"f79ee23db18f94109118cf75beb8ce79f1050c5a","modified":1596001105879},{"_id":"source/tags/index.md","hash":"c6be348a100c4a59037a055ddce675ef1f932b9a","modified":1595989721648},{"_id":"source/_posts/hello-world.md","hash":"372b7083163ddf84cc7fc3d116675c6810cc2715","modified":1595949845684},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344743},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1595935344695},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1595935344695},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1595935344696},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1595935344696},{"_id":"themes/next/layout/_macro/post.swig","hash":"e0df0ec78bbe39ddeb77c6e98dcd93dfb8c5e1a0","modified":1595952097992},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1595935344696},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"d68b43edfc2dd23a50f68efddba6bbbd3444c0c0","modified":1595988767150},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1595935344697},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1595935344697},{"_id":"themes/next/layout/_partials/footer.swig","hash":"306387bbc828c359ebde502f4613ef05119b4c4f","modified":1604055632322},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1595935344697},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1595935344698},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1595935344698},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"26d95dfc5220d041841fa4ac66adb53d768b23d5","modified":1603969762250},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1595935344698},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1595935344701},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1595935344701},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1595935344702},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1595935344707},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1595935344707},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1595935344708},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1595935344708},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1595935344708},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1595935344708},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1595935344708},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1595935344714},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1595935344714},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1595935344715},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1595935344715},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1595935344715},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1595935344716},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1595935344716},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1595935344716},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1595935344717},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1595935344743},{"_id":"themes/next/source/images/.DS_Store","hash":"7e650f566e97d0f9fc048e610521fa24d2e66d85","modified":1595991691968},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1595935344744},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1595935344744},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1595935344000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1595935344745},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1595935344745},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1595935344745},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1595935344745},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1595935344746},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1595935344746},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1595935344746},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1595935344747},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1595935344747},{"_id":"themes/next/source/images/favicon.svg","hash":"d86c042282707c4768d903afd6f0791dd103b1c7","modified":1595948609236},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1595935344747},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1595935344747},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1595935344747},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1595935344748},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1595935344748},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1595935344748},{"_id":"themes/next/source/images/smile.png","hash":"437533897dc8fbf6e68c195dd758cd1a2001c8dc","modified":1595948771356},{"_id":"source/_posts/Binary-Search/binary-search.png","hash":"07464cd8934ba18cd24d2f16bf700ee9d1a32ab4","modified":1601272181098},{"_id":"source/_posts/Greedy-Algorithm/largen-reach.png","hash":"65c5fe4cc7c549e23886375132e006ffb2e8e881","modified":1596421177972},{"_id":"source/_posts/Linked-list/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1601192281457},{"_id":"source/_posts/JavaScript-Notes/htmltree.jpg","hash":"164dd2e4fe565e9ea4dccc436d9d0f9484d807f3","modified":1603969188630},{"_id":"source/_posts/Linked-list/image1.png","hash":"a6f5f6e33b452b75681f187ccb626c309ac83ea0","modified":1600397026169},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344702},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344702},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344742},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344743},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344736},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344736},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595935344737},{"_id":"source/_posts/Backtracking/bitmask4.png","hash":"2c12dfaeec5c2e250853a9beaa39ab495568d815","modified":1597901969824},{"_id":"source/_posts/Binary-Tree/二叉树.png","hash":"cb0e529886f3c5086139c1e2f4b02f259e26f1d0","modified":1601192150002},{"_id":"source/_posts/Greedy-Algorithm/45_fig1.png","hash":"c263da40f4a55cad4e6b21c80d7e8849ef7ccec5","modified":1596421172153},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1595935344697},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1595935344698},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1595935344699},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1595935344699},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1595935344699},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1595935344699},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1595935344700},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1595935344700},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1595935344700},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1595935344701},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1595935344702},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1595935344702},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1595935344703},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1595935344703},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1595935344703},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1595935344703},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1595935344703},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1595935344704},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1595935344704},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1595935344704},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1595935344704},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1595935344704},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1595935344705},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1595935344705},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1595935344705},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1595935344705},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1595935344705},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1595935344706},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1595935344706},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1595935344706},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1595935344706},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1595935344706},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1595935344707},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1595935344707},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1595935344709},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1595935344710},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1595935344709},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1595935344710},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1595935344742},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1595935344742},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1595935344743},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1595935344743},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"959db3f5c17540a42228a8a26ea9595b1e372bb9","modified":1603968566130},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1595935344736},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1595935344736},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1595935344737},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1595935344748},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1595935344749},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1595935344749},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1595935344749},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1595935344749},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1595935344750},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1595935344750},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1595935344750},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1595935344751},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1595935344751},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1595935344752},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1595935344761},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1595935344762},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1595935344762},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1595935344760},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1595935344756},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1595935344767},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1595935344768},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1595935344768},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1595935344768},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1595935344773},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1595935344774},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1595935344775},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1595935344775},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1595935344776},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1595935344789},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1595935344791},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1595935344791},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1595935344791},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1595935344791},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1595935344791},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1595935344792},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1595935344792},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1595935344792},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1595935344793},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1595935344793},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1595935344793},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1595935344793},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1595935344794},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1595935344794},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1595935344794},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1595935344794},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1595935344795},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1595935344795},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1595935344795},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1595935344795},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1595935344795},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1595935344796},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1595935344796},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1595935344802},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1595935344802},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1595935344805},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1595935344806},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1595935344806},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1595935344796},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1595935344797},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1595935344797},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1595935344790},{"_id":"source/_posts/Linked-list/image.png","hash":"99d89358565f62a05ca2b54b11d4a247e7af98f0","modified":1600234232506},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1595935344709},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1595935344709},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1595935344717},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1595935344717},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1595935344718},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1595935344718},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1595935344718},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1595935344722},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1595935344729},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1595935344734},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1595935344734},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1595935344735},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1595935344735},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1595935344735},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1595935344735},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1595935344734},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1595935344737},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1595935344738},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1595935344737},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1595935344738},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1595935344738},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1595935344738},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1595935344738},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1595935344739},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1595935344739},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1595935344740},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1595935344740},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1595935344740},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1595935344740},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1595935344741},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1595935344741},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1595935344741},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1595935344741},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1595935344742},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1595935344742},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1595935344751},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1595935344754},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1595935344756},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1595935344756},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1595935344762},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1595935344763},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1595935344764},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1595935344764},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1595935344764},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1595935344764},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1595935344766},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1595935344767},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1595935344767},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1595935344769},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1595935344769},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1595935344778},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1595935344778},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1595935344779},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1595935344801},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1595935344802},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1595935344755},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1595935344789},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1595935344788},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1595935344804},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1595935344718},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1595935344719},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1595935344719},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1595935344719},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1595935344720},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1595935344720},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1595935344720},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1595935344720},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1595935344721},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1595935344721},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1595935344721},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1595935344722},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1595935344722},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1595935344722},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1595935344723},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1595935344723},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1595935344723},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1595935344723},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1595935344723},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1595935344724},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1595935344724},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1595935344724},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1595935344724},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1595935344724},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1595935344725},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1595935344725},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1595935344726},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1595935344726},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1595935344726},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1595935344727},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"48c000163ce191a76e9e5c747c72be5c46930b88","modified":1595949380275},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1595935344727},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1595935344727},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1595935344728},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1595935344728},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1595935344728},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1595935344728},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1595935344728},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1595935344729},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1595935344732},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1595935344732},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1595935344732},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1595935344732},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1595935344733},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1595935344733},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1595935344733},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1595935344733},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1595935344733},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1595935344729},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1595935344729},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1595935344730},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1595935344730},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1595935344730},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1595935344730},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1595935344731},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1595935344731},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1595935344731},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1595935344739},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1595935344739},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1595935344740},{"_id":"themes/next/source/images/avatar_2.gif","hash":"34226e87bf4e8cc6b2d2bce17295d7177da7ad2a","modified":1595991400579},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1595935344753},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1595935344753},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1595935344753},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1595935344754},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1595935344754},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1595935344765},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1595935344765},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1595935344765},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1595935344765},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1595935344766},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1595935344766},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1595935344788},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1595935344732},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1595935344783},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1595935344781},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1595935344760},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1595935344786},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1595935344800},{"_id":"public/search.xml","hash":"69159bbd2a26d2910780d1146b6cbc8c4f4624dd","modified":1604055827323},{"_id":"public/sitemap.xml","hash":"26c4d419e5e70201640faac0734faa28c5493549","modified":1604055827323},{"_id":"public/about/index.html","hash":"794e08dd876cf740840e7c484397d43769e22d55","modified":1604055827323},{"_id":"public/categories/index.html","hash":"1268448dce0fc690a6e1af802f1453351101b802","modified":1604055827323},{"_id":"public/tags/index.html","hash":"08ad1f563839993816e9d34dc7625ad4718b597f","modified":1604055827323},{"_id":"public/2020/09/30/Basic-Knowledge/index.html","hash":"14845923527cb61eb6e143bddbc3f9021bb5f4f6","modified":1604055827323},{"_id":"public/2020/09/27/Binary-Tree/index.html","hash":"8713ce017c9d9259b224c0284c144fee1fded3da","modified":1604055827323},{"_id":"public/2020/09/21/Array/index.html","hash":"9250a574ed6e7cd2d10001b176fafd0b296c7b42","modified":1604055827323},{"_id":"public/2020/09/17/Sort/index.html","hash":"fe9c62ceedc4330742a5ff0f74a9833bcde2da85","modified":1604055827323},{"_id":"public/2020/09/11/Linked-list/index.html","hash":"aaf8c05ebd1d2a18ebc7fb8223c7bd1f72fa57d5","modified":1604055827323},{"_id":"public/2020/09/01/JavaScript-Notes/index.html","hash":"86b06c246bbdff6f9a4c12f800f44acb9f5083ea","modified":1604055827323},{"_id":"public/2020/08/18/Backtracking/index.html","hash":"4a5311828fc840942b3aac92898c382c89aa2711","modified":1604055827323},{"_id":"public/2020/08/17/String/index.html","hash":"90ae74d2aae501bb4c2b8261cd179237b71af6ff","modified":1604055827323},{"_id":"public/2020/08/04/Dynamic-Programming/index.html","hash":"3376d2f39b3774eabaf57eb856302769bfabba21","modified":1604055827323},{"_id":"public/2020/08/03/Binary-Search/index.html","hash":"b7c50b47b1303b1b886bfeec922580965c5e4e8c","modified":1604055827323},{"_id":"public/2020/08/03/Greedy-Algorithm/index.html","hash":"608856500173083a58e400d789241d80cffbfefe","modified":1604055827323},{"_id":"public/2020/07/30/Two-Pointers/index.html","hash":"ce9ec558e7baadd4eda6127d57db70e04fe06f85","modified":1604055827323},{"_id":"public/2020/07/29/Vue-Learning/index.html","hash":"4985d87146b5738a1e927f527f3ee7735b81a617","modified":1604055827323},{"_id":"public/2020/07/28/hello-world/index.html","hash":"740a658d153ac2256089b4aa4cf91eb26cb8b060","modified":1604055827323},{"_id":"public/archives/index.html","hash":"5dfd2297e4935384ca495ebcb212665960ecebd9","modified":1604055827323},{"_id":"public/archives/page/2/index.html","hash":"833e8345a5af0d22c7d02bbd7421fd0815226aa3","modified":1604055827323},{"_id":"public/archives/2020/index.html","hash":"2bcd16edeceb9d12a16a52c50066678b9ecd5fc8","modified":1604055827323},{"_id":"public/archives/2020/page/2/index.html","hash":"548b78d3d43bcbd3e9a9142502746cf962839363","modified":1604055827323},{"_id":"public/archives/2020/07/index.html","hash":"b0a79816290b542c83e835881f15c74ebb53910a","modified":1604055827323},{"_id":"public/archives/2020/08/index.html","hash":"bb19577114a82088068b8c30567849eb89a0fbea","modified":1604055827323},{"_id":"public/archives/2020/09/index.html","hash":"6a263594814746b01b9d9622ca799f231f108635","modified":1604055827323},{"_id":"public/index.html","hash":"7ec76902fdd220800b516f2a88a44c2698617fff","modified":1604055827323},{"_id":"public/page/2/index.html","hash":"5ed806cde5702f1e23b4388ce5d4ab63521e5ed5","modified":1604055827323},{"_id":"public/categories/Algorithm/index.html","hash":"a6f2a1aa2eb9743c1902dcebf6adeffe4117d458","modified":1604055827323},{"_id":"public/categories/前端框架/index.html","hash":"b9bd9215d238d82842417e1b66efa07e103c4fd5","modified":1604055827323},{"_id":"public/tags/Backtracking/index.html","hash":"83f909ae54e21b9d93c8ffd4bbb4342ac91f9312","modified":1604055827323},{"_id":"public/tags/LeetCode/index.html","hash":"02f96b9b9a849a276cf91f58a02c6c369277a0ca","modified":1604055827323},{"_id":"public/tags/Array/index.html","hash":"996759c9f62f726b2ce03a14fecf56247889ab9f","modified":1604055827323},{"_id":"public/tags/Dynamic-Programming/index.html","hash":"020c4a477a7fbffafae9b766df9c64950b1349ac","modified":1604055827323},{"_id":"public/tags/array/index.html","hash":"9dac0ab76375a2cfd7d2927f6d714f6e0b131704","modified":1604055827323},{"_id":"public/tags/two-pointers/index.html","hash":"dba992ae9789dc3f16da4f977e860394636f5730","modified":1604055827323},{"_id":"public/tags/Vue/index.html","hash":"8e1da75e7fd578e386c2fd62d3740f31df0003d6","modified":1604055827323},{"_id":"public/tags/js/index.html","hash":"b4da46a934b5670aa471eeda83db583ff3ab454a","modified":1604055827323},{"_id":"public/tags/JavaScript/index.html","hash":"a8100ada45f45021144fd180e0ca3430a5da70c4","modified":1604055827323},{"_id":"public/CNAME","hash":"012e2c960e6590e339af6e0b980233583b178c8f","modified":1604055827323},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1604055827323},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1604055827323},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1604055827323},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1604055827323},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1604055827323},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1604055827323},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1604055827323},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1604055827323},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1604055827323},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1604055827323},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1604055827323},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1604055827323},{"_id":"public/images/favicon.svg","hash":"d86c042282707c4768d903afd6f0791dd103b1c7","modified":1604055827323},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1604055827323},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1604055827323},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1604055827323},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1604055827323},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1604055827323},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1604055827323},{"_id":"public/images/smile.png","hash":"437533897dc8fbf6e68c195dd758cd1a2001c8dc","modified":1604055827323},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1604055827323},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1604055827323},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1604055827323},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1604055827323},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1604055827323},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1604055827323},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1604055827323},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1604055827323},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1604055827323},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1604055827323},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1604055827323},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1604055827323},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1604055827323},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1604055827323},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1604055827323},{"_id":"public/2020/09/01/JavaScript-Notes/htmltree.jpg","hash":"164dd2e4fe565e9ea4dccc436d9d0f9484d807f3","modified":1604055827323},{"_id":"public/2020/08/03/Binary-Search/binary-search.png","hash":"07464cd8934ba18cd24d2f16bf700ee9d1a32ab4","modified":1604055827323},{"_id":"public/2020/09/11/Linked-list/image1.png","hash":"a6f5f6e33b452b75681f187ccb626c309ac83ea0","modified":1604055827323},{"_id":"public/2020/08/03/Greedy-Algorithm/largen-reach.png","hash":"65c5fe4cc7c549e23886375132e006ffb2e8e881","modified":1604055827323},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1604055827323},{"_id":"public/2020/09/11/Linked-list/image.png","hash":"99d89358565f62a05ca2b54b11d4a247e7af98f0","modified":1604055827323},{"_id":"public/2020/08/18/Backtracking/bitmask4.png","hash":"2c12dfaeec5c2e250853a9beaa39ab495568d815","modified":1604055827323},{"_id":"public/2020/09/27/Binary-Tree/二叉树.png","hash":"cb0e529886f3c5086139c1e2f4b02f259e26f1d0","modified":1604055827323},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1604055827323},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1604055827323},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1604055827323},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1604055827323},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1604055827323},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1604055827323},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1604055827323},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1604055827323},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1604055827323},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1604055827323},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1604055827323},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1604055827323},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1604055827323},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1604055827323},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1604055827323},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1604055827323},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1604055827323},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1604055827323},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1604055827323},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1604055827323},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1604055827323},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1604055827323},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1604055827323},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1604055827323},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1604055827323},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1604055827323},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1604055827323},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1604055827323},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1604055827323},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1604055827323},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1604055827323},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1604055827323},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1604055827323},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1604055827323},{"_id":"public/lib/fastclick/README.html","hash":"7caacb648dadb33d60f8eb515b0c9f5e7422831f","modified":1604055827323},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"d93ee404d9fdf816d07f77c002ba43a716760350","modified":1604055827323},{"_id":"public/lib/jquery_lazyload/README.html","hash":"fd960c31c8cfe7596f3064aef5a0551cda49eab5","modified":1604055827323},{"_id":"public/css/main.css","hash":"5a2112b7416d8dafeca5d802368656cee8d48069","modified":1604055827323},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1604055827323},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1604055827323},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1604055827323},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1604055827323},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1604055827323},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1604055827323},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1604055827323},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1604055827323},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1604055827323},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1604055827323},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1604055827323},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1604055827323},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1604055827323},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1604055827323},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1604055827323},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1604055827323},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1604055827323},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1604055827323},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1604055827323},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1604055827323},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1604055827323},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1604055827323},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1604055827323},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1604055827323},{"_id":"public/2020/08/03/Greedy-Algorithm/45_fig1.png","hash":"c263da40f4a55cad4e6b21c80d7e8849ef7ccec5","modified":1604055827323},{"_id":"public/images/avatar_2.gif","hash":"34226e87bf4e8cc6b2d2bce17295d7177da7ad2a","modified":1604055827323},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1604055827323}],"Category":[{"name":"Algorithm","_id":"ckgw5fafm0007mm9h1y8qdspx"},{"name":"前端框架","_id":"ckgw5fag1000wmm9h2xlhemsv"}],"Data":[],"Page":[{"title":"about","date":"2020-07-28T16:05:56.000Z","_content":"\n关于页面","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-07-29 00:05:56\n---\n\n关于页面","updated":"2020-07-29T01:50:06.708Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckgw5fafb0000mm9h63kq73bn","content":"<p>关于页面</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于页面</p>\n"},{"title":"categories","date":"2020-07-28T16:03:47.000Z","type":"categories","comments":0,"_content":" \n归档页面","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-07-29 00:03:47\ntype: \"categories\"\ncomments: false\n---\n \n归档页面","updated":"2020-07-29T01:50:14.660Z","path":"categories/index.html","layout":"page","_id":"ckgw5fafh0002mm9h8cgcg3wj","content":"<p>归档页面</p>\n","site":{"data":{}},"excerpt":"","more":"<p>归档页面</p>\n"},{"title":"tags","date":"2020-07-28T16:05:17.000Z","type":"tags","_content":"\n标签页面","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-07-29 00:05:17\ntype: tags\n---\n\n标签页面","updated":"2020-07-29T02:28:41.648Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckgw5fafj0004mm9h7ia7djt0","content":"<p>标签页面</p>\n","site":{"data":{}},"excerpt":"","more":"<p>标签页面</p>\n"}],"Post":[{"title":"Array","abbrlink":7791,"date":"2020-09-21T13:47:45.000Z","description":"数组相关题解","mathjax":true,"_content":"\n#### [56] Merge Intervals\n\n> Given a collection of intervals, merge all overlapping intervals.\n\n**时间复杂度**:\n\n排序时间($O(NlogN)$) + 遍历数组($O(N)$)\n\n**空间复杂度**: 直接借用js数组特性splice对原数组进行修改, 没有使用额外的空间. 因此为$O(1)$.\n\n**数组的sort方法**:\n\n当数组长度<=10的时候，采用插入排序($O(N^2)$)，>10的时候，采用快排($O(NlogN)$)。\n\n对于长度>1000的数组，采用的是快排与插入排序混合的方式进行排序.\n\n```javascript\n// 合并有交集的若干个区间\nvar merge = function (intervals) {\n  let len = intervals.length\n  if (len == 0 || len == 1) return intervals;\n  // 首先对区间进行排序 根据数组的第一列进行排序\n  // 如果不排序 后面在合并区间时也会两两交换 等于排序\n  intervals.sort((a, b) => a[0] - b[0]);\n  // 将数组中的区间进行两两合并\n  // 如果某两个邻近区间a1 a2没有合并完成\n  // 那么由于排序的原因 a1更不会和a3合并\n  let preIndex = 0, currIndex = 1, mergeRes;\n  while (currIndex < len) {\n    // 判断两个区间是否能合并\n    // 不能返回false 能则返回合并后的结果\n    mergeRes = isMerge(intervals[preIndex], intervals[currIndex]);\n    // 不能合并\n    if (mergeRes == false) {\n      preIndex = currIndex;\n      currIndex++;\n    } else { // 进行合并\n      intervals[preIndex] = mergeRes;\n      intervals.splice(currIndex, 1);\n      // currIndex 此时不变\n      len = intervals.length;\n    }\n  }\n  return intervals;\n};\n\nvar isMerge = (inter1, inter2) => {\n  // 两个区间能合并的前提条件是 有交集\n  let num0 = inter1[0], num1 = inter1[1], num2 = inter2[0], num3 = inter2[1];\n  if (num1 < num2) {\n    return false;\n  } else if (num1 >= num2 && num1 <= num3) { // 不是包含关系的交集\n    return [num0, num3];\n  } else { // 前一个区间包含后一个区间\n    return inter1;\n  }\n}\n```\n\n\n\n#### [57] Insert Interval\n\n> Given a set of *non-overlapping* intervals, insert a new interval into the intervals (merge if necessary).\n>\n> You may assume that the intervals were initially sorted according to their start times.\n\n**时间复杂度**:\n\n遍历了一遍数组, 后面的判断部分时间是常数级, 因此  $O(N)$.\n\n不得不说, 思路很好耶, 很巧妙利用了题目所给的条件. 比如有序, 比如区间合并, 这里的区间合并显得尤其简单.\n\n```javascript\n// intervals 本身是已经排好序的\nvar insert = function (intervals, newInterval) {\n  let left = [], right = [];\n  // 逐步比较 将完全不能与当前区间合并的区间分成左右两半部分\n  for (let item of intervals) {\n    if (item[1] < newInterval[0]) {\n      left.push(item);\n    }\n    if (item[0] > newInterval[1]) {\n      right.push(item);\n    }\n  }\n  // 说明剩余有可以合并的区间\n  // 剩余的每个区间都是可以和 newInterval 合并的\n  // 剩余的所有区间和 newInterval 最后会合并成一个区间\n  let ll = left.length, rl = right.length, len = intervals.length;\n  let s = newInterval[0], b = newInterval[1];\n  if (ll + rl != len) {\n    // 可以合并的区间的序号范围是 [ll, len-rl-1]\n    // 由于中间的每一个元素均和 newInterval 有交集\n    // 则最后会合并成一个区间 找到最后这个合并区间的最大值与最小值(即其范围)\n    s = Math.min(intervals[ll][0], s);\n    b = Math.max(intervals[len - rl - 1][1], b);\n  }\n  // 将合并部分的区间置于左右中间\n  // 拼接形成结果\n  let res = left.concat([[s, b]]).concat(right);\n  return res;\n}\n```\n\n\n\n#### [169] Majority Element\n\n> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n\n\n```javascript\n// solution 1\nvar majorityElement = function (nums) {\n  // 确定次数\n  let times = Math.floor(nums.length / 2);\n  let map = {};\n  for (let i of nums) {\n    if (i in map) {\n      map[i] += 1;\n    } else {\n      map[i] = 1;\n    }\n    // 每个值的出现次数更新之后, 都会判断一下是否是主要元素\n    // 由于题目说主要元素一定存在, 因此一定会存在元素的出现次数超过规定值\n    if (map[i] > times) return i;\n  }\n};\n```\n\n\n\n#### [54] Spiral Matrix\n\n> Given a matrix of *m* x *n* elements (*m* rows, *n* columns), return all elements of the matrix in spiral order.\n\n**时间复杂度**:\n\n遍历矩阵 $O(M*N)$.\n\n**空间复杂度**:\n\n除了返回的结果数组, 使用的额外空间为常数级, $O(1)$.\n\n```javascript\n// 旋转矩阵\n// 按层遍历 输出结果\nvar spiralOrder = function (matrix) {\n  let m = matrix.length; // 矩阵的行数\n  if (m == 0) return [];\n  let n = matrix[0].length; // 矩阵的列数\n  let res = []; // 存储结果序列\n  let top = 0, bottom = m - 1;\n  let left = 0, right = n - 1;\n  // 按照顺时针方向\n  while (top <= bottom && left <= right) {\n    // 添加top从左到右的一行\n    for (let i = left; i <= right; i++) {\n      res.push(matrix[top][i]);\n    }\n    if (top == bottom) break; // 判断结束情况\n\n    // 添加right从上到下的一列\n    for (let j = top + 1; j <= bottom; j++) {\n      res.push(matrix[j][right]);\n    }\n    if (left == right) break; // 判断结束情况\n\n    // 添加bottom从右到左的一行 \n    for (let i = right - 1; i >= left; i--) {\n      res.push(matrix[bottom][i]);\n    }\n\n    // 添加left从下到上的一列\n    for (let j = bottom - 1; j >= top + 1; j--) {\n      res.push(matrix[j][left]);\n    }\n    // 修改边界值 进入下一层\n    top++; left++; bottom--; right--;\n  }\n  // 直接在循环中判断两个边界是否相等 就不用再另外判断奇数偶数\n  // 然后分情况讨论了\n  /*\n  // m n 均是偶数 则退出循环后可以直接返回res\n  // m n 至少有一个为奇数\n  退出循环时则会出现 top==bottom 或者 left==right\n  if (m % 2 != 0 || n % 2 != 0) {\n    if (top == bottom) {\n      for (let i = left; i <= right; i++) {\n        res.push(matrix[top][i])\n      }\n    } else {\n      for (let i = top; i <= bottom; i++) {\n        res.push(matrix[i][left])\n      }\n    }\n  }\n  */\n  return res;\n}\n```\n\n\n\n#### [59] Spiral Matrix II\n\n> Given a positive integer *n*, generate a square matrix filled with elements from 1 to *n*2 in spiral order.\n\n借鉴上一题的思路.\n\n**时间复杂度**: O(N*N), 遍历了整个二维数组.\n\n**空间复杂度**: O(1), 除了返回的二维结果数组, 其余为常量级.\n\n```javascript\nvar generateMatrix = function (n) {\n  let top = 0, bottom = n - 1;\n  let left = 0, right = n - 1;\n  // 注意不要使用 let arr = new Array(n).fill(new Array(n))\n  // 这样fill填充的是同一个数组的引用, 不是多个,(坑)\n  // 建议使用for循环初始化结果数组\n  let arr = new Array(n);\n  for (let i = 0; i < n; i++) {\n    arr[i] = new Array(n);\n  }\n  let val = 0;\n  // 按照顺时针的方向逐行逐列填充递增值\n  // 填充完外圈再填充内圈\n  while (top <= bottom && left <= right) {\n    // n为奇数 最后 top==bottom left==right\n    // 只会走下面这一个for循环 其余for循环均不满足条件\n    // n 为偶数 最后 top+1==bottom left+1==right\n    // 最后一个for循环不满足条件\n    for (let i = left; i <= right; i++) {\n      arr[top][i] = ++val;\n    }\n    for (let i = top + 1; i <= bottom; i++) {\n      arr[i][right] = ++val;\n    }\n    for (let i = right - 1; i >= left; i--) {\n      arr[bottom][i] = ++val;\n    }\n    for (let i = bottom - 1; i >= top + 1; i--) {\n      arr[i][left] = ++val;\n    }\n    top++; bottom--; left++; right--;\n  }\n  return arr;\n};\n```\n\n\n\n#### [48] Rotate Image\n\n> You are given an *n* x *n* 2D `matrix` representing an image, rotate the image by 90 degrees (clockwise).\n>\n> You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n**时间复杂度**:\n\n双重循环 $O(N)$.\n\n**空间复杂度**:\n\nO(1). 原地修改数组内容.\n\n```javascript\n// 思路就是: 旋转完外圈, 再旋转内圈\n// 直至内圈没有可以旋转的圈\n// 没有啥可说的, 就是不断画图, 标注坐标\n// 找到需要交换值的四个位置坐标间的联系与规律\nvar rotate = function (matrix) {\n  let n = matrix.length;\n  // 计算层数\n  let levels = Math.floor(n / 2);\n  let end, a, b, c, d;\n  // 遍历层数\n  for (let t = 0; t < levels; t++) {\n    // 每一层右上角节点的纵坐标值\n    end = n - 1 - t;\n    // 每一层的矩阵大小为 m*m\n    // 则只有前m-1个元素需要移动\n    for (let i = t; i <= end - 1; i++) {\n      // 需要进行交换的四个点的值\n      a = matrix[t][i];\n      b = matrix[i][end];\n      c = matrix[end][end - (i - t)];\n      d = matrix[end - (i - t)][t];\n      // 进行交换\n      matrix[t][i] = d;\n      matrix[i][end] = a;\n      matrix[end][end - (i - t)] = b;\n      matrix[end - (i - t)][t] = c;\n    }\n  }\n};\n```\n\n","source":"_posts/Array.md","raw":"---\ntitle: Array\nabbrlink: 7791\ndate: 2020-09-21 21:47:45\ntags:\ndescription: 数组相关题解\nmathjax: true\n---\n\n#### [56] Merge Intervals\n\n> Given a collection of intervals, merge all overlapping intervals.\n\n**时间复杂度**:\n\n排序时间($O(NlogN)$) + 遍历数组($O(N)$)\n\n**空间复杂度**: 直接借用js数组特性splice对原数组进行修改, 没有使用额外的空间. 因此为$O(1)$.\n\n**数组的sort方法**:\n\n当数组长度<=10的时候，采用插入排序($O(N^2)$)，>10的时候，采用快排($O(NlogN)$)。\n\n对于长度>1000的数组，采用的是快排与插入排序混合的方式进行排序.\n\n```javascript\n// 合并有交集的若干个区间\nvar merge = function (intervals) {\n  let len = intervals.length\n  if (len == 0 || len == 1) return intervals;\n  // 首先对区间进行排序 根据数组的第一列进行排序\n  // 如果不排序 后面在合并区间时也会两两交换 等于排序\n  intervals.sort((a, b) => a[0] - b[0]);\n  // 将数组中的区间进行两两合并\n  // 如果某两个邻近区间a1 a2没有合并完成\n  // 那么由于排序的原因 a1更不会和a3合并\n  let preIndex = 0, currIndex = 1, mergeRes;\n  while (currIndex < len) {\n    // 判断两个区间是否能合并\n    // 不能返回false 能则返回合并后的结果\n    mergeRes = isMerge(intervals[preIndex], intervals[currIndex]);\n    // 不能合并\n    if (mergeRes == false) {\n      preIndex = currIndex;\n      currIndex++;\n    } else { // 进行合并\n      intervals[preIndex] = mergeRes;\n      intervals.splice(currIndex, 1);\n      // currIndex 此时不变\n      len = intervals.length;\n    }\n  }\n  return intervals;\n};\n\nvar isMerge = (inter1, inter2) => {\n  // 两个区间能合并的前提条件是 有交集\n  let num0 = inter1[0], num1 = inter1[1], num2 = inter2[0], num3 = inter2[1];\n  if (num1 < num2) {\n    return false;\n  } else if (num1 >= num2 && num1 <= num3) { // 不是包含关系的交集\n    return [num0, num3];\n  } else { // 前一个区间包含后一个区间\n    return inter1;\n  }\n}\n```\n\n\n\n#### [57] Insert Interval\n\n> Given a set of *non-overlapping* intervals, insert a new interval into the intervals (merge if necessary).\n>\n> You may assume that the intervals were initially sorted according to their start times.\n\n**时间复杂度**:\n\n遍历了一遍数组, 后面的判断部分时间是常数级, 因此  $O(N)$.\n\n不得不说, 思路很好耶, 很巧妙利用了题目所给的条件. 比如有序, 比如区间合并, 这里的区间合并显得尤其简单.\n\n```javascript\n// intervals 本身是已经排好序的\nvar insert = function (intervals, newInterval) {\n  let left = [], right = [];\n  // 逐步比较 将完全不能与当前区间合并的区间分成左右两半部分\n  for (let item of intervals) {\n    if (item[1] < newInterval[0]) {\n      left.push(item);\n    }\n    if (item[0] > newInterval[1]) {\n      right.push(item);\n    }\n  }\n  // 说明剩余有可以合并的区间\n  // 剩余的每个区间都是可以和 newInterval 合并的\n  // 剩余的所有区间和 newInterval 最后会合并成一个区间\n  let ll = left.length, rl = right.length, len = intervals.length;\n  let s = newInterval[0], b = newInterval[1];\n  if (ll + rl != len) {\n    // 可以合并的区间的序号范围是 [ll, len-rl-1]\n    // 由于中间的每一个元素均和 newInterval 有交集\n    // 则最后会合并成一个区间 找到最后这个合并区间的最大值与最小值(即其范围)\n    s = Math.min(intervals[ll][0], s);\n    b = Math.max(intervals[len - rl - 1][1], b);\n  }\n  // 将合并部分的区间置于左右中间\n  // 拼接形成结果\n  let res = left.concat([[s, b]]).concat(right);\n  return res;\n}\n```\n\n\n\n#### [169] Majority Element\n\n> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n\n\n```javascript\n// solution 1\nvar majorityElement = function (nums) {\n  // 确定次数\n  let times = Math.floor(nums.length / 2);\n  let map = {};\n  for (let i of nums) {\n    if (i in map) {\n      map[i] += 1;\n    } else {\n      map[i] = 1;\n    }\n    // 每个值的出现次数更新之后, 都会判断一下是否是主要元素\n    // 由于题目说主要元素一定存在, 因此一定会存在元素的出现次数超过规定值\n    if (map[i] > times) return i;\n  }\n};\n```\n\n\n\n#### [54] Spiral Matrix\n\n> Given a matrix of *m* x *n* elements (*m* rows, *n* columns), return all elements of the matrix in spiral order.\n\n**时间复杂度**:\n\n遍历矩阵 $O(M*N)$.\n\n**空间复杂度**:\n\n除了返回的结果数组, 使用的额外空间为常数级, $O(1)$.\n\n```javascript\n// 旋转矩阵\n// 按层遍历 输出结果\nvar spiralOrder = function (matrix) {\n  let m = matrix.length; // 矩阵的行数\n  if (m == 0) return [];\n  let n = matrix[0].length; // 矩阵的列数\n  let res = []; // 存储结果序列\n  let top = 0, bottom = m - 1;\n  let left = 0, right = n - 1;\n  // 按照顺时针方向\n  while (top <= bottom && left <= right) {\n    // 添加top从左到右的一行\n    for (let i = left; i <= right; i++) {\n      res.push(matrix[top][i]);\n    }\n    if (top == bottom) break; // 判断结束情况\n\n    // 添加right从上到下的一列\n    for (let j = top + 1; j <= bottom; j++) {\n      res.push(matrix[j][right]);\n    }\n    if (left == right) break; // 判断结束情况\n\n    // 添加bottom从右到左的一行 \n    for (let i = right - 1; i >= left; i--) {\n      res.push(matrix[bottom][i]);\n    }\n\n    // 添加left从下到上的一列\n    for (let j = bottom - 1; j >= top + 1; j--) {\n      res.push(matrix[j][left]);\n    }\n    // 修改边界值 进入下一层\n    top++; left++; bottom--; right--;\n  }\n  // 直接在循环中判断两个边界是否相等 就不用再另外判断奇数偶数\n  // 然后分情况讨论了\n  /*\n  // m n 均是偶数 则退出循环后可以直接返回res\n  // m n 至少有一个为奇数\n  退出循环时则会出现 top==bottom 或者 left==right\n  if (m % 2 != 0 || n % 2 != 0) {\n    if (top == bottom) {\n      for (let i = left; i <= right; i++) {\n        res.push(matrix[top][i])\n      }\n    } else {\n      for (let i = top; i <= bottom; i++) {\n        res.push(matrix[i][left])\n      }\n    }\n  }\n  */\n  return res;\n}\n```\n\n\n\n#### [59] Spiral Matrix II\n\n> Given a positive integer *n*, generate a square matrix filled with elements from 1 to *n*2 in spiral order.\n\n借鉴上一题的思路.\n\n**时间复杂度**: O(N*N), 遍历了整个二维数组.\n\n**空间复杂度**: O(1), 除了返回的二维结果数组, 其余为常量级.\n\n```javascript\nvar generateMatrix = function (n) {\n  let top = 0, bottom = n - 1;\n  let left = 0, right = n - 1;\n  // 注意不要使用 let arr = new Array(n).fill(new Array(n))\n  // 这样fill填充的是同一个数组的引用, 不是多个,(坑)\n  // 建议使用for循环初始化结果数组\n  let arr = new Array(n);\n  for (let i = 0; i < n; i++) {\n    arr[i] = new Array(n);\n  }\n  let val = 0;\n  // 按照顺时针的方向逐行逐列填充递增值\n  // 填充完外圈再填充内圈\n  while (top <= bottom && left <= right) {\n    // n为奇数 最后 top==bottom left==right\n    // 只会走下面这一个for循环 其余for循环均不满足条件\n    // n 为偶数 最后 top+1==bottom left+1==right\n    // 最后一个for循环不满足条件\n    for (let i = left; i <= right; i++) {\n      arr[top][i] = ++val;\n    }\n    for (let i = top + 1; i <= bottom; i++) {\n      arr[i][right] = ++val;\n    }\n    for (let i = right - 1; i >= left; i--) {\n      arr[bottom][i] = ++val;\n    }\n    for (let i = bottom - 1; i >= top + 1; i--) {\n      arr[i][left] = ++val;\n    }\n    top++; bottom--; left++; right--;\n  }\n  return arr;\n};\n```\n\n\n\n#### [48] Rotate Image\n\n> You are given an *n* x *n* 2D `matrix` representing an image, rotate the image by 90 degrees (clockwise).\n>\n> You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n**时间复杂度**:\n\n双重循环 $O(N)$.\n\n**空间复杂度**:\n\nO(1). 原地修改数组内容.\n\n```javascript\n// 思路就是: 旋转完外圈, 再旋转内圈\n// 直至内圈没有可以旋转的圈\n// 没有啥可说的, 就是不断画图, 标注坐标\n// 找到需要交换值的四个位置坐标间的联系与规律\nvar rotate = function (matrix) {\n  let n = matrix.length;\n  // 计算层数\n  let levels = Math.floor(n / 2);\n  let end, a, b, c, d;\n  // 遍历层数\n  for (let t = 0; t < levels; t++) {\n    // 每一层右上角节点的纵坐标值\n    end = n - 1 - t;\n    // 每一层的矩阵大小为 m*m\n    // 则只有前m-1个元素需要移动\n    for (let i = t; i <= end - 1; i++) {\n      // 需要进行交换的四个点的值\n      a = matrix[t][i];\n      b = matrix[i][end];\n      c = matrix[end][end - (i - t)];\n      d = matrix[end - (i - t)][t];\n      // 进行交换\n      matrix[t][i] = d;\n      matrix[i][end] = a;\n      matrix[end][end - (i - t)] = b;\n      matrix[end - (i - t)][t] = c;\n    }\n  }\n};\n```\n\n","slug":"Array","published":1,"updated":"2020-10-30T10:36:29.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5faff0001mm9h5brgaj73","content":"<h4 id=\"56-Merge-Intervals\"><a href=\"#56-Merge-Intervals\" class=\"headerlink\" title=\"[56] Merge Intervals\"></a>[56] Merge Intervals</h4><blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>排序时间($O(NlogN)$) + 遍历数组($O(N)$)</p>\n<p><strong>空间复杂度</strong>: 直接借用js数组特性splice对原数组进行修改, 没有使用额外的空间. 因此为$O(1)$.</p>\n<p><strong>数组的sort方法</strong>:</p>\n<p>当数组长度&lt;=10的时候，采用插入排序($O(N^2)$)，&gt;10的时候，采用快排($O(NlogN)$)。</p>\n<p>对于长度&gt;1000的数组，采用的是快排与插入排序混合的方式进行排序.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 合并有交集的若干个区间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">intervals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = intervals.length</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span> || len == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">  <span class=\"comment\">// 首先对区间进行排序 根据数组的第一列进行排序</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不排序 后面在合并区间时也会两两交换 等于排序</span></span><br><span class=\"line\">  intervals.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"comment\">// 将数组中的区间进行两两合并</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果某两个邻近区间a1 a2没有合并完成</span></span><br><span class=\"line\">  <span class=\"comment\">// 那么由于排序的原因 a1更不会和a3合并</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> preIndex = <span class=\"number\">0</span>, currIndex = <span class=\"number\">1</span>, mergeRes;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (currIndex &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断两个区间是否能合并</span></span><br><span class=\"line\">    <span class=\"comment\">// 不能返回false 能则返回合并后的结果</span></span><br><span class=\"line\">    mergeRes = isMerge(intervals[preIndex], intervals[currIndex]);</span><br><span class=\"line\">    <span class=\"comment\">// 不能合并</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mergeRes == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      preIndex = currIndex;</span><br><span class=\"line\">      currIndex++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 进行合并</span></span><br><span class=\"line\">      intervals[preIndex] = mergeRes;</span><br><span class=\"line\">      intervals.splice(currIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// currIndex 此时不变</span></span><br><span class=\"line\">      len = intervals.length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> isMerge = <span class=\"function\">(<span class=\"params\">inter1, inter2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 两个区间能合并的前提条件是 有交集</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> num0 = inter1[<span class=\"number\">0</span>], num1 = inter1[<span class=\"number\">1</span>], num2 = inter2[<span class=\"number\">0</span>], num3 = inter2[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 &lt; num2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num1 &gt;= num2 &amp;&amp; num1 &lt;= num3) &#123; <span class=\"comment\">// 不是包含关系的交集</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [num0, num3];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 前一个区间包含后一个区间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> inter1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"57-Insert-Interval\"><a href=\"#57-Insert-Interval\" class=\"headerlink\" title=\"[57] Insert Interval\"></a>[57] Insert Interval</h4><blockquote>\n<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>\n<p>You may assume that the intervals were initially sorted according to their start times.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>遍历了一遍数组, 后面的判断部分时间是常数级, 因此  $O(N)$.</p>\n<p>不得不说, 思路很好耶, 很巧妙利用了题目所给的条件. 比如有序, 比如区间合并, 这里的区间合并显得尤其简单.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// intervals 本身是已经排好序的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">intervals, newInterval</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = [], right = [];</span><br><span class=\"line\">  <span class=\"comment\">// 逐步比较 将完全不能与当前区间合并的区间分成左右两半部分</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> intervals) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item[<span class=\"number\">1</span>] &lt; newInterval[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      left.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item[<span class=\"number\">0</span>] &gt; newInterval[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      right.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 说明剩余有可以合并的区间</span></span><br><span class=\"line\">  <span class=\"comment\">// 剩余的每个区间都是可以和 newInterval 合并的</span></span><br><span class=\"line\">  <span class=\"comment\">// 剩余的所有区间和 newInterval 最后会合并成一个区间</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ll = left.length, rl = right.length, len = intervals.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> s = newInterval[<span class=\"number\">0</span>], b = newInterval[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ll + rl != len) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以合并的区间的序号范围是 [ll, len-rl-1]</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于中间的每一个元素均和 newInterval 有交集</span></span><br><span class=\"line\">    <span class=\"comment\">// 则最后会合并成一个区间 找到最后这个合并区间的最大值与最小值(即其范围)</span></span><br><span class=\"line\">    s = <span class=\"built_in\">Math</span>.min(intervals[ll][<span class=\"number\">0</span>], s);</span><br><span class=\"line\">    b = <span class=\"built_in\">Math</span>.max(intervals[len - rl - <span class=\"number\">1</span>][<span class=\"number\">1</span>], b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将合并部分的区间置于左右中间</span></span><br><span class=\"line\">  <span class=\"comment\">// 拼接形成结果</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = left.concat([[s, b]]).concat(right);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"169-Majority-Element\"><a href=\"#169-Majority-Element\" class=\"headerlink\" title=\"[169] Majority Element\"></a>[169] Majority Element</h4><blockquote>\n<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> majorityElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确定次数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> times = <span class=\"built_in\">Math</span>.floor(nums.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">      map[i] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      map[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 每个值的出现次数更新之后, 都会判断一下是否是主要元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于题目说主要元素一定存在, 因此一定会存在元素的出现次数超过规定值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[i] &gt; times) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"54-Spiral-Matrix\"><a href=\"#54-Spiral-Matrix\" class=\"headerlink\" title=\"[54] Spiral Matrix\"></a>[54] Spiral Matrix</h4><blockquote>\n<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>遍历矩阵 $O(M*N)$.</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>除了返回的结果数组, 使用的额外空间为常数级, $O(1)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 旋转矩阵</span></span><br><span class=\"line\"><span class=\"comment\">// 按层遍历 输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> spiralOrder = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = matrix.length; <span class=\"comment\">// 矩阵的行数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = matrix[<span class=\"number\">0</span>].length; <span class=\"comment\">// 矩阵的列数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []; <span class=\"comment\">// 存储结果序列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> top = <span class=\"number\">0</span>, bottom = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 按照顺时针方向</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加top从左到右的一行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class=\"line\">      res.push(matrix[top][i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top == bottom) <span class=\"keyword\">break</span>; <span class=\"comment\">// 判断结束情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加right从上到下的一列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = top + <span class=\"number\">1</span>; j &lt;= bottom; j++) &#123;</span><br><span class=\"line\">      res.push(matrix[j][right]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left == right) <span class=\"keyword\">break</span>; <span class=\"comment\">// 判断结束情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加bottom从右到左的一行 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = right - <span class=\"number\">1</span>; i &gt;= left; i--) &#123;</span><br><span class=\"line\">      res.push(matrix[bottom][i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加left从下到上的一列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = bottom - <span class=\"number\">1</span>; j &gt;= top + <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">      res.push(matrix[j][left]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 修改边界值 进入下一层</span></span><br><span class=\"line\">    top++; left++; bottom--; right--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 直接在循环中判断两个边界是否相等 就不用再另外判断奇数偶数</span></span><br><span class=\"line\">  <span class=\"comment\">// 然后分情况讨论了</span></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  // m n 均是偶数 则退出循环后可以直接返回res</span></span><br><span class=\"line\"><span class=\"comment\">  // m n 至少有一个为奇数</span></span><br><span class=\"line\"><span class=\"comment\">  退出循环时则会出现 top==bottom 或者 left==right</span></span><br><span class=\"line\"><span class=\"comment\">  if (m % 2 != 0 || n % 2 != 0) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if (top == bottom) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      for (let i = left; i &lt;= right; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        res.push(matrix[top][i])</span></span><br><span class=\"line\"><span class=\"comment\">      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      for (let i = top; i &lt;= bottom; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        res.push(matrix[i][left])</span></span><br><span class=\"line\"><span class=\"comment\">      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"59-Spiral-Matrix-II\"><a href=\"#59-Spiral-Matrix-II\" class=\"headerlink\" title=\"[59] Spiral Matrix II\"></a>[59] Spiral Matrix II</h4><blockquote>\n<p>Given a positive integer <em>n</em>, generate a square matrix filled with elements from 1 to <em>n</em>2 in spiral order.</p>\n</blockquote>\n<p>借鉴上一题的思路.</p>\n<p><strong>时间复杂度</strong>: O(N*N), 遍历了整个二维数组.</p>\n<p><strong>空间复杂度</strong>: O(1), 除了返回的二维结果数组, 其余为常量级.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> generateMatrix = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> top = <span class=\"number\">0</span>, bottom = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 注意不要使用 let arr = new Array(n).fill(new Array(n))</span></span><br><span class=\"line\">  <span class=\"comment\">// 这样fill填充的是同一个数组的引用, 不是多个,(坑)</span></span><br><span class=\"line\">  <span class=\"comment\">// 建议使用for循环初始化结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    arr[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 按照顺时针的方向逐行逐列填充递增值</span></span><br><span class=\"line\">  <span class=\"comment\">// 填充完外圈再填充内圈</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// n为奇数 最后 top==bottom left==right</span></span><br><span class=\"line\">    <span class=\"comment\">// 只会走下面这一个for循环 其余for循环均不满足条件</span></span><br><span class=\"line\">    <span class=\"comment\">// n 为偶数 最后 top+1==bottom left+1==right</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后一个for循环不满足条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class=\"line\">      arr[top][i] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = top + <span class=\"number\">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class=\"line\">      arr[i][right] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = right - <span class=\"number\">1</span>; i &gt;= left; i--) &#123;</span><br><span class=\"line\">      arr[bottom][i] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = bottom - <span class=\"number\">1</span>; i &gt;= top + <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">      arr[i][left] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    top++; bottom--; left++; right--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"48-Rotate-Image\"><a href=\"#48-Rotate-Image\" class=\"headerlink\" title=\"[48] Rotate Image\"></a>[48] Rotate Image</h4><blockquote>\n<p>You are given an <em>n</em> x <em>n</em> 2D <code>matrix</code> representing an image, rotate the image by 90 degrees (clockwise).</p>\n<p>You have to rotate the image <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>双重循环 $O(N)$.</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>O(1). 原地修改数组内容.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路就是: 旋转完外圈, 再旋转内圈</span></span><br><span class=\"line\"><span class=\"comment\">// 直至内圈没有可以旋转的圈</span></span><br><span class=\"line\"><span class=\"comment\">// 没有啥可说的, 就是不断画图, 标注坐标</span></span><br><span class=\"line\"><span class=\"comment\">// 找到需要交换值的四个位置坐标间的联系与规律</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rotate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = matrix.length;</span><br><span class=\"line\">  <span class=\"comment\">// 计算层数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> levels = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> end, a, b, c, d;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历层数</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = <span class=\"number\">0</span>; t &lt; levels; t++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每一层右上角节点的纵坐标值</span></span><br><span class=\"line\">    end = n - <span class=\"number\">1</span> - t;</span><br><span class=\"line\">    <span class=\"comment\">// 每一层的矩阵大小为 m*m</span></span><br><span class=\"line\">    <span class=\"comment\">// 则只有前m-1个元素需要移动</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = t; i &lt;= end - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 需要进行交换的四个点的值</span></span><br><span class=\"line\">      a = matrix[t][i];</span><br><span class=\"line\">      b = matrix[i][end];</span><br><span class=\"line\">      c = matrix[end][end - (i - t)];</span><br><span class=\"line\">      d = matrix[end - (i - t)][t];</span><br><span class=\"line\">      <span class=\"comment\">// 进行交换</span></span><br><span class=\"line\">      matrix[t][i] = d;</span><br><span class=\"line\">      matrix[i][end] = a;</span><br><span class=\"line\">      matrix[end][end - (i - t)] = b;</span><br><span class=\"line\">      matrix[end - (i - t)][t] = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"56-Merge-Intervals\"><a href=\"#56-Merge-Intervals\" class=\"headerlink\" title=\"[56] Merge Intervals\"></a>[56] Merge Intervals</h4><blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>排序时间($O(NlogN)$) + 遍历数组($O(N)$)</p>\n<p><strong>空间复杂度</strong>: 直接借用js数组特性splice对原数组进行修改, 没有使用额外的空间. 因此为$O(1)$.</p>\n<p><strong>数组的sort方法</strong>:</p>\n<p>当数组长度&lt;=10的时候，采用插入排序($O(N^2)$)，&gt;10的时候，采用快排($O(NlogN)$)。</p>\n<p>对于长度&gt;1000的数组，采用的是快排与插入排序混合的方式进行排序.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 合并有交集的若干个区间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">intervals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = intervals.length</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span> || len == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">  <span class=\"comment\">// 首先对区间进行排序 根据数组的第一列进行排序</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不排序 后面在合并区间时也会两两交换 等于排序</span></span><br><span class=\"line\">  intervals.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"comment\">// 将数组中的区间进行两两合并</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果某两个邻近区间a1 a2没有合并完成</span></span><br><span class=\"line\">  <span class=\"comment\">// 那么由于排序的原因 a1更不会和a3合并</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> preIndex = <span class=\"number\">0</span>, currIndex = <span class=\"number\">1</span>, mergeRes;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (currIndex &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断两个区间是否能合并</span></span><br><span class=\"line\">    <span class=\"comment\">// 不能返回false 能则返回合并后的结果</span></span><br><span class=\"line\">    mergeRes = isMerge(intervals[preIndex], intervals[currIndex]);</span><br><span class=\"line\">    <span class=\"comment\">// 不能合并</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mergeRes == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      preIndex = currIndex;</span><br><span class=\"line\">      currIndex++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 进行合并</span></span><br><span class=\"line\">      intervals[preIndex] = mergeRes;</span><br><span class=\"line\">      intervals.splice(currIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// currIndex 此时不变</span></span><br><span class=\"line\">      len = intervals.length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> isMerge = <span class=\"function\">(<span class=\"params\">inter1, inter2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 两个区间能合并的前提条件是 有交集</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> num0 = inter1[<span class=\"number\">0</span>], num1 = inter1[<span class=\"number\">1</span>], num2 = inter2[<span class=\"number\">0</span>], num3 = inter2[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 &lt; num2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num1 &gt;= num2 &amp;&amp; num1 &lt;= num3) &#123; <span class=\"comment\">// 不是包含关系的交集</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [num0, num3];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 前一个区间包含后一个区间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> inter1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"57-Insert-Interval\"><a href=\"#57-Insert-Interval\" class=\"headerlink\" title=\"[57] Insert Interval\"></a>[57] Insert Interval</h4><blockquote>\n<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>\n<p>You may assume that the intervals were initially sorted according to their start times.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>遍历了一遍数组, 后面的判断部分时间是常数级, 因此  $O(N)$.</p>\n<p>不得不说, 思路很好耶, 很巧妙利用了题目所给的条件. 比如有序, 比如区间合并, 这里的区间合并显得尤其简单.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// intervals 本身是已经排好序的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">intervals, newInterval</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = [], right = [];</span><br><span class=\"line\">  <span class=\"comment\">// 逐步比较 将完全不能与当前区间合并的区间分成左右两半部分</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> intervals) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item[<span class=\"number\">1</span>] &lt; newInterval[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      left.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item[<span class=\"number\">0</span>] &gt; newInterval[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      right.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 说明剩余有可以合并的区间</span></span><br><span class=\"line\">  <span class=\"comment\">// 剩余的每个区间都是可以和 newInterval 合并的</span></span><br><span class=\"line\">  <span class=\"comment\">// 剩余的所有区间和 newInterval 最后会合并成一个区间</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ll = left.length, rl = right.length, len = intervals.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> s = newInterval[<span class=\"number\">0</span>], b = newInterval[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ll + rl != len) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以合并的区间的序号范围是 [ll, len-rl-1]</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于中间的每一个元素均和 newInterval 有交集</span></span><br><span class=\"line\">    <span class=\"comment\">// 则最后会合并成一个区间 找到最后这个合并区间的最大值与最小值(即其范围)</span></span><br><span class=\"line\">    s = <span class=\"built_in\">Math</span>.min(intervals[ll][<span class=\"number\">0</span>], s);</span><br><span class=\"line\">    b = <span class=\"built_in\">Math</span>.max(intervals[len - rl - <span class=\"number\">1</span>][<span class=\"number\">1</span>], b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将合并部分的区间置于左右中间</span></span><br><span class=\"line\">  <span class=\"comment\">// 拼接形成结果</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = left.concat([[s, b]]).concat(right);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"169-Majority-Element\"><a href=\"#169-Majority-Element\" class=\"headerlink\" title=\"[169] Majority Element\"></a>[169] Majority Element</h4><blockquote>\n<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> majorityElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确定次数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> times = <span class=\"built_in\">Math</span>.floor(nums.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">      map[i] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      map[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 每个值的出现次数更新之后, 都会判断一下是否是主要元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于题目说主要元素一定存在, 因此一定会存在元素的出现次数超过规定值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[i] &gt; times) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"54-Spiral-Matrix\"><a href=\"#54-Spiral-Matrix\" class=\"headerlink\" title=\"[54] Spiral Matrix\"></a>[54] Spiral Matrix</h4><blockquote>\n<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>遍历矩阵 $O(M*N)$.</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>除了返回的结果数组, 使用的额外空间为常数级, $O(1)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 旋转矩阵</span></span><br><span class=\"line\"><span class=\"comment\">// 按层遍历 输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> spiralOrder = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = matrix.length; <span class=\"comment\">// 矩阵的行数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = matrix[<span class=\"number\">0</span>].length; <span class=\"comment\">// 矩阵的列数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []; <span class=\"comment\">// 存储结果序列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> top = <span class=\"number\">0</span>, bottom = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 按照顺时针方向</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加top从左到右的一行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class=\"line\">      res.push(matrix[top][i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top == bottom) <span class=\"keyword\">break</span>; <span class=\"comment\">// 判断结束情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加right从上到下的一列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = top + <span class=\"number\">1</span>; j &lt;= bottom; j++) &#123;</span><br><span class=\"line\">      res.push(matrix[j][right]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left == right) <span class=\"keyword\">break</span>; <span class=\"comment\">// 判断结束情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加bottom从右到左的一行 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = right - <span class=\"number\">1</span>; i &gt;= left; i--) &#123;</span><br><span class=\"line\">      res.push(matrix[bottom][i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加left从下到上的一列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = bottom - <span class=\"number\">1</span>; j &gt;= top + <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">      res.push(matrix[j][left]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 修改边界值 进入下一层</span></span><br><span class=\"line\">    top++; left++; bottom--; right--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 直接在循环中判断两个边界是否相等 就不用再另外判断奇数偶数</span></span><br><span class=\"line\">  <span class=\"comment\">// 然后分情况讨论了</span></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  // m n 均是偶数 则退出循环后可以直接返回res</span></span><br><span class=\"line\"><span class=\"comment\">  // m n 至少有一个为奇数</span></span><br><span class=\"line\"><span class=\"comment\">  退出循环时则会出现 top==bottom 或者 left==right</span></span><br><span class=\"line\"><span class=\"comment\">  if (m % 2 != 0 || n % 2 != 0) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if (top == bottom) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      for (let i = left; i &lt;= right; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        res.push(matrix[top][i])</span></span><br><span class=\"line\"><span class=\"comment\">      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      for (let i = top; i &lt;= bottom; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        res.push(matrix[i][left])</span></span><br><span class=\"line\"><span class=\"comment\">      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"59-Spiral-Matrix-II\"><a href=\"#59-Spiral-Matrix-II\" class=\"headerlink\" title=\"[59] Spiral Matrix II\"></a>[59] Spiral Matrix II</h4><blockquote>\n<p>Given a positive integer <em>n</em>, generate a square matrix filled with elements from 1 to <em>n</em>2 in spiral order.</p>\n</blockquote>\n<p>借鉴上一题的思路.</p>\n<p><strong>时间复杂度</strong>: O(N*N), 遍历了整个二维数组.</p>\n<p><strong>空间复杂度</strong>: O(1), 除了返回的二维结果数组, 其余为常量级.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> generateMatrix = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> top = <span class=\"number\">0</span>, bottom = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 注意不要使用 let arr = new Array(n).fill(new Array(n))</span></span><br><span class=\"line\">  <span class=\"comment\">// 这样fill填充的是同一个数组的引用, 不是多个,(坑)</span></span><br><span class=\"line\">  <span class=\"comment\">// 建议使用for循环初始化结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    arr[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 按照顺时针的方向逐行逐列填充递增值</span></span><br><span class=\"line\">  <span class=\"comment\">// 填充完外圈再填充内圈</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// n为奇数 最后 top==bottom left==right</span></span><br><span class=\"line\">    <span class=\"comment\">// 只会走下面这一个for循环 其余for循环均不满足条件</span></span><br><span class=\"line\">    <span class=\"comment\">// n 为偶数 最后 top+1==bottom left+1==right</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后一个for循环不满足条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class=\"line\">      arr[top][i] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = top + <span class=\"number\">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class=\"line\">      arr[i][right] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = right - <span class=\"number\">1</span>; i &gt;= left; i--) &#123;</span><br><span class=\"line\">      arr[bottom][i] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = bottom - <span class=\"number\">1</span>; i &gt;= top + <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">      arr[i][left] = ++val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    top++; bottom--; left++; right--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"48-Rotate-Image\"><a href=\"#48-Rotate-Image\" class=\"headerlink\" title=\"[48] Rotate Image\"></a>[48] Rotate Image</h4><blockquote>\n<p>You are given an <em>n</em> x <em>n</em> 2D <code>matrix</code> representing an image, rotate the image by 90 degrees (clockwise).</p>\n<p>You have to rotate the image <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>双重循环 $O(N)$.</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>O(1). 原地修改数组内容.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路就是: 旋转完外圈, 再旋转内圈</span></span><br><span class=\"line\"><span class=\"comment\">// 直至内圈没有可以旋转的圈</span></span><br><span class=\"line\"><span class=\"comment\">// 没有啥可说的, 就是不断画图, 标注坐标</span></span><br><span class=\"line\"><span class=\"comment\">// 找到需要交换值的四个位置坐标间的联系与规律</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rotate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = matrix.length;</span><br><span class=\"line\">  <span class=\"comment\">// 计算层数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> levels = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> end, a, b, c, d;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历层数</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = <span class=\"number\">0</span>; t &lt; levels; t++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每一层右上角节点的纵坐标值</span></span><br><span class=\"line\">    end = n - <span class=\"number\">1</span> - t;</span><br><span class=\"line\">    <span class=\"comment\">// 每一层的矩阵大小为 m*m</span></span><br><span class=\"line\">    <span class=\"comment\">// 则只有前m-1个元素需要移动</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = t; i &lt;= end - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 需要进行交换的四个点的值</span></span><br><span class=\"line\">      a = matrix[t][i];</span><br><span class=\"line\">      b = matrix[i][end];</span><br><span class=\"line\">      c = matrix[end][end - (i - t)];</span><br><span class=\"line\">      d = matrix[end - (i - t)][t];</span><br><span class=\"line\">      <span class=\"comment\">// 进行交换</span></span><br><span class=\"line\">      matrix[t][i] = d;</span><br><span class=\"line\">      matrix[i][end] = a;</span><br><span class=\"line\">      matrix[end][end - (i - t)] = b;</span><br><span class=\"line\">      matrix[end - (i - t)][t] = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Basic Knowledge","abbrlink":1793,"date":"2020-09-30T06:06:46.000Z","_content":"\n# 数据结构与算法\n\n数据结构是工具, 算法是通过合适的工具解决特定问题的方法.\n\n## 数据结构的存储方式\n\n数据结构的存储方式只有两种: 数组(顺序存储)与链表(链式存储)\n\n| 数据结构 | 定义                                                       | 数组                          | 链表                                                         |\n| -------- | ---------------------------------------------------------- | ----------------------------- | ------------------------------------------------------------ |\n| 队列/栈  |                                                            | 需要扩容                      | 更多空间存储指针                                             |\n| 图       | 多对多                                                     | 邻接矩阵                      | 邻接表                                                       |\n| 散列表   | 通过散列函数将键映射到一个大数组里  <br />需要解决散列冲突 | 线性探查法                    | 拉链法                                                       |\n| 树       | 一对多                                                     | 堆, 完全二叉树,不需要节点指针 | 不一定是完全二叉树, 衍生出各种巧妙的设计<br /> eg. 二叉搜索树/AVL树/红黑树/区间树/B树等, 应对不同的问题. |\n\n\n\n## 数据结构的基本操作\n\n遍历(找) + 访问(改) (具体点: 增删改查)\n\n两种形式: 线性(for/while循环) & 非线性(递归)\n\n<!--more-->\n\n#### 二叉搜索树操作\n\n二叉树算法设计: 明确一个节点要做的事, 剩下的交给框架.\n\n判断 BST 的合法性/增/删/查\n\n##### 判断BST合法性\n\n##### 在BST中查找一个数是否存在\n\n##### 在BST中插入一个数\n\n##### 在BST中删除一个数 \n\n\n\n\n\n# 计算机网络\n\n\n\n\n\n# 计算机语言\n\n## 编译型语言 解释型语言\n\n**编译**: 源代码(高级语言写的代码)转换成目标代码(汇编或者机器(`CPU`)能够理解的代码)\n\n**解释**: 解析源代码, 并直接执行, 没有编译的过程. 或者说, 把源代码转换成中间表示(软件`CPU`的指令), 然后执行.\n\n其实编译和解释就是编译的程度, 现在的编译其实就是直接转换成二进制代码, 解释其实就是转换成中间状态.\n\n很多动态语言不仅有解释器, 还有自己的虚拟机, called **高级语言虚拟机**, 有一套自己的指令集, 相当于一个软件`CPU`. \n\n为了在软件`CPU`上执行代码, 需要将源代码转换成软件`CPU`的指令, 其实类似于典型的编译过程. 但是 `Ruby` 并没有暴露出像`javac`这样的编译接口供程序员使用, 由语法树到指令的编译过程是内部操作的对外不暴露. `Ruby` 软指令最后也不会转换成物理`CPU`的机器指令.\n\n\n\n## 面向对象\n\n数据结构的某些数据是私有的, 不能被它的使用者看见, 必须通过固定的访问方式才能访问, 不能随意就访问到了.\n\n➡️ 需要将数据与操作结合起来形成 Object, 属性数据不能直接访问, 只能通过Object的函数来访问.\n\n➡️ 但是很多 Object 的方法都是重复的, 于是这些重复的方法代码都被放进了一个 Class 中\n\n➡️ 此时如何使用Class中的方法呢? 通过Class创建新对象, 从此时新对象可以使用Class中的方法, 创建对象方式是 new Class, 使用 new 关键字.\n\n➡️ 这样会产生很多的对象, 则对象的方法使用时, 需要区分是哪一个对象, 于是需要在使用方法时, 将需要进行操作的对象作为隐藏参数传入.\n\n➡️ 继承: 很多Class有重复功能, 将重复的代码放进父类中, 子类可以直接使用. \n\n➡️ 多态: 对于同一个接口, 使用不同的实例而执行不同的操作.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak () { console.log(`${this.name} make a noise`); }\n}\n\nclass Dog1 extends Animal {\n  constructor(name, sex) {\n    // 调用超类构造函数并传入name参数\n    // 必须先super 然后才能使用this\n    super(name);\n    this.sex = sex;\n  }\n  speak () { console.log(`${this.name} is ${this.sex} and barks`); }\n}\n\nlet d = new Dog1('cookie', 'girl');\nd.speak(); // cookie is girl and barks\n// 这里执行的是 Dog1 的 speak 方法而不是 Animal的 speak 方法.\n// 体现多态特征\n```\n\n继承破坏了封装性, 父类的很多细节对子类都可见. \n\n优先使用组合而不是继承 <<Head First 设计模式>>\n\n面向接口编程而不是实现编程. <<设计模式: 可复用面向对象软件的基础>>\n\n编程的关键是要抽象, 系统需求抽象成高层概念, 在概念层次进行编程.","source":"_posts/Basic-Knowledge.md","raw":"---\ntitle: Basic Knowledge\nabbrlink: 1793\ndate: 2020-09-30 14:06:46\ntags:\n---\n\n# 数据结构与算法\n\n数据结构是工具, 算法是通过合适的工具解决特定问题的方法.\n\n## 数据结构的存储方式\n\n数据结构的存储方式只有两种: 数组(顺序存储)与链表(链式存储)\n\n| 数据结构 | 定义                                                       | 数组                          | 链表                                                         |\n| -------- | ---------------------------------------------------------- | ----------------------------- | ------------------------------------------------------------ |\n| 队列/栈  |                                                            | 需要扩容                      | 更多空间存储指针                                             |\n| 图       | 多对多                                                     | 邻接矩阵                      | 邻接表                                                       |\n| 散列表   | 通过散列函数将键映射到一个大数组里  <br />需要解决散列冲突 | 线性探查法                    | 拉链法                                                       |\n| 树       | 一对多                                                     | 堆, 完全二叉树,不需要节点指针 | 不一定是完全二叉树, 衍生出各种巧妙的设计<br /> eg. 二叉搜索树/AVL树/红黑树/区间树/B树等, 应对不同的问题. |\n\n\n\n## 数据结构的基本操作\n\n遍历(找) + 访问(改) (具体点: 增删改查)\n\n两种形式: 线性(for/while循环) & 非线性(递归)\n\n<!--more-->\n\n#### 二叉搜索树操作\n\n二叉树算法设计: 明确一个节点要做的事, 剩下的交给框架.\n\n判断 BST 的合法性/增/删/查\n\n##### 判断BST合法性\n\n##### 在BST中查找一个数是否存在\n\n##### 在BST中插入一个数\n\n##### 在BST中删除一个数 \n\n\n\n\n\n# 计算机网络\n\n\n\n\n\n# 计算机语言\n\n## 编译型语言 解释型语言\n\n**编译**: 源代码(高级语言写的代码)转换成目标代码(汇编或者机器(`CPU`)能够理解的代码)\n\n**解释**: 解析源代码, 并直接执行, 没有编译的过程. 或者说, 把源代码转换成中间表示(软件`CPU`的指令), 然后执行.\n\n其实编译和解释就是编译的程度, 现在的编译其实就是直接转换成二进制代码, 解释其实就是转换成中间状态.\n\n很多动态语言不仅有解释器, 还有自己的虚拟机, called **高级语言虚拟机**, 有一套自己的指令集, 相当于一个软件`CPU`. \n\n为了在软件`CPU`上执行代码, 需要将源代码转换成软件`CPU`的指令, 其实类似于典型的编译过程. 但是 `Ruby` 并没有暴露出像`javac`这样的编译接口供程序员使用, 由语法树到指令的编译过程是内部操作的对外不暴露. `Ruby` 软指令最后也不会转换成物理`CPU`的机器指令.\n\n\n\n## 面向对象\n\n数据结构的某些数据是私有的, 不能被它的使用者看见, 必须通过固定的访问方式才能访问, 不能随意就访问到了.\n\n➡️ 需要将数据与操作结合起来形成 Object, 属性数据不能直接访问, 只能通过Object的函数来访问.\n\n➡️ 但是很多 Object 的方法都是重复的, 于是这些重复的方法代码都被放进了一个 Class 中\n\n➡️ 此时如何使用Class中的方法呢? 通过Class创建新对象, 从此时新对象可以使用Class中的方法, 创建对象方式是 new Class, 使用 new 关键字.\n\n➡️ 这样会产生很多的对象, 则对象的方法使用时, 需要区分是哪一个对象, 于是需要在使用方法时, 将需要进行操作的对象作为隐藏参数传入.\n\n➡️ 继承: 很多Class有重复功能, 将重复的代码放进父类中, 子类可以直接使用. \n\n➡️ 多态: 对于同一个接口, 使用不同的实例而执行不同的操作.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak () { console.log(`${this.name} make a noise`); }\n}\n\nclass Dog1 extends Animal {\n  constructor(name, sex) {\n    // 调用超类构造函数并传入name参数\n    // 必须先super 然后才能使用this\n    super(name);\n    this.sex = sex;\n  }\n  speak () { console.log(`${this.name} is ${this.sex} and barks`); }\n}\n\nlet d = new Dog1('cookie', 'girl');\nd.speak(); // cookie is girl and barks\n// 这里执行的是 Dog1 的 speak 方法而不是 Animal的 speak 方法.\n// 体现多态特征\n```\n\n继承破坏了封装性, 父类的很多细节对子类都可见. \n\n优先使用组合而不是继承 <<Head First 设计模式>>\n\n面向接口编程而不是实现编程. <<设计模式: 可复用面向对象软件的基础>>\n\n编程的关键是要抽象, 系统需求抽象成高层概念, 在概念层次进行编程.","slug":"Basic-Knowledge","published":1,"updated":"2020-10-29T10:54:05.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafi0003mm9h3h904mhz","content":"<h1 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h1><p>数据结构是工具, 算法是通过合适的工具解决特定问题的方法.</p>\n<h2 id=\"数据结构的存储方式\"><a href=\"#数据结构的存储方式\" class=\"headerlink\" title=\"数据结构的存储方式\"></a>数据结构的存储方式</h2><p>数据结构的存储方式只有两种: 数组(顺序存储)与链表(链式存储)</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>定义</th>\n<th>数组</th>\n<th>链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>队列/栈</td>\n<td></td>\n<td>需要扩容</td>\n<td>更多空间存储指针</td>\n</tr>\n<tr>\n<td>图</td>\n<td>多对多</td>\n<td>邻接矩阵</td>\n<td>邻接表</td>\n</tr>\n<tr>\n<td>散列表</td>\n<td>通过散列函数将键映射到一个大数组里  <br />需要解决散列冲突</td>\n<td>线性探查法</td>\n<td>拉链法</td>\n</tr>\n<tr>\n<td>树</td>\n<td>一对多</td>\n<td>堆, 完全二叉树,不需要节点指针</td>\n<td>不一定是完全二叉树, 衍生出各种巧妙的设计<br /> eg. 二叉搜索树/AVL树/红黑树/区间树/B树等, 应对不同的问题.</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"数据结构的基本操作\"><a href=\"#数据结构的基本操作\" class=\"headerlink\" title=\"数据结构的基本操作\"></a>数据结构的基本操作</h2><p>遍历(找) + 访问(改) (具体点: 增删改查)</p>\n<p>两种形式: 线性(for/while循环) &amp; 非线性(递归)</p>\n<a id=\"more\"></a>\n<h4 id=\"二叉搜索树操作\"><a href=\"#二叉搜索树操作\" class=\"headerlink\" title=\"二叉搜索树操作\"></a>二叉搜索树操作</h4><p>二叉树算法设计: 明确一个节点要做的事, 剩下的交给框架.</p>\n<p>判断 BST 的合法性/增/删/查</p>\n<h5 id=\"判断BST合法性\"><a href=\"#判断BST合法性\" class=\"headerlink\" title=\"判断BST合法性\"></a>判断BST合法性</h5><h5 id=\"在BST中查找一个数是否存在\"><a href=\"#在BST中查找一个数是否存在\" class=\"headerlink\" title=\"在BST中查找一个数是否存在\"></a>在BST中查找一个数是否存在</h5><h5 id=\"在BST中插入一个数\"><a href=\"#在BST中插入一个数\" class=\"headerlink\" title=\"在BST中插入一个数\"></a>在BST中插入一个数</h5><h5 id=\"在BST中删除一个数\"><a href=\"#在BST中删除一个数\" class=\"headerlink\" title=\"在BST中删除一个数\"></a>在BST中删除一个数</h5><h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h1 id=\"计算机语言\"><a href=\"#计算机语言\" class=\"headerlink\" title=\"计算机语言\"></a>计算机语言</h1><h2 id=\"编译型语言-解释型语言\"><a href=\"#编译型语言-解释型语言\" class=\"headerlink\" title=\"编译型语言 解释型语言\"></a>编译型语言 解释型语言</h2><p><strong>编译</strong>: 源代码(高级语言写的代码)转换成目标代码(汇编或者机器(<code>CPU</code>)能够理解的代码)</p>\n<p><strong>解释</strong>: 解析源代码, 并直接执行, 没有编译的过程. 或者说, 把源代码转换成中间表示(软件<code>CPU</code>的指令), 然后执行.</p>\n<p>其实编译和解释就是编译的程度, 现在的编译其实就是直接转换成二进制代码, 解释其实就是转换成中间状态.</p>\n<p>很多动态语言不仅有解释器, 还有自己的虚拟机, called <strong>高级语言虚拟机</strong>, 有一套自己的指令集, 相当于一个软件<code>CPU</code>. </p>\n<p>为了在软件<code>CPU</code>上执行代码, 需要将源代码转换成软件<code>CPU</code>的指令, 其实类似于典型的编译过程. 但是 <code>Ruby</code> 并没有暴露出像<code>javac</code>这样的编译接口供程序员使用, 由语法树到指令的编译过程是内部操作的对外不暴露. <code>Ruby</code> 软指令最后也不会转换成物理<code>CPU</code>的机器指令.</p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>数据结构的某些数据是私有的, 不能被它的使用者看见, 必须通过固定的访问方式才能访问, 不能随意就访问到了.</p>\n<p>➡️ 需要将数据与操作结合起来形成 Object, 属性数据不能直接访问, 只能通过Object的函数来访问.</p>\n<p>➡️ 但是很多 Object 的方法都是重复的, 于是这些重复的方法代码都被放进了一个 Class 中</p>\n<p>➡️ 此时如何使用Class中的方法呢? 通过Class创建新对象, 从此时新对象可以使用Class中的方法, 创建对象方式是 new Class, 使用 new 关键字.</p>\n<p>➡️ 这样会产生很多的对象, 则对象的方法使用时, 需要区分是哪一个对象, 于是需要在使用方法时, 将需要进行操作的对象作为隐藏参数传入.</p>\n<p>➡️ 继承: 很多Class有重复功能, 将重复的代码放进父类中, 子类可以直接使用. </p>\n<p>➡️ 多态: 对于同一个接口, 使用不同的实例而执行不同的操作.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> make a noise`</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, sex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用超类构造函数并传入name参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 必须先super 然后才能使用this</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.sex&#125;</span> and barks`</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Dog1(<span class=\"string\">'cookie'</span>, <span class=\"string\">'girl'</span>);</span><br><span class=\"line\">d.speak(); <span class=\"comment\">// cookie is girl and barks</span></span><br><span class=\"line\"><span class=\"comment\">// 这里执行的是 Dog1 的 speak 方法而不是 Animal的 speak 方法.</span></span><br><span class=\"line\"><span class=\"comment\">// 体现多态特征</span></span><br></pre></td></tr></table></figure>\n<p>继承破坏了封装性, 父类的很多细节对子类都可见. </p>\n<p>优先使用组合而不是继承 &lt;<Head First 设计模式>&gt;</p>\n<p>面向接口编程而不是实现编程. &lt;&lt;设计模式: 可复用面向对象软件的基础&gt;&gt;</p>\n<p>编程的关键是要抽象, 系统需求抽象成高层概念, 在概念层次进行编程.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h1><p>数据结构是工具, 算法是通过合适的工具解决特定问题的方法.</p>\n<h2 id=\"数据结构的存储方式\"><a href=\"#数据结构的存储方式\" class=\"headerlink\" title=\"数据结构的存储方式\"></a>数据结构的存储方式</h2><p>数据结构的存储方式只有两种: 数组(顺序存储)与链表(链式存储)</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>定义</th>\n<th>数组</th>\n<th>链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>队列/栈</td>\n<td></td>\n<td>需要扩容</td>\n<td>更多空间存储指针</td>\n</tr>\n<tr>\n<td>图</td>\n<td>多对多</td>\n<td>邻接矩阵</td>\n<td>邻接表</td>\n</tr>\n<tr>\n<td>散列表</td>\n<td>通过散列函数将键映射到一个大数组里  <br />需要解决散列冲突</td>\n<td>线性探查法</td>\n<td>拉链法</td>\n</tr>\n<tr>\n<td>树</td>\n<td>一对多</td>\n<td>堆, 完全二叉树,不需要节点指针</td>\n<td>不一定是完全二叉树, 衍生出各种巧妙的设计<br /> eg. 二叉搜索树/AVL树/红黑树/区间树/B树等, 应对不同的问题.</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"数据结构的基本操作\"><a href=\"#数据结构的基本操作\" class=\"headerlink\" title=\"数据结构的基本操作\"></a>数据结构的基本操作</h2><p>遍历(找) + 访问(改) (具体点: 增删改查)</p>\n<p>两种形式: 线性(for/while循环) &amp; 非线性(递归)</p>","more":"<h4 id=\"二叉搜索树操作\"><a href=\"#二叉搜索树操作\" class=\"headerlink\" title=\"二叉搜索树操作\"></a>二叉搜索树操作</h4><p>二叉树算法设计: 明确一个节点要做的事, 剩下的交给框架.</p>\n<p>判断 BST 的合法性/增/删/查</p>\n<h5 id=\"判断BST合法性\"><a href=\"#判断BST合法性\" class=\"headerlink\" title=\"判断BST合法性\"></a>判断BST合法性</h5><h5 id=\"在BST中查找一个数是否存在\"><a href=\"#在BST中查找一个数是否存在\" class=\"headerlink\" title=\"在BST中查找一个数是否存在\"></a>在BST中查找一个数是否存在</h5><h5 id=\"在BST中插入一个数\"><a href=\"#在BST中插入一个数\" class=\"headerlink\" title=\"在BST中插入一个数\"></a>在BST中插入一个数</h5><h5 id=\"在BST中删除一个数\"><a href=\"#在BST中删除一个数\" class=\"headerlink\" title=\"在BST中删除一个数\"></a>在BST中删除一个数</h5><h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h1 id=\"计算机语言\"><a href=\"#计算机语言\" class=\"headerlink\" title=\"计算机语言\"></a>计算机语言</h1><h2 id=\"编译型语言-解释型语言\"><a href=\"#编译型语言-解释型语言\" class=\"headerlink\" title=\"编译型语言 解释型语言\"></a>编译型语言 解释型语言</h2><p><strong>编译</strong>: 源代码(高级语言写的代码)转换成目标代码(汇编或者机器(<code>CPU</code>)能够理解的代码)</p>\n<p><strong>解释</strong>: 解析源代码, 并直接执行, 没有编译的过程. 或者说, 把源代码转换成中间表示(软件<code>CPU</code>的指令), 然后执行.</p>\n<p>其实编译和解释就是编译的程度, 现在的编译其实就是直接转换成二进制代码, 解释其实就是转换成中间状态.</p>\n<p>很多动态语言不仅有解释器, 还有自己的虚拟机, called <strong>高级语言虚拟机</strong>, 有一套自己的指令集, 相当于一个软件<code>CPU</code>. </p>\n<p>为了在软件<code>CPU</code>上执行代码, 需要将源代码转换成软件<code>CPU</code>的指令, 其实类似于典型的编译过程. 但是 <code>Ruby</code> 并没有暴露出像<code>javac</code>这样的编译接口供程序员使用, 由语法树到指令的编译过程是内部操作的对外不暴露. <code>Ruby</code> 软指令最后也不会转换成物理<code>CPU</code>的机器指令.</p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>数据结构的某些数据是私有的, 不能被它的使用者看见, 必须通过固定的访问方式才能访问, 不能随意就访问到了.</p>\n<p>➡️ 需要将数据与操作结合起来形成 Object, 属性数据不能直接访问, 只能通过Object的函数来访问.</p>\n<p>➡️ 但是很多 Object 的方法都是重复的, 于是这些重复的方法代码都被放进了一个 Class 中</p>\n<p>➡️ 此时如何使用Class中的方法呢? 通过Class创建新对象, 从此时新对象可以使用Class中的方法, 创建对象方式是 new Class, 使用 new 关键字.</p>\n<p>➡️ 这样会产生很多的对象, 则对象的方法使用时, 需要区分是哪一个对象, 于是需要在使用方法时, 将需要进行操作的对象作为隐藏参数传入.</p>\n<p>➡️ 继承: 很多Class有重复功能, 将重复的代码放进父类中, 子类可以直接使用. </p>\n<p>➡️ 多态: 对于同一个接口, 使用不同的实例而执行不同的操作.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> make a noise`</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, sex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用超类构造函数并传入name参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 必须先super 然后才能使用this</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.sex&#125;</span> and barks`</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Dog1(<span class=\"string\">'cookie'</span>, <span class=\"string\">'girl'</span>);</span><br><span class=\"line\">d.speak(); <span class=\"comment\">// cookie is girl and barks</span></span><br><span class=\"line\"><span class=\"comment\">// 这里执行的是 Dog1 的 speak 方法而不是 Animal的 speak 方法.</span></span><br><span class=\"line\"><span class=\"comment\">// 体现多态特征</span></span><br></pre></td></tr></table></figure>\n<p>继承破坏了封装性, 父类的很多细节对子类都可见. </p>\n<p>优先使用组合而不是继承 &lt;<Head First 设计模式>&gt;</p>\n<p>面向接口编程而不是实现编程. &lt;&lt;设计模式: 可复用面向对象软件的基础&gt;&gt;</p>\n<p>编程的关键是要抽象, 系统需求抽象成高层概念, 在概念层次进行编程.</p>"},{"title":"Backtracking","abbrlink":"1f6fbb87","date":"2020-08-18T02:18:11.000Z","description":"回溯相关题解","mathjax":true,"_content":"\n### 回溯算法\n\n##### 解题过程=决策树的遍历过程:\n\n1. 路径: 已经做出的选择\n2. 选择列表: 当前可以做的选择\n3. 结束条件: 到达决策树底层, 无法再做选择的条件(可选列表为空等)\n\n##### 回溯算法代码框架:\n\n```javascript\nresult = []\nvar backtrack = (路径, 选择列表) => {\n  if 满足结束条件{\n    result.push(路径);\n  \treturn;\n  }\n  \n  for 选择 in 选择列表{\n  \t// 做选择\n  \t将该选择从选择列表中移除\n    路径.push(选择)\n    backtrack(路径, 选择列表);\n  \t// 撤销选择\n    路径.pop()\n    将该选择再加入选择列表\n  }\n}\n```\n\n##### 时间复杂度分析:\n\n递归相关的算法, 时间复杂度计算为: [递归次数]*[递归本身的时间复杂度].\n\n\n\n### 经典例题\n\n#### N皇后问题\n\n##### [51] N-Queens\n\n套用回溯框架即可, 每确定一个皇后位置, 将其加入已经选择的路径中, 接着进行选择.\n\n学了框架之后, 思路都清楚了很多.\n\n```javascript\n// 皇后彼此不能相互攻击也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上\nvar solveNQueens = function (n) {\n  // 初始化棋盘\n  let board = [];\n  for (let i = 0; i < n; i++) {\n    board.push('.');\n  }\n  let path = [], res = []; // 存储皇后的纵坐标\n  backtrack(board, path, res, n, 0);\n  return res;\n};\n\nvar backtrack = (board, path, res, n, depth) => {\n  // end condition\n  if (path.length == n) {\n    let solution = [];\n    for (let col of path) {\n      let ele = board.slice();\n      ele[col] = 'Q';\n      solution.push(ele.join(''));\n    }\n    res.push(solution);\n    return;\n  }\n  // make a choice\n  for (let i = 0; i < n; i++) {\n    if (path.length == 0 || isValid(depth, i, path)) {\n      // 进行选择\n      path.push(i);\n      backtrack(board, path, res, n, depth + 1);\n      // 撤销选择\n      path.pop();\n    }\n  }\n}\n\n// 给两个皇后的坐标 判断这两个皇后是否会互相攻击\n// 同一横线 同一竖线 同一斜线\nvar isValid = (m, n, path) => {\n  for (let i = 0; i < path.length; i++) {\n    // 横坐标相等 纵坐标相等 横坐标坐标差值相等\n    if (m == i || n == path[i] || Math.abs(m - i) == Math.abs(path[i] - n)) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n\n\n#### 子集问题\n\n##### [78] Subsets\n\n> Given a set of **distinct** integers, *nums*, return all possible subsets (the power set).\n>\n> **Note:** The solution set must not contain duplicate subsets.\n\n观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。\n\n首先，它们的解空间非常大：\n\n- 全排列：N!。\n\n\n- 组合：N!。\n\n\n- 子集：2^N, 每个元素都可能存在或不存在。\n\n\n在它们的指数级解法中，要确保生成的结果 **完整** 且 **无冗余**，有三种常用的方法：\n\n1. 递归\n2. 回溯\n3. 基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集\n\n相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。\n\n此外，第三种方法具有**最优的时间复杂度**，可以生成按照字典顺序的输出结果。\n\n\n\n###### solution 1 : 字典排序（二进制排序） 子集\n\n这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.\n\n数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.\n\n因此该方法的思路如下:\n\n假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8\n\n则从 0 - 7 的二进制对应分别为 000-111\n\n每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].\n\n![bitmask4](Backtracking/bitmask4.png)\n\n需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.\n\n```javascript\nvar subsets = function (nums) {\n  let len = nums.length;\n  let subSets = [];\n  // 根据数组长度计算器其子集数量\n  let subSetsNum = Math.pow(2, len);\n  for (let i = 0; i < subSetsNum; i++) {\n    // 十进制转换为二进制\n    // 每一个二进制都唯一对应一个子集\n    let setNoStr = i.toString(2);\n    while (setNoStr.length < len) {\n      //如果长度不足 len，前面添加 0\n      setNoStr = '0' + setNoStr;\n    }\n    let setNoList = setNoStr.split('');\n    let subSet = [];\n    for (let j = 0; j < len; j++) {\n      if (setNoList[j] == '1') {\n        subSet.push(nums[j]);\n      }\n    }\n    subSets.push(subSet);\n  }\n  return subSets;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。\n- 空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。\n\n\n\n###### solution 2 : 数学归纳法\n\n这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.\n\n```javascript\nvar subsets = function (nums) {\n  let subSets = [[]];\n  let len = nums.length;\n  if (len == 0)\n    return subSets\n\n  for (let i = 0; i < len; i++) {\n    let l = subSets.length;\n    for (let j = 0; j < l; j++) {\n      let ele = subSets[j].concat([nums[i]]);\n      subSets.push(ele);\n    }\n  }\n  return subSets;\n}\n```\n\n时间复杂度:  总共添加2^N个子集, 每个子集是数组形式, 子集通过深拷贝塞进结果数组中, 拷贝耗时O(N). 因此, 总的时间复杂度是 O(N*2^N).\n\n空间复杂度: 存储每个子集需要 O(N)的递归堆栈空间(不算结果集), 算上结果的话, 一共2^N个子集, 因此所需空间为 O(N*2^N).\n\n\n\n###### Solution 3 :  回溯解法\n\n使用回溯模板. 控制start.\n\n```javascript\nvar subsets = (nums) => {\n  let res = [], path = [];\n  helper(nums, res, path);\n  res.push([]); // 添加空集\n  return res;\n}\n\nvar helper = (choice, res, path) => {\n  // end condition\n  // 没有节点可以选择时 返回\n  if (choice.length == 0) return;\n  \n  for (let i = 0; i < choice.length; i++) {\n    // 做选择\n    path.push(choice[i]);\n    res.push(path.slice()); // 每一个节点都是子集\n    // 对于一个没有重复元素的集合来说\n    // 在添加元素时 直接向后作为选择列表即可\n    // 因为前面的元素与当前元素的子集已经被先前元素添加过了\n    // 排除已选择的数字\n    helper(choice.slice(i + 1), res, path);\n    // 撤销选择\n    path.pop();\n  }\n}\n```\n\n\n\n##### [90] Subsets II\n\n> Given a collection of integers that might contain duplicates, ***nums\\***, return all possible subsets (the power set).\n>\n> **Note:** The solution set must not contain duplicate subsets.\n\n思路与子集时类似, 只是需要剪枝操作, **将同一层其余相同的元素除去**.\n\n```javascript\nvar subsetsWithDup = function (nums) {\n  nums = nums.sort(); // 排序操作 使得相同元素相邻\n  let len = nums.length;\n  let res = [];\n  for (let i = 0; i <= len; i++) {\n    recur(i, 0, len, [], res, nums);\n  }\n  console.log(res);\n  return res;\n}\n\nvar recur = (depth, first, len, curr, res, nums) => {\n  if (curr.length == depth) {\n    res.push(curr.slice()); // 将当前子集的深拷贝加入结果数组\n    return;\n  }\n  for (let i = first; i < len; i++) {\n    if (i > first && nums[i] == nums[i - 1]) { // 一开始写成了 i>0 结果总是不对 后来知道每次加元素是从 first 开始 不是 0 开始\n      // 每次当作为起始点往数组加入元素时,不能加入与上一个元素相同的元素\n      continue;\n    }\n    curr.push(nums[i]);\n    recur(depth, i + 1, len, curr, res, nums);\n    curr.pop(); // 回溯 回到初始状态\n  }\n}\n```\n\n\n\n#### 括号问题\n\n两个性质:\n\n1. 合法的括号组合中, 左括号数目=右括号数目.\n2. 一个合法的括号组合字符串 s, 对于任意 0<=i<len(s), 子串 s[0, i] 中, 左括号数目>=右括号数目.\n\n##### [22] Generate Parentheses\n\n> Given *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n对于该题题意的理解, 可以是, 现在有 `2n` 个位置, 每个位置可以放置`'('`(数目为n)/`')'`(数目为n), 请问一共有多少种合法的放置方式?\n\n则解题思路是: *先得到 2^(2n) 种组合方式, 再去除不合法的部分即可.*\n\n```javascript\n// 2020/10/21 学习回溯模板之后 很简洁\nvar generateParenthesis = (n) => {\n  let path = [], res = [];\n  helper(path, res, n, n, n);\n  return res;\n}\n\nvar helper = (path, res, n, left, right) => {\n  // 左括号剩的比右括号多 不合法\n  if (left > right) return;\n  // 使用次数小于0 不合法\n  if (left < 0 || right < 0) return;\n  // 左右括号都恰好用完, 得到一个合法的括号\n  if (left == 0 && right == 0) {\n    res.push(path.join(''));\n    return;\n  }\n  // 尝试放一个左括号\n  path.push('('); // 选择\n  helper(path, res, n, left - 1, right);\n  path.pop(); // 撤销选择\n  // 尝试放一个右括号\n  path.push(')'); // 选择\n  helper(path, res, n, left, right - 1);\n  path.pop(); // 撤销选择\n}\n```\n\n\n\n#### 排列问题\n\n##### [46] Permutations\n\n> Given a collection of **distinct** integers, return all possible permutations.\n\n时间复杂度: O(N*N!)\n\n全排列一共有 N! 种可能, 实现每一种可能需要遍历整个数组即O(N)时间, 所以可得.\n\n使用回溯模板. 删除已经选择的数字.\n\n```javascript\nvar permute = (nums) => {\n  let res = [], path = [];\n  helper(nums, res, path);\n  return res;\n}\nvar helper = (nums, res, path) => {\n  // 选择列表为空\n  if (nums.length == 0) {\n    res.push(path.slice());\n    return;\n  }\n  for (let i = 0; i < nums.length; i++) {\n    // 做选择\n    path.push(nums[i]);\n    let nums_cp = nums.slice();\n    // 从选择列表中删除这个选择\n    // 排除已选择的数字\n    nums.splice(i, 1); \n    helper(nums, res, path);\n    // 撤销选择\n    path.pop(); \n    nums = nums_cp; // 将移除的选择重新加入选择列表\n  }\n}\n```\n\n#### 组合问题\n\n##### [77] Combinations\n\n> Given two integers *n* and *k*, return all possible combinations of *k* numbers out of 1 ... *n*.\n>\n> You may return the answer in **any order**.\n\n使用回溯模板, 决策树的深度为 k. 将深度为k的节点均加入节点列表.\n\n其实就是自己问题的一部分, 使用start排除已经做出的选择.\n\n```javascript\nvar combine = (n, k) => {\n  let path = [], res = [];\n  let choice = [];\n  for (let i = 1; i <= n; i++) {\n    choice.push(i);\n  }\n  helper(choice, 0, path, res, k);\n  return res;\n}\n\nvar helper = (choice, start, path, res, k) => {\n  if (path.length == k) {\n    res.push(path.slice());\n    return;\n  }\n  for (let i = start; i < choice.length; i++) {\n    path.push(choice[i]);\n    helper(choice, i + 1, path, res, k);\n    path.pop();\n  }\n}\n```\n\n\n\n#### 其他问题\n\n##### [79] Word Search\n\n> Given a 2D board and a word, find if the word exists in the grid.\n>\n> The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n回溯算法本质就是暴力穷举.\n\n```javascript\nvar exist = function (board, word) {\n  let m = board.length;\n  let n = board[0].length;\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (board[i][j] == word[0]) {\n        const res = findNeighbor(board, word, 0, i, j, {});\n        if (res) return true;\n      }\n    }\n  }\n  return false;\n};\n\nvar findNeighbor = (board, word, w, row, col, visited) => {\n  // 不能在这里进行判断 因为尽管w这里表示最后一个字母\n  // 但是却并不一定能在board里找到 需要再经过判断\n  // if (w + 1 == word.length) return true;\n\n  // 选择不合法则回到上一层\n  let key = row + '+' + col;\n  if (row >= board.length || row < 0 || col >= board[0].length || col < 0\n    || visited[key] || board[row][col] != word[w]\n  ) {\n    return false;\n  }\n\n  // 选择列表\n  // 对一个可能的选择都进行尝试\n\n  // 做选择\n  visited[key] = true;\n  // 递归结束条件\n  // 一旦word的最后一个字母也找到 则说明成功找到word\n  if (w + 1 == word.length) return true;\n  // 一旦找到目标字符串(递归返回值为true) 就直接返回 不用再进行下面的递归了 减少递归次数\n  let r1 = findNeighbor(board, word, w + 1, row - 1, col, visited);\n  if (r1) return true;\n  let r2 = findNeighbor(board, word, w + 1, row + 1, col, visited);\n  if (r2) return true;\n  let r3 = findNeighbor(board, word, w + 1, row, col - 1, visited);\n  if (r3) return true;\n  let r4 = findNeighbor(board, word, w + 1, row, col + 1, visited);\n  if (r4) return true;\n\n  // 找了一圈没有找到 说明从该节点开始不是正确的选择\n  // 则在该节点应该 撤销选择 回到上一层 在上一层转换搜索方向\n  visited[key] = false;\n  return false;\n}\n```\n\n\n\n##### [93] Restore IP Addresses\n\n> Given a string `s` containing only digits. Return all possible valid IP addresses that can be obtained from `s`. You can return them in **any** order.\n>\n> A **valid IP address** consists of exactly four integers, each integer is between `0` and `255`, separated by single points and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are **valid** IP addresses and \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are **invalid** IP addresses. \n\n就是大概有想法但是却实现不出来, 说明思路还不是很清楚, 需要画树状图帮助自己理解.\n\n多画树状图, 理解回溯过程. 被这道题折磨好久.\n\n```javascript\n/**\n * \n * 合法的url的条件:\n * 将字符串分为四个部分, 每个部分的数字[0,255], 不超过3位\n * 中间的数字不能以0开头\n * \n */\nvar restoreIpAddresses = function (s) {\n  let len = s.length;\n  // 字符串长度不够则直接返回空数组\n  if (len > 12 || len < 4)\n    return [];\n  let res = new Array();\n  let ip = new Array();\n  let start = 0;\n  dfs(res, ip, start, s);\n  return res;\n};\n\n/**\n * \n * @param {array} res 存储合法ip\n * @param {array} ip 存储ip的每一段\n * @param {number} start 剩余需要继续递归的子串\n * @param {string} s \n */\nvar dfs = (res, ip, start, s) => {\n  // 在开始切割子串之前, 判断ip是否符合题意\n  // s 已经遍历完毕且ip是四段的话, 该ip可以进结果数组了\n  if (ip.length == 4) {\n    if (start == s.length) {\n      res.push(ip.join('.'));\n      return;\n    }\n    // 未遍历完s ip已经4段 该ip不合题意\n    if (start < s.length) {\n      return;\n    }\n  }\n  // s 已经遍历完了,但是ip不到四段,返回\n  if (ip.length < 4 && start == s.length) {\n    return;\n  }\n  // 从每个起始位置开始切割都是三个长度\n  for (let l = 1; l <= 3; l++) {\n    if (start + l > s.length) return; // 索引超过边界\n    if ((l == 2 || l == 3) && s[start] == '0') return; // 2/3子串以0开头\n    let part = s.substring(start, start + l); // 切割子串\n    if (Number(part) > 255) return; // 子串不符合条件 这里已经l==3了 continue和return是一样的效果\n    // part符合条件\n    ip.push(part.slice());\n    // 下次递归的子串的起始位置是start+l\n    dfs(res, ip, start + l, s);\n    ip.pop();\n  }\n}\n```\n\n\n\n##### [473] Matchsticks to Square\n\n> Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used **exactly** one time.\n>\n> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n\n需要注意的是, 在采用递归方法的情况下,  这里不需要在选择位置的外面再套一层for循环去遍历火柴, 因为不存在第一根火柴找到合适位置之后, 把第一根火柴去掉, 以第二根火柴为第一根火柴, 再重新开始摆放. 只需要每根火柴摆放好之后, 去递归摆放下一根火柴即可.\n\n```javascript\n// 使用小女孩的所有火柴拼成一个正方形\n// 回溯 使用所有的火柴 每根火柴只能用一次\nvar makesquare = function (nums) {\n  let sum = 0;\n  nums.forEach((val) => {\n    sum += val;\n  })\n  if (sum % 4 != 0) return false;\n  let res = [0, 0, 0, 0];\n  helper(nums, 0, res, sum / 4);\n  return res[0] != 0;\n};\n\nvar helper = (nums, index, res, sum) => {\n  // 递归结束条件 所有火柴均已放置\n  if (index == nums.length) {\n    // 找到可行解\n    return res[0] == res[1] && res[1] == res[2] && res[2] == res[3];\n  }\n  \n  // 每根火柴均有四个位置可以选择\n  for (let j = 0; j < res.length; j++) {\n    if (res[j] + nums[index] <= sum) {\n      // 做选择\n      res[j] += nums[index];\n      if (helper(nums, index + 1, res, sum)) {\n        return true; // 找到可行解就返回 不再继续尝试\n      }\n      // 撤销选择\n      res[j] -= nums[index];\n    }\n  }\n  // 走到这里说明 剩下的火柴怎么摆放都达不到要求\n  // 说明上一层摆错了位置\n  return false;\n}\n```\n\n","source":"_posts/Backtracking.md","raw":"---\ntitle: Backtracking\ntags:\n  - LeetCode\n  - Backtracking\ncategories: Algorithm\nabbrlink: 1f6fbb87\ndate: 2020-08-18 10:18:11\ndescription: 回溯相关题解\nmathjax: true\n---\n\n### 回溯算法\n\n##### 解题过程=决策树的遍历过程:\n\n1. 路径: 已经做出的选择\n2. 选择列表: 当前可以做的选择\n3. 结束条件: 到达决策树底层, 无法再做选择的条件(可选列表为空等)\n\n##### 回溯算法代码框架:\n\n```javascript\nresult = []\nvar backtrack = (路径, 选择列表) => {\n  if 满足结束条件{\n    result.push(路径);\n  \treturn;\n  }\n  \n  for 选择 in 选择列表{\n  \t// 做选择\n  \t将该选择从选择列表中移除\n    路径.push(选择)\n    backtrack(路径, 选择列表);\n  \t// 撤销选择\n    路径.pop()\n    将该选择再加入选择列表\n  }\n}\n```\n\n##### 时间复杂度分析:\n\n递归相关的算法, 时间复杂度计算为: [递归次数]*[递归本身的时间复杂度].\n\n\n\n### 经典例题\n\n#### N皇后问题\n\n##### [51] N-Queens\n\n套用回溯框架即可, 每确定一个皇后位置, 将其加入已经选择的路径中, 接着进行选择.\n\n学了框架之后, 思路都清楚了很多.\n\n```javascript\n// 皇后彼此不能相互攻击也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上\nvar solveNQueens = function (n) {\n  // 初始化棋盘\n  let board = [];\n  for (let i = 0; i < n; i++) {\n    board.push('.');\n  }\n  let path = [], res = []; // 存储皇后的纵坐标\n  backtrack(board, path, res, n, 0);\n  return res;\n};\n\nvar backtrack = (board, path, res, n, depth) => {\n  // end condition\n  if (path.length == n) {\n    let solution = [];\n    for (let col of path) {\n      let ele = board.slice();\n      ele[col] = 'Q';\n      solution.push(ele.join(''));\n    }\n    res.push(solution);\n    return;\n  }\n  // make a choice\n  for (let i = 0; i < n; i++) {\n    if (path.length == 0 || isValid(depth, i, path)) {\n      // 进行选择\n      path.push(i);\n      backtrack(board, path, res, n, depth + 1);\n      // 撤销选择\n      path.pop();\n    }\n  }\n}\n\n// 给两个皇后的坐标 判断这两个皇后是否会互相攻击\n// 同一横线 同一竖线 同一斜线\nvar isValid = (m, n, path) => {\n  for (let i = 0; i < path.length; i++) {\n    // 横坐标相等 纵坐标相等 横坐标坐标差值相等\n    if (m == i || n == path[i] || Math.abs(m - i) == Math.abs(path[i] - n)) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n\n\n#### 子集问题\n\n##### [78] Subsets\n\n> Given a set of **distinct** integers, *nums*, return all possible subsets (the power set).\n>\n> **Note:** The solution set must not contain duplicate subsets.\n\n观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。\n\n首先，它们的解空间非常大：\n\n- 全排列：N!。\n\n\n- 组合：N!。\n\n\n- 子集：2^N, 每个元素都可能存在或不存在。\n\n\n在它们的指数级解法中，要确保生成的结果 **完整** 且 **无冗余**，有三种常用的方法：\n\n1. 递归\n2. 回溯\n3. 基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集\n\n相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。\n\n此外，第三种方法具有**最优的时间复杂度**，可以生成按照字典顺序的输出结果。\n\n\n\n###### solution 1 : 字典排序（二进制排序） 子集\n\n这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.\n\n数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.\n\n因此该方法的思路如下:\n\n假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8\n\n则从 0 - 7 的二进制对应分别为 000-111\n\n每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].\n\n![bitmask4](Backtracking/bitmask4.png)\n\n需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.\n\n```javascript\nvar subsets = function (nums) {\n  let len = nums.length;\n  let subSets = [];\n  // 根据数组长度计算器其子集数量\n  let subSetsNum = Math.pow(2, len);\n  for (let i = 0; i < subSetsNum; i++) {\n    // 十进制转换为二进制\n    // 每一个二进制都唯一对应一个子集\n    let setNoStr = i.toString(2);\n    while (setNoStr.length < len) {\n      //如果长度不足 len，前面添加 0\n      setNoStr = '0' + setNoStr;\n    }\n    let setNoList = setNoStr.split('');\n    let subSet = [];\n    for (let j = 0; j < len; j++) {\n      if (setNoList[j] == '1') {\n        subSet.push(nums[j]);\n      }\n    }\n    subSets.push(subSet);\n  }\n  return subSets;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。\n- 空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。\n\n\n\n###### solution 2 : 数学归纳法\n\n这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.\n\n```javascript\nvar subsets = function (nums) {\n  let subSets = [[]];\n  let len = nums.length;\n  if (len == 0)\n    return subSets\n\n  for (let i = 0; i < len; i++) {\n    let l = subSets.length;\n    for (let j = 0; j < l; j++) {\n      let ele = subSets[j].concat([nums[i]]);\n      subSets.push(ele);\n    }\n  }\n  return subSets;\n}\n```\n\n时间复杂度:  总共添加2^N个子集, 每个子集是数组形式, 子集通过深拷贝塞进结果数组中, 拷贝耗时O(N). 因此, 总的时间复杂度是 O(N*2^N).\n\n空间复杂度: 存储每个子集需要 O(N)的递归堆栈空间(不算结果集), 算上结果的话, 一共2^N个子集, 因此所需空间为 O(N*2^N).\n\n\n\n###### Solution 3 :  回溯解法\n\n使用回溯模板. 控制start.\n\n```javascript\nvar subsets = (nums) => {\n  let res = [], path = [];\n  helper(nums, res, path);\n  res.push([]); // 添加空集\n  return res;\n}\n\nvar helper = (choice, res, path) => {\n  // end condition\n  // 没有节点可以选择时 返回\n  if (choice.length == 0) return;\n  \n  for (let i = 0; i < choice.length; i++) {\n    // 做选择\n    path.push(choice[i]);\n    res.push(path.slice()); // 每一个节点都是子集\n    // 对于一个没有重复元素的集合来说\n    // 在添加元素时 直接向后作为选择列表即可\n    // 因为前面的元素与当前元素的子集已经被先前元素添加过了\n    // 排除已选择的数字\n    helper(choice.slice(i + 1), res, path);\n    // 撤销选择\n    path.pop();\n  }\n}\n```\n\n\n\n##### [90] Subsets II\n\n> Given a collection of integers that might contain duplicates, ***nums\\***, return all possible subsets (the power set).\n>\n> **Note:** The solution set must not contain duplicate subsets.\n\n思路与子集时类似, 只是需要剪枝操作, **将同一层其余相同的元素除去**.\n\n```javascript\nvar subsetsWithDup = function (nums) {\n  nums = nums.sort(); // 排序操作 使得相同元素相邻\n  let len = nums.length;\n  let res = [];\n  for (let i = 0; i <= len; i++) {\n    recur(i, 0, len, [], res, nums);\n  }\n  console.log(res);\n  return res;\n}\n\nvar recur = (depth, first, len, curr, res, nums) => {\n  if (curr.length == depth) {\n    res.push(curr.slice()); // 将当前子集的深拷贝加入结果数组\n    return;\n  }\n  for (let i = first; i < len; i++) {\n    if (i > first && nums[i] == nums[i - 1]) { // 一开始写成了 i>0 结果总是不对 后来知道每次加元素是从 first 开始 不是 0 开始\n      // 每次当作为起始点往数组加入元素时,不能加入与上一个元素相同的元素\n      continue;\n    }\n    curr.push(nums[i]);\n    recur(depth, i + 1, len, curr, res, nums);\n    curr.pop(); // 回溯 回到初始状态\n  }\n}\n```\n\n\n\n#### 括号问题\n\n两个性质:\n\n1. 合法的括号组合中, 左括号数目=右括号数目.\n2. 一个合法的括号组合字符串 s, 对于任意 0<=i<len(s), 子串 s[0, i] 中, 左括号数目>=右括号数目.\n\n##### [22] Generate Parentheses\n\n> Given *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n对于该题题意的理解, 可以是, 现在有 `2n` 个位置, 每个位置可以放置`'('`(数目为n)/`')'`(数目为n), 请问一共有多少种合法的放置方式?\n\n则解题思路是: *先得到 2^(2n) 种组合方式, 再去除不合法的部分即可.*\n\n```javascript\n// 2020/10/21 学习回溯模板之后 很简洁\nvar generateParenthesis = (n) => {\n  let path = [], res = [];\n  helper(path, res, n, n, n);\n  return res;\n}\n\nvar helper = (path, res, n, left, right) => {\n  // 左括号剩的比右括号多 不合法\n  if (left > right) return;\n  // 使用次数小于0 不合法\n  if (left < 0 || right < 0) return;\n  // 左右括号都恰好用完, 得到一个合法的括号\n  if (left == 0 && right == 0) {\n    res.push(path.join(''));\n    return;\n  }\n  // 尝试放一个左括号\n  path.push('('); // 选择\n  helper(path, res, n, left - 1, right);\n  path.pop(); // 撤销选择\n  // 尝试放一个右括号\n  path.push(')'); // 选择\n  helper(path, res, n, left, right - 1);\n  path.pop(); // 撤销选择\n}\n```\n\n\n\n#### 排列问题\n\n##### [46] Permutations\n\n> Given a collection of **distinct** integers, return all possible permutations.\n\n时间复杂度: O(N*N!)\n\n全排列一共有 N! 种可能, 实现每一种可能需要遍历整个数组即O(N)时间, 所以可得.\n\n使用回溯模板. 删除已经选择的数字.\n\n```javascript\nvar permute = (nums) => {\n  let res = [], path = [];\n  helper(nums, res, path);\n  return res;\n}\nvar helper = (nums, res, path) => {\n  // 选择列表为空\n  if (nums.length == 0) {\n    res.push(path.slice());\n    return;\n  }\n  for (let i = 0; i < nums.length; i++) {\n    // 做选择\n    path.push(nums[i]);\n    let nums_cp = nums.slice();\n    // 从选择列表中删除这个选择\n    // 排除已选择的数字\n    nums.splice(i, 1); \n    helper(nums, res, path);\n    // 撤销选择\n    path.pop(); \n    nums = nums_cp; // 将移除的选择重新加入选择列表\n  }\n}\n```\n\n#### 组合问题\n\n##### [77] Combinations\n\n> Given two integers *n* and *k*, return all possible combinations of *k* numbers out of 1 ... *n*.\n>\n> You may return the answer in **any order**.\n\n使用回溯模板, 决策树的深度为 k. 将深度为k的节点均加入节点列表.\n\n其实就是自己问题的一部分, 使用start排除已经做出的选择.\n\n```javascript\nvar combine = (n, k) => {\n  let path = [], res = [];\n  let choice = [];\n  for (let i = 1; i <= n; i++) {\n    choice.push(i);\n  }\n  helper(choice, 0, path, res, k);\n  return res;\n}\n\nvar helper = (choice, start, path, res, k) => {\n  if (path.length == k) {\n    res.push(path.slice());\n    return;\n  }\n  for (let i = start; i < choice.length; i++) {\n    path.push(choice[i]);\n    helper(choice, i + 1, path, res, k);\n    path.pop();\n  }\n}\n```\n\n\n\n#### 其他问题\n\n##### [79] Word Search\n\n> Given a 2D board and a word, find if the word exists in the grid.\n>\n> The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n回溯算法本质就是暴力穷举.\n\n```javascript\nvar exist = function (board, word) {\n  let m = board.length;\n  let n = board[0].length;\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (board[i][j] == word[0]) {\n        const res = findNeighbor(board, word, 0, i, j, {});\n        if (res) return true;\n      }\n    }\n  }\n  return false;\n};\n\nvar findNeighbor = (board, word, w, row, col, visited) => {\n  // 不能在这里进行判断 因为尽管w这里表示最后一个字母\n  // 但是却并不一定能在board里找到 需要再经过判断\n  // if (w + 1 == word.length) return true;\n\n  // 选择不合法则回到上一层\n  let key = row + '+' + col;\n  if (row >= board.length || row < 0 || col >= board[0].length || col < 0\n    || visited[key] || board[row][col] != word[w]\n  ) {\n    return false;\n  }\n\n  // 选择列表\n  // 对一个可能的选择都进行尝试\n\n  // 做选择\n  visited[key] = true;\n  // 递归结束条件\n  // 一旦word的最后一个字母也找到 则说明成功找到word\n  if (w + 1 == word.length) return true;\n  // 一旦找到目标字符串(递归返回值为true) 就直接返回 不用再进行下面的递归了 减少递归次数\n  let r1 = findNeighbor(board, word, w + 1, row - 1, col, visited);\n  if (r1) return true;\n  let r2 = findNeighbor(board, word, w + 1, row + 1, col, visited);\n  if (r2) return true;\n  let r3 = findNeighbor(board, word, w + 1, row, col - 1, visited);\n  if (r3) return true;\n  let r4 = findNeighbor(board, word, w + 1, row, col + 1, visited);\n  if (r4) return true;\n\n  // 找了一圈没有找到 说明从该节点开始不是正确的选择\n  // 则在该节点应该 撤销选择 回到上一层 在上一层转换搜索方向\n  visited[key] = false;\n  return false;\n}\n```\n\n\n\n##### [93] Restore IP Addresses\n\n> Given a string `s` containing only digits. Return all possible valid IP addresses that can be obtained from `s`. You can return them in **any** order.\n>\n> A **valid IP address** consists of exactly four integers, each integer is between `0` and `255`, separated by single points and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are **valid** IP addresses and \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are **invalid** IP addresses. \n\n就是大概有想法但是却实现不出来, 说明思路还不是很清楚, 需要画树状图帮助自己理解.\n\n多画树状图, 理解回溯过程. 被这道题折磨好久.\n\n```javascript\n/**\n * \n * 合法的url的条件:\n * 将字符串分为四个部分, 每个部分的数字[0,255], 不超过3位\n * 中间的数字不能以0开头\n * \n */\nvar restoreIpAddresses = function (s) {\n  let len = s.length;\n  // 字符串长度不够则直接返回空数组\n  if (len > 12 || len < 4)\n    return [];\n  let res = new Array();\n  let ip = new Array();\n  let start = 0;\n  dfs(res, ip, start, s);\n  return res;\n};\n\n/**\n * \n * @param {array} res 存储合法ip\n * @param {array} ip 存储ip的每一段\n * @param {number} start 剩余需要继续递归的子串\n * @param {string} s \n */\nvar dfs = (res, ip, start, s) => {\n  // 在开始切割子串之前, 判断ip是否符合题意\n  // s 已经遍历完毕且ip是四段的话, 该ip可以进结果数组了\n  if (ip.length == 4) {\n    if (start == s.length) {\n      res.push(ip.join('.'));\n      return;\n    }\n    // 未遍历完s ip已经4段 该ip不合题意\n    if (start < s.length) {\n      return;\n    }\n  }\n  // s 已经遍历完了,但是ip不到四段,返回\n  if (ip.length < 4 && start == s.length) {\n    return;\n  }\n  // 从每个起始位置开始切割都是三个长度\n  for (let l = 1; l <= 3; l++) {\n    if (start + l > s.length) return; // 索引超过边界\n    if ((l == 2 || l == 3) && s[start] == '0') return; // 2/3子串以0开头\n    let part = s.substring(start, start + l); // 切割子串\n    if (Number(part) > 255) return; // 子串不符合条件 这里已经l==3了 continue和return是一样的效果\n    // part符合条件\n    ip.push(part.slice());\n    // 下次递归的子串的起始位置是start+l\n    dfs(res, ip, start + l, s);\n    ip.pop();\n  }\n}\n```\n\n\n\n##### [473] Matchsticks to Square\n\n> Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used **exactly** one time.\n>\n> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n\n需要注意的是, 在采用递归方法的情况下,  这里不需要在选择位置的外面再套一层for循环去遍历火柴, 因为不存在第一根火柴找到合适位置之后, 把第一根火柴去掉, 以第二根火柴为第一根火柴, 再重新开始摆放. 只需要每根火柴摆放好之后, 去递归摆放下一根火柴即可.\n\n```javascript\n// 使用小女孩的所有火柴拼成一个正方形\n// 回溯 使用所有的火柴 每根火柴只能用一次\nvar makesquare = function (nums) {\n  let sum = 0;\n  nums.forEach((val) => {\n    sum += val;\n  })\n  if (sum % 4 != 0) return false;\n  let res = [0, 0, 0, 0];\n  helper(nums, 0, res, sum / 4);\n  return res[0] != 0;\n};\n\nvar helper = (nums, index, res, sum) => {\n  // 递归结束条件 所有火柴均已放置\n  if (index == nums.length) {\n    // 找到可行解\n    return res[0] == res[1] && res[1] == res[2] && res[2] == res[3];\n  }\n  \n  // 每根火柴均有四个位置可以选择\n  for (let j = 0; j < res.length; j++) {\n    if (res[j] + nums[index] <= sum) {\n      // 做选择\n      res[j] += nums[index];\n      if (helper(nums, index + 1, res, sum)) {\n        return true; // 找到可行解就返回 不再继续尝试\n      }\n      // 撤销选择\n      res[j] -= nums[index];\n    }\n  }\n  // 走到这里说明 剩下的火柴怎么摆放都达不到要求\n  // 说明上一层摆错了位置\n  return false;\n}\n```\n\n","slug":"Backtracking","published":1,"updated":"2020-10-30T10:23:14.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafk0005mm9ha375cu8a","content":"<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><h5 id=\"解题过程-决策树的遍历过程\"><a href=\"#解题过程-决策树的遍历过程\" class=\"headerlink\" title=\"解题过程=决策树的遍历过程:\"></a>解题过程=决策树的遍历过程:</h5><ol>\n<li>路径: 已经做出的选择</li>\n<li>选择列表: 当前可以做的选择</li>\n<li>结束条件: 到达决策树底层, 无法再做选择的条件(可选列表为空等)</li>\n</ol>\n<h5 id=\"回溯算法代码框架\"><a href=\"#回溯算法代码框架\" class=\"headerlink\" title=\"回溯算法代码框架:\"></a>回溯算法代码框架:</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> backtrack = <span class=\"function\">(<span class=\"params\">路径, 选择列表</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> 满足结束条件&#123;</span><br><span class=\"line\">    result.push(路径);</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> 选择 <span class=\"keyword\">in</span> 选择列表&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 做选择</span></span><br><span class=\"line\">  \t将该选择从选择列表中移除</span><br><span class=\"line\">    路径.push(选择)</span><br><span class=\"line\">    backtrack(路径, 选择列表);</span><br><span class=\"line\">  \t<span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">    路径.pop()</span><br><span class=\"line\">    将该选择再加入选择列表</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析:\"></a>时间复杂度分析:</h5><p>递归相关的算法, 时间复杂度计算为: [递归次数]*[递归本身的时间复杂度].</p>\n<h3 id=\"经典例题\"><a href=\"#经典例题\" class=\"headerlink\" title=\"经典例题\"></a>经典例题</h3><h4 id=\"N皇后问题\"><a href=\"#N皇后问题\" class=\"headerlink\" title=\"N皇后问题\"></a>N皇后问题</h4><h5 id=\"51-N-Queens\"><a href=\"#51-N-Queens\" class=\"headerlink\" title=\"[51] N-Queens\"></a>[51] N-Queens</h5><p>套用回溯框架即可, 每确定一个皇后位置, 将其加入已经选择的路径中, 接着进行选择.</p>\n<p>学了框架之后, 思路都清楚了很多.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 皇后彼此不能相互攻击也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> solveNQueens = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化棋盘</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> board = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    board.push(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = [], res = []; <span class=\"comment\">// 存储皇后的纵坐标</span></span><br><span class=\"line\">  backtrack(board, path, res, n, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> backtrack = <span class=\"function\">(<span class=\"params\">board, path, res, n, depth</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// end condition</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path.length == n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> solution = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col <span class=\"keyword\">of</span> path) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> ele = board.slice();</span><br><span class=\"line\">      ele[col] = <span class=\"string\">'Q'</span>;</span><br><span class=\"line\">      solution.push(ele.join(<span class=\"string\">''</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.push(solution);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// make a choice</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.length == <span class=\"number\">0</span> || isValid(depth, i, path)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 进行选择</span></span><br><span class=\"line\">      path.push(i);</span><br><span class=\"line\">      backtrack(board, path, res, n, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">      path.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给两个皇后的坐标 判断这两个皇后是否会互相攻击</span></span><br><span class=\"line\"><span class=\"comment\">// 同一横线 同一竖线 同一斜线</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isValid = <span class=\"function\">(<span class=\"params\">m, n, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; path.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 横坐标相等 纵坐标相等 横坐标坐标差值相等</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == i || n == path[i] || <span class=\"built_in\">Math</span>.abs(m - i) == <span class=\"built_in\">Math</span>.abs(path[i] - n)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"子集问题\"><a href=\"#子集问题\" class=\"headerlink\" title=\"子集问题\"></a>子集问题</h4><h5 id=\"78-Subsets\"><a href=\"#78-Subsets\" class=\"headerlink\" title=\"[78] Subsets\"></a>[78] Subsets</h5><blockquote>\n<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<p>观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。</p>\n<p>首先，它们的解空间非常大：</p>\n<ul>\n<li>全排列：N!。</li>\n</ul>\n<ul>\n<li>组合：N!。</li>\n</ul>\n<ul>\n<li>子集：2^N, 每个元素都可能存在或不存在。</li>\n</ul>\n<p>在它们的指数级解法中，要确保生成的结果 <strong>完整</strong> 且 <strong>无冗余</strong>，有三种常用的方法：</p>\n<ol>\n<li>递归</li>\n<li>回溯</li>\n<li>基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集</li>\n</ol>\n<p>相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。</p>\n<p>此外，第三种方法具有<strong>最优的时间复杂度</strong>，可以生成按照字典顺序的输出结果。</p>\n<h6 id=\"solution-1-字典排序（二进制排序）-子集\"><a href=\"#solution-1-字典排序（二进制排序）-子集\" class=\"headerlink\" title=\"solution 1 : 字典排序（二进制排序） 子集\"></a>solution 1 : 字典排序（二进制排序） 子集</h6><p>这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.</p>\n<p>数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.</p>\n<p>因此该方法的思路如下:</p>\n<p>假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8</p>\n<p>则从 0 - 7 的二进制对应分别为 000-111</p>\n<p>每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].</p>\n<img src=\"/2020/08/18/Backtracking/bitmask4.png\" class=\"\" title=\"bitmask4\">\n<p>需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsets = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> subSets = [];</span><br><span class=\"line\">  <span class=\"comment\">// 根据数组长度计算器其子集数量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> subSetsNum = <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, len);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; subSetsNum; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 十进制转换为二进制</span></span><br><span class=\"line\">    <span class=\"comment\">// 每一个二进制都唯一对应一个子集</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> setNoStr = i.toString(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (setNoStr.length &lt; len) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果长度不足 len，前面添加 0</span></span><br><span class=\"line\">      setNoStr = <span class=\"string\">'0'</span> + setNoStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> setNoList = setNoStr.split(<span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subSet = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (setNoList[j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">        subSet.push(nums[j]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    subSets.push(subSet);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subSets;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。</li>\n<li>空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。</li>\n</ul>\n<h6 id=\"solution-2-数学归纳法\"><a href=\"#solution-2-数学归纳法\" class=\"headerlink\" title=\"solution 2 : 数学归纳法\"></a>solution 2 : 数学归纳法</h6><p>这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsets = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> subSets = [[]];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subSets</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = subSets.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; l; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> ele = subSets[j].concat([nums[i]]);</span><br><span class=\"line\">      subSets.push(ele);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subSets;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度:  总共添加2^N个子集, 每个子集是数组形式, 子集通过深拷贝塞进结果数组中, 拷贝耗时O(N). 因此, 总的时间复杂度是 O(N*2^N).</p>\n<p>空间复杂度: 存储每个子集需要 O(N)的递归堆栈空间(不算结果集), 算上结果的话, 一共2^N个子集, 因此所需空间为 O(N*2^N).</p>\n<h6 id=\"Solution-3-回溯解法\"><a href=\"#Solution-3-回溯解法\" class=\"headerlink\" title=\"Solution 3 :  回溯解法\"></a>Solution 3 :  回溯解法</h6><p>使用回溯模板. 控制start.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsets = <span class=\"function\">(<span class=\"params\">nums</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [], path = [];</span><br><span class=\"line\">  helper(nums, res, path);</span><br><span class=\"line\">  res.push([]); <span class=\"comment\">// 添加空集</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">choice, res, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// end condition</span></span><br><span class=\"line\">  <span class=\"comment\">// 没有节点可以选择时 返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (choice.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; choice.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">    path.push(choice[i]);</span><br><span class=\"line\">    res.push(path.slice()); <span class=\"comment\">// 每一个节点都是子集</span></span><br><span class=\"line\">    <span class=\"comment\">// 对于一个没有重复元素的集合来说</span></span><br><span class=\"line\">    <span class=\"comment\">// 在添加元素时 直接向后作为选择列表即可</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为前面的元素与当前元素的子集已经被先前元素添加过了</span></span><br><span class=\"line\">    <span class=\"comment\">// 排除已选择的数字</span></span><br><span class=\"line\">    helper(choice.slice(i + <span class=\"number\">1</span>), res, path);</span><br><span class=\"line\">    <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">    path.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"90-Subsets-II\"><a href=\"#90-Subsets-II\" class=\"headerlink\" title=\"[90] Subsets II\"></a>[90] Subsets II</h5><blockquote>\n<p>Given a collection of integers that might contain duplicates, <strong><em>nums\\</em></strong>, return all possible subsets (the power set).</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<p>思路与子集时类似, 只是需要剪枝操作, <strong>将同一层其余相同的元素除去</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsetsWithDup = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(); <span class=\"comment\">// 排序操作 使得相同元素相邻</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">    recur(i, <span class=\"number\">0</span>, len, [], res, nums);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> recur = <span class=\"function\">(<span class=\"params\">depth, first, len, curr, res, nums</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (curr.length == depth) &#123;</span><br><span class=\"line\">    res.push(curr.slice()); <span class=\"comment\">// 将当前子集的深拷贝加入结果数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = first; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; first &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 一开始写成了 i&gt;0 结果总是不对 后来知道每次加元素是从 first 开始 不是 0 开始</span></span><br><span class=\"line\">      <span class=\"comment\">// 每次当作为起始点往数组加入元素时,不能加入与上一个元素相同的元素</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr.push(nums[i]);</span><br><span class=\"line\">    recur(depth, i + <span class=\"number\">1</span>, len, curr, res, nums);</span><br><span class=\"line\">    curr.pop(); <span class=\"comment\">// 回溯 回到初始状态</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"括号问题\"><a href=\"#括号问题\" class=\"headerlink\" title=\"括号问题\"></a>括号问题</h4><p>两个性质:</p>\n<ol>\n<li>合法的括号组合中, 左括号数目=右括号数目.</li>\n<li>一个合法的括号组合字符串 s, 对于任意 0&lt;=i<len(s), 子串 s[0, i] 中, 左括号数目>=右括号数目.</li>\n</ol>\n<h5 id=\"22-Generate-Parentheses\"><a href=\"#22-Generate-Parentheses\" class=\"headerlink\" title=\"[22] Generate Parentheses\"></a>[22] Generate Parentheses</h5><blockquote>\n<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>\n</blockquote>\n<p>对于该题题意的理解, 可以是, 现在有 <code>2n</code> 个位置, 每个位置可以放置<code>&#39;(&#39;</code>(数目为n)/<code>&#39;)&#39;</code>(数目为n), 请问一共有多少种合法的放置方式?</p>\n<p>则解题思路是: <em>先得到 2^(2n) 种组合方式, 再去除不合法的部分即可.</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2020/10/21 学习回溯模板之后 很简洁</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> generateParenthesis = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = [], res = [];</span><br><span class=\"line\">  helper(path, res, n, n, n);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">path, res, n, left, right</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 左括号剩的比右括号多 不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &gt; right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 使用次数小于0 不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span> || right &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 左右括号都恰好用完, 得到一个合法的括号</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left == <span class=\"number\">0</span> &amp;&amp; right == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    res.push(path.join(<span class=\"string\">''</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 尝试放一个左括号</span></span><br><span class=\"line\">  path.push(<span class=\"string\">'('</span>); <span class=\"comment\">// 选择</span></span><br><span class=\"line\">  helper(path, res, n, left - <span class=\"number\">1</span>, right);</span><br><span class=\"line\">  path.pop(); <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">  <span class=\"comment\">// 尝试放一个右括号</span></span><br><span class=\"line\">  path.push(<span class=\"string\">')'</span>); <span class=\"comment\">// 选择</span></span><br><span class=\"line\">  helper(path, res, n, left, right - <span class=\"number\">1</span>);</span><br><span class=\"line\">  path.pop(); <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"排列问题\"><a href=\"#排列问题\" class=\"headerlink\" title=\"排列问题\"></a>排列问题</h4><h5 id=\"46-Permutations\"><a href=\"#46-Permutations\" class=\"headerlink\" title=\"[46] Permutations\"></a>[46] Permutations</h5><blockquote>\n<p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>\n</blockquote>\n<p>时间复杂度: O(N*N!)</p>\n<p>全排列一共有 N! 种可能, 实现每一种可能需要遍历整个数组即O(N)时间, 所以可得.</p>\n<p>使用回溯模板. 删除已经选择的数字.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> permute = <span class=\"function\">(<span class=\"params\">nums</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [], path = [];</span><br><span class=\"line\">  helper(nums, res, path);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">nums, res, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 选择列表为空</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    res.push(path.slice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">    path.push(nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nums_cp = nums.slice();</span><br><span class=\"line\">    <span class=\"comment\">// 从选择列表中删除这个选择</span></span><br><span class=\"line\">    <span class=\"comment\">// 排除已选择的数字</span></span><br><span class=\"line\">    nums.splice(i, <span class=\"number\">1</span>); </span><br><span class=\"line\">    helper(nums, res, path);</span><br><span class=\"line\">    <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">    path.pop(); </span><br><span class=\"line\">    nums = nums_cp; <span class=\"comment\">// 将移除的选择重新加入选择列表</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"组合问题\"><a href=\"#组合问题\" class=\"headerlink\" title=\"组合问题\"></a>组合问题</h4><h5 id=\"77-Combinations\"><a href=\"#77-Combinations\" class=\"headerlink\" title=\"[77] Combinations\"></a>[77] Combinations</h5><blockquote>\n<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>\n<p>You may return the answer in <strong>any order</strong>.</p>\n</blockquote>\n<p>使用回溯模板, 决策树的深度为 k. 将深度为k的节点均加入节点列表.</p>\n<p>其实就是自己问题的一部分, 使用start排除已经做出的选择.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> combine = <span class=\"function\">(<span class=\"params\">n, k</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = [], res = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> choice = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    choice.push(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  helper(choice, <span class=\"number\">0</span>, path, res, k);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">choice, start, path, res, k</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path.length == k) &#123;</span><br><span class=\"line\">    res.push(path.slice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = start; i &lt; choice.length; i++) &#123;</span><br><span class=\"line\">    path.push(choice[i]);</span><br><span class=\"line\">    helper(choice, i + <span class=\"number\">1</span>, path, res, k);</span><br><span class=\"line\">    path.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h4><h5 id=\"79-Word-Search\"><a href=\"#79-Word-Search\" class=\"headerlink\" title=\"[79] Word Search\"></a>[79] Word Search</h5><blockquote>\n<p>Given a 2D board and a word, find if the word exists in the grid.</p>\n<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n</blockquote>\n<p>回溯算法本质就是暴力穷举.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> exist = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">board, word</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = board.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (board[i][j] == word[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = findNeighbor(board, word, <span class=\"number\">0</span>, i, j, &#123;&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> findNeighbor = <span class=\"function\">(<span class=\"params\">board, word, w, row, col, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不能在这里进行判断 因为尽管w这里表示最后一个字母</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是却并不一定能在board里找到 需要再经过判断</span></span><br><span class=\"line\">  <span class=\"comment\">// if (w + 1 == word.length) return true;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 选择不合法则回到上一层</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> key = row + <span class=\"string\">'+'</span> + col;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (row &gt;= board.length || row &lt; <span class=\"number\">0</span> || col &gt;= board[<span class=\"number\">0</span>].length || col &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    || visited[key] || board[row][col] != word[w]</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 选择列表</span></span><br><span class=\"line\">  <span class=\"comment\">// 对一个可能的选择都进行尝试</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">  visited[key] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 递归结束条件</span></span><br><span class=\"line\">  <span class=\"comment\">// 一旦word的最后一个字母也找到 则说明成功找到word</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (w + <span class=\"number\">1</span> == word.length) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 一旦找到目标字符串(递归返回值为true) 就直接返回 不用再进行下面的递归了 减少递归次数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> r1 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row - <span class=\"number\">1</span>, col, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r1) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r2 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row + <span class=\"number\">1</span>, col, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r2) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r3 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row, col - <span class=\"number\">1</span>, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r3) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r4 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row, col + <span class=\"number\">1</span>, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r4) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找了一圈没有找到 说明从该节点开始不是正确的选择</span></span><br><span class=\"line\">  <span class=\"comment\">// 则在该节点应该 撤销选择 回到上一层 在上一层转换搜索方向</span></span><br><span class=\"line\">  visited[key] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"93-Restore-IP-Addresses\"><a href=\"#93-Restore-IP-Addresses\" class=\"headerlink\" title=\"[93] Restore IP Addresses\"></a>[93] Restore IP Addresses</h5><blockquote>\n<p>Given a string <code>s</code> containing only digits. Return all possible valid IP addresses that can be obtained from <code>s</code>. You can return them in <strong>any</strong> order.</p>\n<p>A <strong>valid IP address</strong> consists of exactly four integers, each integer is between <code>0</code> and <code>255</code>, separated by single points and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are <strong>valid</strong> IP addresses and “0.011.255.245”, “192.168.1.312” and “192.168@1.1” are <strong>invalid</strong> IP addresses. </p>\n</blockquote>\n<p>就是大概有想法但是却实现不出来, 说明思路还不是很清楚, 需要画树状图帮助自己理解.</p>\n<p>多画树状图, 理解回溯过程. 被这道题折磨好久.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 合法的url的条件:</span></span><br><span class=\"line\"><span class=\"comment\"> * 将字符串分为四个部分, 每个部分的数字[0,255], 不超过3位</span></span><br><span class=\"line\"><span class=\"comment\"> * 中间的数字不能以0开头</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restoreIpAddresses = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = s.length;</span><br><span class=\"line\">  <span class=\"comment\">// 字符串长度不够则直接返回空数组</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">12</span> || len &lt; <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ip = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dfs(res, ip, start, s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;array&#125;</span> </span>res 存储合法ip</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;array&#125;</span> </span>ip 存储ip的每一段</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>start 剩余需要继续递归的子串</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>s </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dfs = <span class=\"function\">(<span class=\"params\">res, ip, start, s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在开始切割子串之前, 判断ip是否符合题意</span></span><br><span class=\"line\">  <span class=\"comment\">// s 已经遍历完毕且ip是四段的话, 该ip可以进结果数组了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip.length == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == s.length) &#123;</span><br><span class=\"line\">      res.push(ip.join(<span class=\"string\">'.'</span>));</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 未遍历完s ip已经4段 该ip不合题意</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; s.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// s 已经遍历完了,但是ip不到四段,返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip.length &lt; <span class=\"number\">4</span> &amp;&amp; start == s.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从每个起始位置开始切割都是三个长度</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">1</span>; l &lt;= <span class=\"number\">3</span>; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start + l &gt; s.length) <span class=\"keyword\">return</span>; <span class=\"comment\">// 索引超过边界</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((l == <span class=\"number\">2</span> || l == <span class=\"number\">3</span>) &amp;&amp; s[start] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 2/3子串以0开头</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> part = s.substring(start, start + l); <span class=\"comment\">// 切割子串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>(part) &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 子串不符合条件 这里已经l==3了 continue和return是一样的效果</span></span><br><span class=\"line\">    <span class=\"comment\">// part符合条件</span></span><br><span class=\"line\">    ip.push(part.slice());</span><br><span class=\"line\">    <span class=\"comment\">// 下次递归的子串的起始位置是start+l</span></span><br><span class=\"line\">    dfs(res, ip, start + l, s);</span><br><span class=\"line\">    ip.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"473-Matchsticks-to-Square\"><a href=\"#473-Matchsticks-to-Square\" class=\"headerlink\" title=\"[473] Matchsticks to Square\"></a>[473] Matchsticks to Square</h5><blockquote>\n<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used <strong>exactly</strong> one time.</p>\n<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n</blockquote>\n<p>需要注意的是, 在采用递归方法的情况下,  这里不需要在选择位置的外面再套一层for循环去遍历火柴, 因为不存在第一根火柴找到合适位置之后, 把第一根火柴去掉, 以第二根火柴为第一根火柴, 再重新开始摆放. 只需要每根火柴摆放好之后, 去递归摆放下一根火柴即可.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用小女孩的所有火柴拼成一个正方形</span></span><br><span class=\"line\"><span class=\"comment\">// 回溯 使用所有的火柴 每根火柴只能用一次</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> makesquare = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  nums.forEach(<span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    sum += val;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sum % <span class=\"number\">4</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\">  helper(nums, <span class=\"number\">0</span>, res, sum / <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res[<span class=\"number\">0</span>] != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">nums, index, res, sum</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 递归结束条件 所有火柴均已放置</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index == nums.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找到可行解</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res[<span class=\"number\">0</span>] == res[<span class=\"number\">1</span>] &amp;&amp; res[<span class=\"number\">1</span>] == res[<span class=\"number\">2</span>] &amp;&amp; res[<span class=\"number\">2</span>] == res[<span class=\"number\">3</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 每根火柴均有四个位置可以选择</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; res.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res[j] + nums[index] &lt;= sum) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">      res[j] += nums[index];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (helper(nums, index + <span class=\"number\">1</span>, res, sum)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 找到可行解就返回 不再继续尝试</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">      res[j] -= nums[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 走到这里说明 剩下的火柴怎么摆放都达不到要求</span></span><br><span class=\"line\">  <span class=\"comment\">// 说明上一层摆错了位置</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><h5 id=\"解题过程-决策树的遍历过程\"><a href=\"#解题过程-决策树的遍历过程\" class=\"headerlink\" title=\"解题过程=决策树的遍历过程:\"></a>解题过程=决策树的遍历过程:</h5><ol>\n<li>路径: 已经做出的选择</li>\n<li>选择列表: 当前可以做的选择</li>\n<li>结束条件: 到达决策树底层, 无法再做选择的条件(可选列表为空等)</li>\n</ol>\n<h5 id=\"回溯算法代码框架\"><a href=\"#回溯算法代码框架\" class=\"headerlink\" title=\"回溯算法代码框架:\"></a>回溯算法代码框架:</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> backtrack = <span class=\"function\">(<span class=\"params\">路径, 选择列表</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> 满足结束条件&#123;</span><br><span class=\"line\">    result.push(路径);</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> 选择 <span class=\"keyword\">in</span> 选择列表&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 做选择</span></span><br><span class=\"line\">  \t将该选择从选择列表中移除</span><br><span class=\"line\">    路径.push(选择)</span><br><span class=\"line\">    backtrack(路径, 选择列表);</span><br><span class=\"line\">  \t<span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">    路径.pop()</span><br><span class=\"line\">    将该选择再加入选择列表</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析:\"></a>时间复杂度分析:</h5><p>递归相关的算法, 时间复杂度计算为: [递归次数]*[递归本身的时间复杂度].</p>\n<h3 id=\"经典例题\"><a href=\"#经典例题\" class=\"headerlink\" title=\"经典例题\"></a>经典例题</h3><h4 id=\"N皇后问题\"><a href=\"#N皇后问题\" class=\"headerlink\" title=\"N皇后问题\"></a>N皇后问题</h4><h5 id=\"51-N-Queens\"><a href=\"#51-N-Queens\" class=\"headerlink\" title=\"[51] N-Queens\"></a>[51] N-Queens</h5><p>套用回溯框架即可, 每确定一个皇后位置, 将其加入已经选择的路径中, 接着进行选择.</p>\n<p>学了框架之后, 思路都清楚了很多.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 皇后彼此不能相互攻击也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> solveNQueens = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化棋盘</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> board = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    board.push(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = [], res = []; <span class=\"comment\">// 存储皇后的纵坐标</span></span><br><span class=\"line\">  backtrack(board, path, res, n, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> backtrack = <span class=\"function\">(<span class=\"params\">board, path, res, n, depth</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// end condition</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path.length == n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> solution = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col <span class=\"keyword\">of</span> path) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> ele = board.slice();</span><br><span class=\"line\">      ele[col] = <span class=\"string\">'Q'</span>;</span><br><span class=\"line\">      solution.push(ele.join(<span class=\"string\">''</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.push(solution);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// make a choice</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.length == <span class=\"number\">0</span> || isValid(depth, i, path)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 进行选择</span></span><br><span class=\"line\">      path.push(i);</span><br><span class=\"line\">      backtrack(board, path, res, n, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">      path.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给两个皇后的坐标 判断这两个皇后是否会互相攻击</span></span><br><span class=\"line\"><span class=\"comment\">// 同一横线 同一竖线 同一斜线</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isValid = <span class=\"function\">(<span class=\"params\">m, n, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; path.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 横坐标相等 纵坐标相等 横坐标坐标差值相等</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == i || n == path[i] || <span class=\"built_in\">Math</span>.abs(m - i) == <span class=\"built_in\">Math</span>.abs(path[i] - n)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"子集问题\"><a href=\"#子集问题\" class=\"headerlink\" title=\"子集问题\"></a>子集问题</h4><h5 id=\"78-Subsets\"><a href=\"#78-Subsets\" class=\"headerlink\" title=\"[78] Subsets\"></a>[78] Subsets</h5><blockquote>\n<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<p>观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。</p>\n<p>首先，它们的解空间非常大：</p>\n<ul>\n<li>全排列：N!。</li>\n</ul>\n<ul>\n<li>组合：N!。</li>\n</ul>\n<ul>\n<li>子集：2^N, 每个元素都可能存在或不存在。</li>\n</ul>\n<p>在它们的指数级解法中，要确保生成的结果 <strong>完整</strong> 且 <strong>无冗余</strong>，有三种常用的方法：</p>\n<ol>\n<li>递归</li>\n<li>回溯</li>\n<li>基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集</li>\n</ol>\n<p>相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。</p>\n<p>此外，第三种方法具有<strong>最优的时间复杂度</strong>，可以生成按照字典顺序的输出结果。</p>\n<h6 id=\"solution-1-字典排序（二进制排序）-子集\"><a href=\"#solution-1-字典排序（二进制排序）-子集\" class=\"headerlink\" title=\"solution 1 : 字典排序（二进制排序） 子集\"></a>solution 1 : 字典排序（二进制排序） 子集</h6><p>这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.</p>\n<p>数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.</p>\n<p>因此该方法的思路如下:</p>\n<p>假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8</p>\n<p>则从 0 - 7 的二进制对应分别为 000-111</p>\n<p>每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].</p>\n<img src=\"/2020/08/18/Backtracking/bitmask4.png\" class=\"\" title=\"bitmask4\">\n<p>需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsets = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> subSets = [];</span><br><span class=\"line\">  <span class=\"comment\">// 根据数组长度计算器其子集数量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> subSetsNum = <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, len);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; subSetsNum; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 十进制转换为二进制</span></span><br><span class=\"line\">    <span class=\"comment\">// 每一个二进制都唯一对应一个子集</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> setNoStr = i.toString(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (setNoStr.length &lt; len) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果长度不足 len，前面添加 0</span></span><br><span class=\"line\">      setNoStr = <span class=\"string\">'0'</span> + setNoStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> setNoList = setNoStr.split(<span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subSet = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (setNoList[j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">        subSet.push(nums[j]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    subSets.push(subSet);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subSets;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。</li>\n<li>空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。</li>\n</ul>\n<h6 id=\"solution-2-数学归纳法\"><a href=\"#solution-2-数学归纳法\" class=\"headerlink\" title=\"solution 2 : 数学归纳法\"></a>solution 2 : 数学归纳法</h6><p>这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsets = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> subSets = [[]];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subSets</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = subSets.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; l; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> ele = subSets[j].concat([nums[i]]);</span><br><span class=\"line\">      subSets.push(ele);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subSets;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度:  总共添加2^N个子集, 每个子集是数组形式, 子集通过深拷贝塞进结果数组中, 拷贝耗时O(N). 因此, 总的时间复杂度是 O(N*2^N).</p>\n<p>空间复杂度: 存储每个子集需要 O(N)的递归堆栈空间(不算结果集), 算上结果的话, 一共2^N个子集, 因此所需空间为 O(N*2^N).</p>\n<h6 id=\"Solution-3-回溯解法\"><a href=\"#Solution-3-回溯解法\" class=\"headerlink\" title=\"Solution 3 :  回溯解法\"></a>Solution 3 :  回溯解法</h6><p>使用回溯模板. 控制start.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsets = <span class=\"function\">(<span class=\"params\">nums</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [], path = [];</span><br><span class=\"line\">  helper(nums, res, path);</span><br><span class=\"line\">  res.push([]); <span class=\"comment\">// 添加空集</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">choice, res, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// end condition</span></span><br><span class=\"line\">  <span class=\"comment\">// 没有节点可以选择时 返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (choice.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; choice.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">    path.push(choice[i]);</span><br><span class=\"line\">    res.push(path.slice()); <span class=\"comment\">// 每一个节点都是子集</span></span><br><span class=\"line\">    <span class=\"comment\">// 对于一个没有重复元素的集合来说</span></span><br><span class=\"line\">    <span class=\"comment\">// 在添加元素时 直接向后作为选择列表即可</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为前面的元素与当前元素的子集已经被先前元素添加过了</span></span><br><span class=\"line\">    <span class=\"comment\">// 排除已选择的数字</span></span><br><span class=\"line\">    helper(choice.slice(i + <span class=\"number\">1</span>), res, path);</span><br><span class=\"line\">    <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">    path.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"90-Subsets-II\"><a href=\"#90-Subsets-II\" class=\"headerlink\" title=\"[90] Subsets II\"></a>[90] Subsets II</h5><blockquote>\n<p>Given a collection of integers that might contain duplicates, <strong><em>nums\\</em></strong>, return all possible subsets (the power set).</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<p>思路与子集时类似, 只是需要剪枝操作, <strong>将同一层其余相同的元素除去</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsetsWithDup = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(); <span class=\"comment\">// 排序操作 使得相同元素相邻</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">    recur(i, <span class=\"number\">0</span>, len, [], res, nums);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> recur = <span class=\"function\">(<span class=\"params\">depth, first, len, curr, res, nums</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (curr.length == depth) &#123;</span><br><span class=\"line\">    res.push(curr.slice()); <span class=\"comment\">// 将当前子集的深拷贝加入结果数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = first; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; first &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 一开始写成了 i&gt;0 结果总是不对 后来知道每次加元素是从 first 开始 不是 0 开始</span></span><br><span class=\"line\">      <span class=\"comment\">// 每次当作为起始点往数组加入元素时,不能加入与上一个元素相同的元素</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr.push(nums[i]);</span><br><span class=\"line\">    recur(depth, i + <span class=\"number\">1</span>, len, curr, res, nums);</span><br><span class=\"line\">    curr.pop(); <span class=\"comment\">// 回溯 回到初始状态</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"括号问题\"><a href=\"#括号问题\" class=\"headerlink\" title=\"括号问题\"></a>括号问题</h4><p>两个性质:</p>\n<ol>\n<li>合法的括号组合中, 左括号数目=右括号数目.</li>\n<li>一个合法的括号组合字符串 s, 对于任意 0&lt;=i<len(s), 子串 s[0, i] 中, 左括号数目>=右括号数目.</li>\n</ol>\n<h5 id=\"22-Generate-Parentheses\"><a href=\"#22-Generate-Parentheses\" class=\"headerlink\" title=\"[22] Generate Parentheses\"></a>[22] Generate Parentheses</h5><blockquote>\n<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>\n</blockquote>\n<p>对于该题题意的理解, 可以是, 现在有 <code>2n</code> 个位置, 每个位置可以放置<code>&#39;(&#39;</code>(数目为n)/<code>&#39;)&#39;</code>(数目为n), 请问一共有多少种合法的放置方式?</p>\n<p>则解题思路是: <em>先得到 2^(2n) 种组合方式, 再去除不合法的部分即可.</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2020/10/21 学习回溯模板之后 很简洁</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> generateParenthesis = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = [], res = [];</span><br><span class=\"line\">  helper(path, res, n, n, n);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">path, res, n, left, right</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 左括号剩的比右括号多 不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &gt; right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 使用次数小于0 不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span> || right &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 左右括号都恰好用完, 得到一个合法的括号</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left == <span class=\"number\">0</span> &amp;&amp; right == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    res.push(path.join(<span class=\"string\">''</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 尝试放一个左括号</span></span><br><span class=\"line\">  path.push(<span class=\"string\">'('</span>); <span class=\"comment\">// 选择</span></span><br><span class=\"line\">  helper(path, res, n, left - <span class=\"number\">1</span>, right);</span><br><span class=\"line\">  path.pop(); <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">  <span class=\"comment\">// 尝试放一个右括号</span></span><br><span class=\"line\">  path.push(<span class=\"string\">')'</span>); <span class=\"comment\">// 选择</span></span><br><span class=\"line\">  helper(path, res, n, left, right - <span class=\"number\">1</span>);</span><br><span class=\"line\">  path.pop(); <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"排列问题\"><a href=\"#排列问题\" class=\"headerlink\" title=\"排列问题\"></a>排列问题</h4><h5 id=\"46-Permutations\"><a href=\"#46-Permutations\" class=\"headerlink\" title=\"[46] Permutations\"></a>[46] Permutations</h5><blockquote>\n<p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>\n</blockquote>\n<p>时间复杂度: O(N*N!)</p>\n<p>全排列一共有 N! 种可能, 实现每一种可能需要遍历整个数组即O(N)时间, 所以可得.</p>\n<p>使用回溯模板. 删除已经选择的数字.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> permute = <span class=\"function\">(<span class=\"params\">nums</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [], path = [];</span><br><span class=\"line\">  helper(nums, res, path);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">nums, res, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 选择列表为空</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    res.push(path.slice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">    path.push(nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nums_cp = nums.slice();</span><br><span class=\"line\">    <span class=\"comment\">// 从选择列表中删除这个选择</span></span><br><span class=\"line\">    <span class=\"comment\">// 排除已选择的数字</span></span><br><span class=\"line\">    nums.splice(i, <span class=\"number\">1</span>); </span><br><span class=\"line\">    helper(nums, res, path);</span><br><span class=\"line\">    <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">    path.pop(); </span><br><span class=\"line\">    nums = nums_cp; <span class=\"comment\">// 将移除的选择重新加入选择列表</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"组合问题\"><a href=\"#组合问题\" class=\"headerlink\" title=\"组合问题\"></a>组合问题</h4><h5 id=\"77-Combinations\"><a href=\"#77-Combinations\" class=\"headerlink\" title=\"[77] Combinations\"></a>[77] Combinations</h5><blockquote>\n<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>\n<p>You may return the answer in <strong>any order</strong>.</p>\n</blockquote>\n<p>使用回溯模板, 决策树的深度为 k. 将深度为k的节点均加入节点列表.</p>\n<p>其实就是自己问题的一部分, 使用start排除已经做出的选择.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> combine = <span class=\"function\">(<span class=\"params\">n, k</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = [], res = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> choice = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    choice.push(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  helper(choice, <span class=\"number\">0</span>, path, res, k);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">choice, start, path, res, k</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path.length == k) &#123;</span><br><span class=\"line\">    res.push(path.slice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = start; i &lt; choice.length; i++) &#123;</span><br><span class=\"line\">    path.push(choice[i]);</span><br><span class=\"line\">    helper(choice, i + <span class=\"number\">1</span>, path, res, k);</span><br><span class=\"line\">    path.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h4><h5 id=\"79-Word-Search\"><a href=\"#79-Word-Search\" class=\"headerlink\" title=\"[79] Word Search\"></a>[79] Word Search</h5><blockquote>\n<p>Given a 2D board and a word, find if the word exists in the grid.</p>\n<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n</blockquote>\n<p>回溯算法本质就是暴力穷举.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> exist = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">board, word</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = board.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (board[i][j] == word[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = findNeighbor(board, word, <span class=\"number\">0</span>, i, j, &#123;&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> findNeighbor = <span class=\"function\">(<span class=\"params\">board, word, w, row, col, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不能在这里进行判断 因为尽管w这里表示最后一个字母</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是却并不一定能在board里找到 需要再经过判断</span></span><br><span class=\"line\">  <span class=\"comment\">// if (w + 1 == word.length) return true;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 选择不合法则回到上一层</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> key = row + <span class=\"string\">'+'</span> + col;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (row &gt;= board.length || row &lt; <span class=\"number\">0</span> || col &gt;= board[<span class=\"number\">0</span>].length || col &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    || visited[key] || board[row][col] != word[w]</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 选择列表</span></span><br><span class=\"line\">  <span class=\"comment\">// 对一个可能的选择都进行尝试</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">  visited[key] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 递归结束条件</span></span><br><span class=\"line\">  <span class=\"comment\">// 一旦word的最后一个字母也找到 则说明成功找到word</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (w + <span class=\"number\">1</span> == word.length) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 一旦找到目标字符串(递归返回值为true) 就直接返回 不用再进行下面的递归了 减少递归次数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> r1 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row - <span class=\"number\">1</span>, col, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r1) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r2 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row + <span class=\"number\">1</span>, col, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r2) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r3 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row, col - <span class=\"number\">1</span>, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r3) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r4 = findNeighbor(board, word, w + <span class=\"number\">1</span>, row, col + <span class=\"number\">1</span>, visited);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r4) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找了一圈没有找到 说明从该节点开始不是正确的选择</span></span><br><span class=\"line\">  <span class=\"comment\">// 则在该节点应该 撤销选择 回到上一层 在上一层转换搜索方向</span></span><br><span class=\"line\">  visited[key] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"93-Restore-IP-Addresses\"><a href=\"#93-Restore-IP-Addresses\" class=\"headerlink\" title=\"[93] Restore IP Addresses\"></a>[93] Restore IP Addresses</h5><blockquote>\n<p>Given a string <code>s</code> containing only digits. Return all possible valid IP addresses that can be obtained from <code>s</code>. You can return them in <strong>any</strong> order.</p>\n<p>A <strong>valid IP address</strong> consists of exactly four integers, each integer is between <code>0</code> and <code>255</code>, separated by single points and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are <strong>valid</strong> IP addresses and “0.011.255.245”, “192.168.1.312” and “192.168@1.1” are <strong>invalid</strong> IP addresses. </p>\n</blockquote>\n<p>就是大概有想法但是却实现不出来, 说明思路还不是很清楚, 需要画树状图帮助自己理解.</p>\n<p>多画树状图, 理解回溯过程. 被这道题折磨好久.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 合法的url的条件:</span></span><br><span class=\"line\"><span class=\"comment\"> * 将字符串分为四个部分, 每个部分的数字[0,255], 不超过3位</span></span><br><span class=\"line\"><span class=\"comment\"> * 中间的数字不能以0开头</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restoreIpAddresses = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = s.length;</span><br><span class=\"line\">  <span class=\"comment\">// 字符串长度不够则直接返回空数组</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">12</span> || len &lt; <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ip = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dfs(res, ip, start, s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;array&#125;</span> </span>res 存储合法ip</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;array&#125;</span> </span>ip 存储ip的每一段</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>start 剩余需要继续递归的子串</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>s </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dfs = <span class=\"function\">(<span class=\"params\">res, ip, start, s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在开始切割子串之前, 判断ip是否符合题意</span></span><br><span class=\"line\">  <span class=\"comment\">// s 已经遍历完毕且ip是四段的话, 该ip可以进结果数组了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip.length == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == s.length) &#123;</span><br><span class=\"line\">      res.push(ip.join(<span class=\"string\">'.'</span>));</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 未遍历完s ip已经4段 该ip不合题意</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; s.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// s 已经遍历完了,但是ip不到四段,返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip.length &lt; <span class=\"number\">4</span> &amp;&amp; start == s.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从每个起始位置开始切割都是三个长度</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">1</span>; l &lt;= <span class=\"number\">3</span>; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start + l &gt; s.length) <span class=\"keyword\">return</span>; <span class=\"comment\">// 索引超过边界</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((l == <span class=\"number\">2</span> || l == <span class=\"number\">3</span>) &amp;&amp; s[start] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 2/3子串以0开头</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> part = s.substring(start, start + l); <span class=\"comment\">// 切割子串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>(part) &gt; <span class=\"number\">255</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 子串不符合条件 这里已经l==3了 continue和return是一样的效果</span></span><br><span class=\"line\">    <span class=\"comment\">// part符合条件</span></span><br><span class=\"line\">    ip.push(part.slice());</span><br><span class=\"line\">    <span class=\"comment\">// 下次递归的子串的起始位置是start+l</span></span><br><span class=\"line\">    dfs(res, ip, start + l, s);</span><br><span class=\"line\">    ip.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"473-Matchsticks-to-Square\"><a href=\"#473-Matchsticks-to-Square\" class=\"headerlink\" title=\"[473] Matchsticks to Square\"></a>[473] Matchsticks to Square</h5><blockquote>\n<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used <strong>exactly</strong> one time.</p>\n<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n</blockquote>\n<p>需要注意的是, 在采用递归方法的情况下,  这里不需要在选择位置的外面再套一层for循环去遍历火柴, 因为不存在第一根火柴找到合适位置之后, 把第一根火柴去掉, 以第二根火柴为第一根火柴, 再重新开始摆放. 只需要每根火柴摆放好之后, 去递归摆放下一根火柴即可.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用小女孩的所有火柴拼成一个正方形</span></span><br><span class=\"line\"><span class=\"comment\">// 回溯 使用所有的火柴 每根火柴只能用一次</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> makesquare = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  nums.forEach(<span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    sum += val;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sum % <span class=\"number\">4</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\">  helper(nums, <span class=\"number\">0</span>, res, sum / <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res[<span class=\"number\">0</span>] != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helper = <span class=\"function\">(<span class=\"params\">nums, index, res, sum</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 递归结束条件 所有火柴均已放置</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index == nums.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找到可行解</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res[<span class=\"number\">0</span>] == res[<span class=\"number\">1</span>] &amp;&amp; res[<span class=\"number\">1</span>] == res[<span class=\"number\">2</span>] &amp;&amp; res[<span class=\"number\">2</span>] == res[<span class=\"number\">3</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 每根火柴均有四个位置可以选择</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; res.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res[j] + nums[index] &lt;= sum) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 做选择</span></span><br><span class=\"line\">      res[j] += nums[index];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (helper(nums, index + <span class=\"number\">1</span>, res, sum)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 找到可行解就返回 不再继续尝试</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 撤销选择</span></span><br><span class=\"line\">      res[j] -= nums[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 走到这里说明 剩下的火柴怎么摆放都达不到要求</span></span><br><span class=\"line\">  <span class=\"comment\">// 说明上一层摆错了位置</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Tree","abbrlink":22317,"date":"2020-09-27T04:27:05.000Z","description":"二叉树相关题解","mathjax":true,"_content":"\n### 二叉树\n\n#### 定义\n\n每个节点最多只有两个分支的树结构, 子树分左右.\n\n每层的节点数<=2^(i-1), 总共的节点数\n\n假设**根节点的层数为1,** 则一颗**二叉树总共的节点数不超过2^k-1**(等比数列求和公式得来)\n\n#### 特殊类型\n\n##### 满二叉树\n\n定义: 深度为k, 且总节点数为2^k-1的二叉树, 数的外形是严格三角形.\n\n假设总结点数为n, 则树高为$log_2(n+1)$.\n\n##### 完全二叉树\n\n定义: 高度为h的二叉树,  其第0到(h-1)层的节点都满, 第h层节点不满, 且最后一层的节点都是从左往右排, 节点都在左边, 空位都在右边. Called 完全二叉树. 与满二叉数的节点一一对应.\n\n性质: \n\n一棵完全二叉树的节点数目为 n, 假设根节点的序号为0,  则最后一个节点的序号为n-1. \n\n对于序号为i的节点, 其父节点序号为 **(i-1)/2** [向下取整 画图可知]. 左子节点为left = 2\\*i+1(前提是left<=n-1), 右子节点序号为 right = 2\\*i+2(前提是right<=n-1).\n\n#### 存储结构\n\n#### 遍历\n\n按照系统化方式访问二叉树的每一个节点, 每棵二叉树都有唯一的根节点 root, 是基于树结构的处理入口.\n\n<img src=\"Binary-Tree/二叉树.png\" width=\"50%\" height=\"50%\">\n\n> 深度优先遍历\n\n##### 前(根)序遍历\n\n先访问根节点, 再访问左节点和右节点\n\nABDHEICFJKG\n\n##### 中(根)序遍历 \n\n先访问左子树, 再访问根节点, 再访问右子树\n\nDHBEIAJFKCG\n\n##### 后(根)序遍历\n\n先访问左右子树, 再访问根节点.\n\nHDIEBJKFGCA\n\n注意: 任意一棵树的任意一种遍历序列都无法唯一确定相应的二叉树.\n\n> 广度优先遍历\n\n##### 层序遍历\n\nABCDEFGHIJK\n\n##### 遍历实现\n\n主要使用递归法进行理解与实现.\n\n深度优先一般使用递归方法/栈结构,  广度优先遍历使用队列.\n\n中序(知道左右子树的位置)+前序/后序(知道根节点的位置) + 元素不重复 --> 复原二叉树结构\n\n##### 复杂度分析\n\n统计每个节点被访问的次数\n\n#### \n\n### 二叉查找树(Binary Search Tree-BST)\n\n每个节点都包含一个可比较的键以及相应的值, 且每个节点的值都>=左子树中任意节点的键, <右子树中任意节点的键.\n\n**使用中序遍历可以得到一个有序数组**.\n\nBST使用的每个节点含有2个链接.","source":"_posts/Binary-Tree.md","raw":"---\ntitle: Binary Tree\nabbrlink: 22317\ndate: 2020-09-27 12:27:05\ntags:\ndescription: 二叉树相关题解\nmathjax: true\n---\n\n### 二叉树\n\n#### 定义\n\n每个节点最多只有两个分支的树结构, 子树分左右.\n\n每层的节点数<=2^(i-1), 总共的节点数\n\n假设**根节点的层数为1,** 则一颗**二叉树总共的节点数不超过2^k-1**(等比数列求和公式得来)\n\n#### 特殊类型\n\n##### 满二叉树\n\n定义: 深度为k, 且总节点数为2^k-1的二叉树, 数的外形是严格三角形.\n\n假设总结点数为n, 则树高为$log_2(n+1)$.\n\n##### 完全二叉树\n\n定义: 高度为h的二叉树,  其第0到(h-1)层的节点都满, 第h层节点不满, 且最后一层的节点都是从左往右排, 节点都在左边, 空位都在右边. Called 完全二叉树. 与满二叉数的节点一一对应.\n\n性质: \n\n一棵完全二叉树的节点数目为 n, 假设根节点的序号为0,  则最后一个节点的序号为n-1. \n\n对于序号为i的节点, 其父节点序号为 **(i-1)/2** [向下取整 画图可知]. 左子节点为left = 2\\*i+1(前提是left<=n-1), 右子节点序号为 right = 2\\*i+2(前提是right<=n-1).\n\n#### 存储结构\n\n#### 遍历\n\n按照系统化方式访问二叉树的每一个节点, 每棵二叉树都有唯一的根节点 root, 是基于树结构的处理入口.\n\n<img src=\"Binary-Tree/二叉树.png\" width=\"50%\" height=\"50%\">\n\n> 深度优先遍历\n\n##### 前(根)序遍历\n\n先访问根节点, 再访问左节点和右节点\n\nABDHEICFJKG\n\n##### 中(根)序遍历 \n\n先访问左子树, 再访问根节点, 再访问右子树\n\nDHBEIAJFKCG\n\n##### 后(根)序遍历\n\n先访问左右子树, 再访问根节点.\n\nHDIEBJKFGCA\n\n注意: 任意一棵树的任意一种遍历序列都无法唯一确定相应的二叉树.\n\n> 广度优先遍历\n\n##### 层序遍历\n\nABCDEFGHIJK\n\n##### 遍历实现\n\n主要使用递归法进行理解与实现.\n\n深度优先一般使用递归方法/栈结构,  广度优先遍历使用队列.\n\n中序(知道左右子树的位置)+前序/后序(知道根节点的位置) + 元素不重复 --> 复原二叉树结构\n\n##### 复杂度分析\n\n统计每个节点被访问的次数\n\n#### \n\n### 二叉查找树(Binary Search Tree-BST)\n\n每个节点都包含一个可比较的键以及相应的值, 且每个节点的值都>=左子树中任意节点的键, <右子树中任意节点的键.\n\n**使用中序遍历可以得到一个有序数组**.\n\nBST使用的每个节点含有2个链接.","slug":"Binary-Tree","published":1,"updated":"2020-10-30T10:23:02.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafl0006mm9h2wdv4ddv","content":"<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>每个节点最多只有两个分支的树结构, 子树分左右.</p>\n<p>每层的节点数&lt;=2^(i-1), 总共的节点数</p>\n<p>假设<strong>根节点的层数为1,</strong> 则一颗<strong>二叉树总共的节点数不超过2^k-1</strong>(等比数列求和公式得来)</p>\n<h4 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h4><h5 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h5><p>定义: 深度为k, 且总节点数为2^k-1的二叉树, 数的外形是严格三角形.</p>\n<p>假设总结点数为n, 则树高为$log_2(n+1)$.</p>\n<h5 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h5><p>定义: 高度为h的二叉树,  其第0到(h-1)层的节点都满, 第h层节点不满, 且最后一层的节点都是从左往右排, 节点都在左边, 空位都在右边. Called 完全二叉树. 与满二叉数的节点一一对应.</p>\n<p>性质: </p>\n<p>一棵完全二叉树的节点数目为 n, 假设根节点的序号为0,  则最后一个节点的序号为n-1. </p>\n<p>对于序号为i的节点, 其父节点序号为 <strong>(i-1)/2</strong> [向下取整 画图可知]. 左子节点为left = 2*i+1(前提是left&lt;=n-1), 右子节点序号为 right = 2*i+2(前提是right&lt;=n-1).</p>\n<h4 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h4><h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>按照系统化方式访问二叉树的每一个节点, 每棵二叉树都有唯一的根节点 root, 是基于树结构的处理入口.</p>\n<p><img src=\"Binary-Tree/二叉树.png\" width=\"50%\" height=\"50%\"></p>\n<blockquote>\n<p>深度优先遍历</p>\n</blockquote>\n<h5 id=\"前-根-序遍历\"><a href=\"#前-根-序遍历\" class=\"headerlink\" title=\"前(根)序遍历\"></a>前(根)序遍历</h5><p>先访问根节点, 再访问左节点和右节点</p>\n<p>ABDHEICFJKG</p>\n<h5 id=\"中-根-序遍历\"><a href=\"#中-根-序遍历\" class=\"headerlink\" title=\"中(根)序遍历\"></a>中(根)序遍历</h5><p>先访问左子树, 再访问根节点, 再访问右子树</p>\n<p>DHBEIAJFKCG</p>\n<h5 id=\"后-根-序遍历\"><a href=\"#后-根-序遍历\" class=\"headerlink\" title=\"后(根)序遍历\"></a>后(根)序遍历</h5><p>先访问左右子树, 再访问根节点.</p>\n<p>HDIEBJKFGCA</p>\n<p>注意: 任意一棵树的任意一种遍历序列都无法唯一确定相应的二叉树.</p>\n<blockquote>\n<p>广度优先遍历</p>\n</blockquote>\n<h5 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h5><p>ABCDEFGHIJK</p>\n<h5 id=\"遍历实现\"><a href=\"#遍历实现\" class=\"headerlink\" title=\"遍历实现\"></a>遍历实现</h5><p>主要使用递归法进行理解与实现.</p>\n<p>深度优先一般使用递归方法/栈结构,  广度优先遍历使用队列.</p>\n<p>中序(知道左右子树的位置)+前序/后序(知道根节点的位置) + 元素不重复 —&gt; 复原二叉树结构</p>\n<h5 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h5><p>统计每个节点被访问的次数</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h4><h3 id=\"二叉查找树-Binary-Search-Tree-BST\"><a href=\"#二叉查找树-Binary-Search-Tree-BST\" class=\"headerlink\" title=\"二叉查找树(Binary Search Tree-BST)\"></a>二叉查找树(Binary Search Tree-BST)</h3><p>每个节点都包含一个可比较的键以及相应的值, 且每个节点的值都&gt;=左子树中任意节点的键, &lt;右子树中任意节点的键.</p>\n<p><strong>使用中序遍历可以得到一个有序数组</strong>.</p>\n<p>BST使用的每个节点含有2个链接.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>每个节点最多只有两个分支的树结构, 子树分左右.</p>\n<p>每层的节点数&lt;=2^(i-1), 总共的节点数</p>\n<p>假设<strong>根节点的层数为1,</strong> 则一颗<strong>二叉树总共的节点数不超过2^k-1</strong>(等比数列求和公式得来)</p>\n<h4 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h4><h5 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h5><p>定义: 深度为k, 且总节点数为2^k-1的二叉树, 数的外形是严格三角形.</p>\n<p>假设总结点数为n, 则树高为$log_2(n+1)$.</p>\n<h5 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h5><p>定义: 高度为h的二叉树,  其第0到(h-1)层的节点都满, 第h层节点不满, 且最后一层的节点都是从左往右排, 节点都在左边, 空位都在右边. Called 完全二叉树. 与满二叉数的节点一一对应.</p>\n<p>性质: </p>\n<p>一棵完全二叉树的节点数目为 n, 假设根节点的序号为0,  则最后一个节点的序号为n-1. </p>\n<p>对于序号为i的节点, 其父节点序号为 <strong>(i-1)/2</strong> [向下取整 画图可知]. 左子节点为left = 2*i+1(前提是left&lt;=n-1), 右子节点序号为 right = 2*i+2(前提是right&lt;=n-1).</p>\n<h4 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h4><h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>按照系统化方式访问二叉树的每一个节点, 每棵二叉树都有唯一的根节点 root, 是基于树结构的处理入口.</p>\n<p><img src=\"Binary-Tree/二叉树.png\" width=\"50%\" height=\"50%\"></p>\n<blockquote>\n<p>深度优先遍历</p>\n</blockquote>\n<h5 id=\"前-根-序遍历\"><a href=\"#前-根-序遍历\" class=\"headerlink\" title=\"前(根)序遍历\"></a>前(根)序遍历</h5><p>先访问根节点, 再访问左节点和右节点</p>\n<p>ABDHEICFJKG</p>\n<h5 id=\"中-根-序遍历\"><a href=\"#中-根-序遍历\" class=\"headerlink\" title=\"中(根)序遍历\"></a>中(根)序遍历</h5><p>先访问左子树, 再访问根节点, 再访问右子树</p>\n<p>DHBEIAJFKCG</p>\n<h5 id=\"后-根-序遍历\"><a href=\"#后-根-序遍历\" class=\"headerlink\" title=\"后(根)序遍历\"></a>后(根)序遍历</h5><p>先访问左右子树, 再访问根节点.</p>\n<p>HDIEBJKFGCA</p>\n<p>注意: 任意一棵树的任意一种遍历序列都无法唯一确定相应的二叉树.</p>\n<blockquote>\n<p>广度优先遍历</p>\n</blockquote>\n<h5 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h5><p>ABCDEFGHIJK</p>\n<h5 id=\"遍历实现\"><a href=\"#遍历实现\" class=\"headerlink\" title=\"遍历实现\"></a>遍历实现</h5><p>主要使用递归法进行理解与实现.</p>\n<p>深度优先一般使用递归方法/栈结构,  广度优先遍历使用队列.</p>\n<p>中序(知道左右子树的位置)+前序/后序(知道根节点的位置) + 元素不重复 —&gt; 复原二叉树结构</p>\n<h5 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h5><p>统计每个节点被访问的次数</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h4><h3 id=\"二叉查找树-Binary-Search-Tree-BST\"><a href=\"#二叉查找树-Binary-Search-Tree-BST\" class=\"headerlink\" title=\"二叉查找树(Binary Search Tree-BST)\"></a>二叉查找树(Binary Search Tree-BST)</h3><p>每个节点都包含一个可比较的键以及相应的值, 且每个节点的值都&gt;=左子树中任意节点的键, &lt;右子树中任意节点的键.</p>\n<p><strong>使用中序遍历可以得到一个有序数组</strong>.</p>\n<p>BST使用的每个节点含有2个链接.</p>\n"},{"title":"Binary Search","abbrlink":"fbb0c1cd","date":"2020-08-03T02:21:55.000Z","description":"二分查找相关题解","_content":"\n\n\n### 二分查找/折半查找\n\n#### 前提\n\n数列有序; \n\n数列使用顺序存储结构\n\n#### 过程\n\n将目标元素与有序数列的中间元素比较大小, 比中间元素大, 则在数列的右半部分查找, 比中间元素小, 则在数列的左半部分查找, 如果相等, 则找到.\n\n不会查找所有的元素, 查找的数据量正好符合元素的对数, 正常情况每次查找的元素都在对半减少.所以时间复杂度为 $O(log_2N)$.\n\n<img src=\"Binary-Search/binary-search.png\" height=\"70%\" width=\"70%\">\n\n#### 优化\n\n根据要找的key的大小, 从更接近的位置进行查找.eg.1-100000找10, 肯定采取顺序查找而不是折半查找.\n\ncalled 插值查找. 适用于数列比较大&均匀的数列.\n\n#### 使用场景\n\n有序; 元素个数较多; 不进行频繁增删\n\n#### 代码实现\n\n##### 普通的二分查找\n\n```javascript\n// 标准的二分查找模板\nvar binary_search = (nums, target) => {\n  let len = nums.length;\n  if(len == 0) return -1;\n  let left = 0, right = len - 1; // 注意! [0, nums.length-1] 闭区间\n  let mid = 0;\n  // 停止条件: 找不到/数组为空\n  // 找不到时是区间为空 当 left=right+1 时区间为空\n  // 注意!\n  while (left <= right) {\n    // 防止使用 (left+right)/2 计算 mid 时溢出 \n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) {\n      return mid;\n    } else if (nums[mid] > target) { // 对于已经比较过的mid 不应该在下一次进行搜索的区间内\n      right = mid - 1; // 注意!\n    } else if (nums[mid] < target) {\n      left = mid + 1; // 注意!\n    }\n  }\n  return -1;\n}\n```\n\n\n\n##### 寻找左侧边界的二分查找(模板)\n\n```javascript\nvar search_left = (nums, target) => {\n  let len = nums.length;\n  if (len == 0) return -1;\n  let left = 0, right = len - 1, mid = 0;\n  // 循环停止条件是 left = right + 1\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) { // 关键 !!! 向左缩小区域\n      right = mid - 1; // 探索区间为 [left, mid-1]\n    } else if (nums[mid] > target) {\n      right = mid - 1; // 探索区间为 [left, mid-1]\n    } else if (nums[mid] < target) {\n      left = mid + 1; // 探索区间为 [mid+1, right]\n    }\n    // console.log('left:', left, 'mid:', mid, 'right:', right);\n  }\n  // 处理数组越界情况\n  // target>所有值(left==nums.length) || target<所有值(right==-1)\n  // nums[left] != target ps.即使right == -1 left==0 nums[0]也有可能是target\n  if (left == len || nums[left] != target) {\n    return -1;\n  }\n  return left;\n}\n```\n\n\n\n##### 寻找右侧边界的二分查找(模板)\n\n```javascript\nvar search_right = (nums, target) => {\n  let len = nums.length;\n  if (len == 0) return -1;\n  let left = 0, right = len - 1, mid = 0;\n  // 循环停止条件是 left = right + 1\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) { // 关键!!! 向右缩小区域\n      left = mid + 1; // 探索区间为 [mid+1, right]\n    } else if (nums[mid] > target) {\n      right = mid - 1; // 探索区间为 [left, mid-1]\n    } else if (nums[mid] < target) {\n      left = mid + 1; // 探索区间为 [mid+1, right]\n    }\n    // console.log('left:', left, 'mid:', mid, 'right:', right);\n  }\n  // 处理数组越界情况\n  // target>所有值(left==nums.length) || target<所有值(right==-1)\n  // 即使left==len 但是 right==len-1 nums[right]也有可能是target\n  if (nums[right] != target || right == -1) {\n    return -1;\n  }\n  return right;\n}\n```\n\n\n\n#### [33] Search in Rotated Sorted Array\n\n> You are given an integer array `nums` sorted in ascending order, and an integer `target`.\n>\n> Suppose that `nums` is rotated at some pivot unknown to you beforehand (i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).\n>\n> *If `target` is found in the array return its index, otherwise, return `-1`.*\n\n1. 确定有序部分 判断target在哪个部分\n2. 边界 当数组两端或者中间找不到target时的情况处理\n\n```javascript\n// 比较中间元素与最后一个元素的大小 确定有序区间\n// 再将目标值与该区间的首尾元素比较 确定是否在该区域内\n// 给定的nums中无重复元素\nvar search = function (nums, target) {\n  let len = nums.length;\n  if (len == 0) return -1; // 处理特殊情况\n  let left = 0, right = len - 1, mid = 0;\n  /** 需要注意的是 有序区间的另外半边 \n   * 根据其中间元素与末尾元素(right)对比\n   * 仍然可以划分出有序区间 \n   * */\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) return mid;\n    // 处理在数组中间left==right但是nums[mid]!=target的情况\n    // 此时也没有找到目标元素\n    if (left == right && nums[mid] != target) return -1;\n    // 先判断哪边是有序序列 再看目标元素是否在有序区间内\n    // 由于没有重复元素 则不会出现 nums[mid] = nums[right] 的情况\n    // 一定会存在升序序列\n    if (nums[mid] < nums[right]) { // 右边有序\n      // 看目标元素是否在右侧有序区间内\n      if (target > nums[mid] && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    } else if (nums[mid] > nums[right]) { // 左边有序\n      // 看目标元素是否在左侧有序区间内\n      if (target >= nums[left] && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n  }\n  // 处理target<min(nums)或者target>max(nums) 两种情况\n  return -1;\n};\n\n```\n\n\n\n#### [35] Search Insert Position\n\n> Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n>\n> You may assume no duplicates in the array.\n\n\n\n###### My solution\n\n我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了.....\n\n```javascript\nvar searchInsert = function (nums, target) {\n  let start = 0,\n    end = nums.length - 1;\n  let mid = start + index(end - start);\n  // 数组len=1\n  if (start == end) {\n    if (target > nums[end])\n      return 1\n    else if (target < nums[start])\n      return 0\n    else\n      return start\n  } else if (end - start == 1) { // 数组len=2\n    if (target > nums[end])\n      return end + 1\n    else if (target < nums[start])\n      return 0\n    else if (target == nums[start])\n      return start\n    else\n      return end\n  } else { // 数组len>2\n    while (end - start > 1) {\n      if (target < nums[mid]) {\n        console.log('target:' + target + '<' + \"nums[\" + mid + \"]:\" + nums[mid]);\n        end = mid;\n        if (end - start == 1) {\n          if (target == nums[start]) {\n            return start\n          } else if (target < nums[start]) {\n            return 0\n          } else {\n            return start + 1\n          }\n        } else {\n          mid = start + index(end - start);\n        }\n      } else if (target > nums[mid]) {\n        console.log('target:' + target + '>' + \"nums[\" + mid + \"]:\" + nums[mid]);\n        start = mid;\n        if (end - start == 1) {\n          if (target == nums[end]) {\n            return end\n          } else if (target > nums[end]) {\n            return end + 1\n          } else {\n            return start + 1\n          }\n        } else {\n          mid = start + index(end - start);\n        }\n      } else {\n        // console.log(mid);\n        return mid;\n      }\n    }\n  }\n};\n\nvar index = (gap) => {\n  if (gap % 2 == 0)\n    return gap / 2;\n  else\n    return (gap + 1) / 2\n}\n```\n\n\n\n###### solution on the Internet\n\n参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值\n\n```javascript\nvar searchInsert = function (nums, target) {\n\n  if (nums.length == 0)\n    return 0\n  let start = 0, end = nums.length - 1, mid = 0;\n  if (target > nums[end])\n    return end + 1;\n  // if (target < nums[start])\n  //   return 0;\n  // if (target == nums[start])\n  //   return start\n\n  while (end > start) {\n    mid = start + parseInt((end - start) / 2); // parseInt 直接丢弃小数部分, 保留整数部分\n    console.log('mid: ', mid, ' start: ', start, ' end: ', end);\n    if (target == nums[start])\n      return start;\n    if (target == nums[end])\n      return end;\n    if (target == nums[mid])\n      return mid;\n\n    if (target > nums[mid]) {\n      start = mid + 1;\n      // console.log('target > mid', 'start: ', start);\n    } else {\n      end = mid;\n      // console.log('target < mid', 'end: ', end);\n    }\n  }\n\n  return start\n}\n```\n\n\n\n#### [81] Search in Rotated Sorted Array II\n\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n>\n> (i.e., `[0,0,1,2,2,5,6]` might become `[2,5,6,0,0,1,2]`).\n>\n> You are given a target value to search. If found in the array return `true`, otherwise return `false`.\n>\n> **Follow up:**\n>\n> - This is a follow up problem to [Search in Rotated Sorted Array](vscode-webview://5ad24d3b-f3dc-4f27-82d5-8e23615b83c1/problems/search-in-rotated-sorted-array/description/), where `nums` may contain duplicates.\n> - Would this affect the run-time complexity? How and why?\n\n有重复元素的有序数组分为了两个部分, 颠倒之后的数组的第一个元素一定>=第二部分的任意元素.\n\n将需要搜索的部分分为三个部分, 前半个数组[left, mid)/中间元素mid/后半个数组(mid, right]\n\nmid和target可能分别在左右部分, 对这两者的位置组合进行分情况讨论. 如果target在左min(left)和max(right)之间, 则直接返回false.\n\n```javascript\n// 原来没有重复元素时 判断有序数组比较好判断 直接比较大小\n// 现在有重复元素 无法通过比较中间元素与最右元素的大小来确定哪一边数组是有序的\n// 也就无法知道target应该在mid的哪一边\n// eg. 1,1,2,3,1,1,1,1,1,1,1,1\n// 普遍意义的二分查找不能使用了 但是不能使用遍历的方法(O(N))\n// 为了O(logN)的时间复杂度必须想其他方法\nvar search = function (nums, target) {\n  // 先写一个标准的二分查找\n  let len = nums.length;\n  if (len == 0) return false;\n  let left = 0, right = len - 1, mid = 0;\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    // 找到目标元素\n    if (target == nums[mid]) return true;\n    // 看mid在哪个部分\n    // mid in left part\n    if (nums[mid] > nums[left]) {\n      if (target > nums[mid]) { // target in left and > mid\n        left = mid + 1;\n      } else if (target < nums[mid] && target >= nums[left]) { // target in left and < mid\n        right = mid - 1;\n      } else if (target <= nums[right]) { // target in right\n        left = mid + 1;\n      } else {\n        // target 左右部分均不在\n        // 考虑测试案例 [1,3,1,1,1] 2\n        return false;\n      }\n      // mid in right part\n    } else if (nums[mid] < nums[left]) {\n      if (target < nums[mid]) { // target in right and < mid\n        right = mid - 1;\n      } else if (target > nums[mid] && target <= nums[right]) { // target in right and > mid\n        left = mid + 1;\n      } else if (target >= nums[left]) { // target in left\n        right = mid - 1;\n      } else {\n        // target 左右部分均不在\n        return false;\n      }\n    } else if (nums[mid] == nums[left]) { // mid in left or right\n      // 此时不能根据nums[mid]与target的大小比较确定接下来的收缩范围\n      // 不确定是 left=mid+1 or right=mid-1\n      left = left + 1; // or right=right-1; 逐步缩小搜索范围\n    }\n  }\n  return false;\n};\n```\n\n\n\n#### [153] Find Minimum in Rotated Sorted Array\n\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n>\n> (i.e.,  `[0,1,2,4,5,6,7]` might become  `[4,5,6,7,0,1,2]`).\n>\n> Find the minimum element.\n>\n> You may assume no duplicate exists in the array.\n\n总体思路: 使用二分查找, 不断寻找有序部分的最小值, 返回最小值中的最小值.\n\n时间复杂度: logN\n\n```javascript\n// 首先确定有序的部分 保留其最小值x\n// 然后再使用二分查找查找剩下无序部分中的升序部分的最小值 与x比较保留较小值\nvar findMin = function (nums) {\n  let len = nums.length;\n  let left = 0, right = len - 1, mid = 0, min = nums[0];\n  while (left <= right) {\n    // 此时判断一下最小值\n    // eg [3,4,5,0,1,2]\n    // 最后left==right==3(index)而此时 nums[3]==0 是最小值\n    if (left == right) {\n      min = Math.min(nums[left], min);\n      break;\n    }\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] < nums[right]) { // right is ordered\n      min = Math.min(nums[mid], min); // 获取有序列表的最小值\n      right = mid - 1;\n    } else if (nums[mid] > nums[right]) { // left is ordered\n      min = Math.min(nums[left], min); // 获取有序列表的最小值\n      left = mid + 1;\n    }\n  }\n  return min;\n};\n```\n\n","source":"_posts/Binary-Search.md","raw":"---\ntitle: Binary Search\ntags:\n  - LeetCode\ncategories: Algorithm\nabbrlink: fbb0c1cd\ndate: 2020-08-03 10:21:55\ndescription: 二分查找相关题解\n---\n\n\n\n### 二分查找/折半查找\n\n#### 前提\n\n数列有序; \n\n数列使用顺序存储结构\n\n#### 过程\n\n将目标元素与有序数列的中间元素比较大小, 比中间元素大, 则在数列的右半部分查找, 比中间元素小, 则在数列的左半部分查找, 如果相等, 则找到.\n\n不会查找所有的元素, 查找的数据量正好符合元素的对数, 正常情况每次查找的元素都在对半减少.所以时间复杂度为 $O(log_2N)$.\n\n<img src=\"Binary-Search/binary-search.png\" height=\"70%\" width=\"70%\">\n\n#### 优化\n\n根据要找的key的大小, 从更接近的位置进行查找.eg.1-100000找10, 肯定采取顺序查找而不是折半查找.\n\ncalled 插值查找. 适用于数列比较大&均匀的数列.\n\n#### 使用场景\n\n有序; 元素个数较多; 不进行频繁增删\n\n#### 代码实现\n\n##### 普通的二分查找\n\n```javascript\n// 标准的二分查找模板\nvar binary_search = (nums, target) => {\n  let len = nums.length;\n  if(len == 0) return -1;\n  let left = 0, right = len - 1; // 注意! [0, nums.length-1] 闭区间\n  let mid = 0;\n  // 停止条件: 找不到/数组为空\n  // 找不到时是区间为空 当 left=right+1 时区间为空\n  // 注意!\n  while (left <= right) {\n    // 防止使用 (left+right)/2 计算 mid 时溢出 \n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) {\n      return mid;\n    } else if (nums[mid] > target) { // 对于已经比较过的mid 不应该在下一次进行搜索的区间内\n      right = mid - 1; // 注意!\n    } else if (nums[mid] < target) {\n      left = mid + 1; // 注意!\n    }\n  }\n  return -1;\n}\n```\n\n\n\n##### 寻找左侧边界的二分查找(模板)\n\n```javascript\nvar search_left = (nums, target) => {\n  let len = nums.length;\n  if (len == 0) return -1;\n  let left = 0, right = len - 1, mid = 0;\n  // 循环停止条件是 left = right + 1\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) { // 关键 !!! 向左缩小区域\n      right = mid - 1; // 探索区间为 [left, mid-1]\n    } else if (nums[mid] > target) {\n      right = mid - 1; // 探索区间为 [left, mid-1]\n    } else if (nums[mid] < target) {\n      left = mid + 1; // 探索区间为 [mid+1, right]\n    }\n    // console.log('left:', left, 'mid:', mid, 'right:', right);\n  }\n  // 处理数组越界情况\n  // target>所有值(left==nums.length) || target<所有值(right==-1)\n  // nums[left] != target ps.即使right == -1 left==0 nums[0]也有可能是target\n  if (left == len || nums[left] != target) {\n    return -1;\n  }\n  return left;\n}\n```\n\n\n\n##### 寻找右侧边界的二分查找(模板)\n\n```javascript\nvar search_right = (nums, target) => {\n  let len = nums.length;\n  if (len == 0) return -1;\n  let left = 0, right = len - 1, mid = 0;\n  // 循环停止条件是 left = right + 1\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) { // 关键!!! 向右缩小区域\n      left = mid + 1; // 探索区间为 [mid+1, right]\n    } else if (nums[mid] > target) {\n      right = mid - 1; // 探索区间为 [left, mid-1]\n    } else if (nums[mid] < target) {\n      left = mid + 1; // 探索区间为 [mid+1, right]\n    }\n    // console.log('left:', left, 'mid:', mid, 'right:', right);\n  }\n  // 处理数组越界情况\n  // target>所有值(left==nums.length) || target<所有值(right==-1)\n  // 即使left==len 但是 right==len-1 nums[right]也有可能是target\n  if (nums[right] != target || right == -1) {\n    return -1;\n  }\n  return right;\n}\n```\n\n\n\n#### [33] Search in Rotated Sorted Array\n\n> You are given an integer array `nums` sorted in ascending order, and an integer `target`.\n>\n> Suppose that `nums` is rotated at some pivot unknown to you beforehand (i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).\n>\n> *If `target` is found in the array return its index, otherwise, return `-1`.*\n\n1. 确定有序部分 判断target在哪个部分\n2. 边界 当数组两端或者中间找不到target时的情况处理\n\n```javascript\n// 比较中间元素与最后一个元素的大小 确定有序区间\n// 再将目标值与该区间的首尾元素比较 确定是否在该区域内\n// 给定的nums中无重复元素\nvar search = function (nums, target) {\n  let len = nums.length;\n  if (len == 0) return -1; // 处理特殊情况\n  let left = 0, right = len - 1, mid = 0;\n  /** 需要注意的是 有序区间的另外半边 \n   * 根据其中间元素与末尾元素(right)对比\n   * 仍然可以划分出有序区间 \n   * */\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] == target) return mid;\n    // 处理在数组中间left==right但是nums[mid]!=target的情况\n    // 此时也没有找到目标元素\n    if (left == right && nums[mid] != target) return -1;\n    // 先判断哪边是有序序列 再看目标元素是否在有序区间内\n    // 由于没有重复元素 则不会出现 nums[mid] = nums[right] 的情况\n    // 一定会存在升序序列\n    if (nums[mid] < nums[right]) { // 右边有序\n      // 看目标元素是否在右侧有序区间内\n      if (target > nums[mid] && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    } else if (nums[mid] > nums[right]) { // 左边有序\n      // 看目标元素是否在左侧有序区间内\n      if (target >= nums[left] && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n  }\n  // 处理target<min(nums)或者target>max(nums) 两种情况\n  return -1;\n};\n\n```\n\n\n\n#### [35] Search Insert Position\n\n> Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n>\n> You may assume no duplicates in the array.\n\n\n\n###### My solution\n\n我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了.....\n\n```javascript\nvar searchInsert = function (nums, target) {\n  let start = 0,\n    end = nums.length - 1;\n  let mid = start + index(end - start);\n  // 数组len=1\n  if (start == end) {\n    if (target > nums[end])\n      return 1\n    else if (target < nums[start])\n      return 0\n    else\n      return start\n  } else if (end - start == 1) { // 数组len=2\n    if (target > nums[end])\n      return end + 1\n    else if (target < nums[start])\n      return 0\n    else if (target == nums[start])\n      return start\n    else\n      return end\n  } else { // 数组len>2\n    while (end - start > 1) {\n      if (target < nums[mid]) {\n        console.log('target:' + target + '<' + \"nums[\" + mid + \"]:\" + nums[mid]);\n        end = mid;\n        if (end - start == 1) {\n          if (target == nums[start]) {\n            return start\n          } else if (target < nums[start]) {\n            return 0\n          } else {\n            return start + 1\n          }\n        } else {\n          mid = start + index(end - start);\n        }\n      } else if (target > nums[mid]) {\n        console.log('target:' + target + '>' + \"nums[\" + mid + \"]:\" + nums[mid]);\n        start = mid;\n        if (end - start == 1) {\n          if (target == nums[end]) {\n            return end\n          } else if (target > nums[end]) {\n            return end + 1\n          } else {\n            return start + 1\n          }\n        } else {\n          mid = start + index(end - start);\n        }\n      } else {\n        // console.log(mid);\n        return mid;\n      }\n    }\n  }\n};\n\nvar index = (gap) => {\n  if (gap % 2 == 0)\n    return gap / 2;\n  else\n    return (gap + 1) / 2\n}\n```\n\n\n\n###### solution on the Internet\n\n参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值\n\n```javascript\nvar searchInsert = function (nums, target) {\n\n  if (nums.length == 0)\n    return 0\n  let start = 0, end = nums.length - 1, mid = 0;\n  if (target > nums[end])\n    return end + 1;\n  // if (target < nums[start])\n  //   return 0;\n  // if (target == nums[start])\n  //   return start\n\n  while (end > start) {\n    mid = start + parseInt((end - start) / 2); // parseInt 直接丢弃小数部分, 保留整数部分\n    console.log('mid: ', mid, ' start: ', start, ' end: ', end);\n    if (target == nums[start])\n      return start;\n    if (target == nums[end])\n      return end;\n    if (target == nums[mid])\n      return mid;\n\n    if (target > nums[mid]) {\n      start = mid + 1;\n      // console.log('target > mid', 'start: ', start);\n    } else {\n      end = mid;\n      // console.log('target < mid', 'end: ', end);\n    }\n  }\n\n  return start\n}\n```\n\n\n\n#### [81] Search in Rotated Sorted Array II\n\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n>\n> (i.e., `[0,0,1,2,2,5,6]` might become `[2,5,6,0,0,1,2]`).\n>\n> You are given a target value to search. If found in the array return `true`, otherwise return `false`.\n>\n> **Follow up:**\n>\n> - This is a follow up problem to [Search in Rotated Sorted Array](vscode-webview://5ad24d3b-f3dc-4f27-82d5-8e23615b83c1/problems/search-in-rotated-sorted-array/description/), where `nums` may contain duplicates.\n> - Would this affect the run-time complexity? How and why?\n\n有重复元素的有序数组分为了两个部分, 颠倒之后的数组的第一个元素一定>=第二部分的任意元素.\n\n将需要搜索的部分分为三个部分, 前半个数组[left, mid)/中间元素mid/后半个数组(mid, right]\n\nmid和target可能分别在左右部分, 对这两者的位置组合进行分情况讨论. 如果target在左min(left)和max(right)之间, 则直接返回false.\n\n```javascript\n// 原来没有重复元素时 判断有序数组比较好判断 直接比较大小\n// 现在有重复元素 无法通过比较中间元素与最右元素的大小来确定哪一边数组是有序的\n// 也就无法知道target应该在mid的哪一边\n// eg. 1,1,2,3,1,1,1,1,1,1,1,1\n// 普遍意义的二分查找不能使用了 但是不能使用遍历的方法(O(N))\n// 为了O(logN)的时间复杂度必须想其他方法\nvar search = function (nums, target) {\n  // 先写一个标准的二分查找\n  let len = nums.length;\n  if (len == 0) return false;\n  let left = 0, right = len - 1, mid = 0;\n  while (left <= right) {\n    mid = left + Math.floor((right - left) / 2);\n    // 找到目标元素\n    if (target == nums[mid]) return true;\n    // 看mid在哪个部分\n    // mid in left part\n    if (nums[mid] > nums[left]) {\n      if (target > nums[mid]) { // target in left and > mid\n        left = mid + 1;\n      } else if (target < nums[mid] && target >= nums[left]) { // target in left and < mid\n        right = mid - 1;\n      } else if (target <= nums[right]) { // target in right\n        left = mid + 1;\n      } else {\n        // target 左右部分均不在\n        // 考虑测试案例 [1,3,1,1,1] 2\n        return false;\n      }\n      // mid in right part\n    } else if (nums[mid] < nums[left]) {\n      if (target < nums[mid]) { // target in right and < mid\n        right = mid - 1;\n      } else if (target > nums[mid] && target <= nums[right]) { // target in right and > mid\n        left = mid + 1;\n      } else if (target >= nums[left]) { // target in left\n        right = mid - 1;\n      } else {\n        // target 左右部分均不在\n        return false;\n      }\n    } else if (nums[mid] == nums[left]) { // mid in left or right\n      // 此时不能根据nums[mid]与target的大小比较确定接下来的收缩范围\n      // 不确定是 left=mid+1 or right=mid-1\n      left = left + 1; // or right=right-1; 逐步缩小搜索范围\n    }\n  }\n  return false;\n};\n```\n\n\n\n#### [153] Find Minimum in Rotated Sorted Array\n\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n>\n> (i.e.,  `[0,1,2,4,5,6,7]` might become  `[4,5,6,7,0,1,2]`).\n>\n> Find the minimum element.\n>\n> You may assume no duplicate exists in the array.\n\n总体思路: 使用二分查找, 不断寻找有序部分的最小值, 返回最小值中的最小值.\n\n时间复杂度: logN\n\n```javascript\n// 首先确定有序的部分 保留其最小值x\n// 然后再使用二分查找查找剩下无序部分中的升序部分的最小值 与x比较保留较小值\nvar findMin = function (nums) {\n  let len = nums.length;\n  let left = 0, right = len - 1, mid = 0, min = nums[0];\n  while (left <= right) {\n    // 此时判断一下最小值\n    // eg [3,4,5,0,1,2]\n    // 最后left==right==3(index)而此时 nums[3]==0 是最小值\n    if (left == right) {\n      min = Math.min(nums[left], min);\n      break;\n    }\n    mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] < nums[right]) { // right is ordered\n      min = Math.min(nums[mid], min); // 获取有序列表的最小值\n      right = mid - 1;\n    } else if (nums[mid] > nums[right]) { // left is ordered\n      min = Math.min(nums[left], min); // 获取有序列表的最小值\n      left = mid + 1;\n    }\n  }\n  return min;\n};\n```\n\n","slug":"Binary-Search","published":1,"updated":"2020-10-29T10:56:30.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafo0009mm9hhv9fcqxb","content":"<h3 id=\"二分查找-折半查找\"><a href=\"#二分查找-折半查找\" class=\"headerlink\" title=\"二分查找/折半查找\"></a>二分查找/折半查找</h3><h4 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h4><p>数列有序; </p>\n<p>数列使用顺序存储结构</p>\n<h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><p>将目标元素与有序数列的中间元素比较大小, 比中间元素大, 则在数列的右半部分查找, 比中间元素小, 则在数列的左半部分查找, 如果相等, 则找到.</p>\n<p>不会查找所有的元素, 查找的数据量正好符合元素的对数, 正常情况每次查找的元素都在对半减少.所以时间复杂度为 $O(log_2N)$.</p>\n<p><img src=\"Binary-Search/binary-search.png\" height=\"70%\" width=\"70%\"></p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>根据要找的key的大小, 从更接近的位置进行查找.eg.1-100000找10, 肯定采取顺序查找而不是折半查找.</p>\n<p>called 插值查找. 适用于数列比较大&amp;均匀的数列.</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><p>有序; 元素个数较多; 不进行频繁增删</p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><h5 id=\"普通的二分查找\"><a href=\"#普通的二分查找\" class=\"headerlink\" title=\"普通的二分查找\"></a>普通的二分查找</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 标准的二分查找模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> binary_search = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>; <span class=\"comment\">// 注意! [0, nums.length-1] 闭区间</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 停止条件: 找不到/数组为空</span></span><br><span class=\"line\">  <span class=\"comment\">// 找不到时是区间为空 当 left=right+1 时区间为空</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意!</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 防止使用 (left+right)/2 计算 mid 时溢出 </span></span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123; <span class=\"comment\">// 对于已经比较过的mid 不应该在下一次进行搜索的区间内</span></span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 注意!</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 注意!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"寻找左侧边界的二分查找-模板\"><a href=\"#寻找左侧边界的二分查找-模板\" class=\"headerlink\" title=\"寻找左侧边界的二分查找(模板)\"></a>寻找左侧边界的二分查找(模板)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> search_left = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 循环停止条件是 left = right + 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) &#123; <span class=\"comment\">// 关键 !!! 向左缩小区域</span></span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [left, mid-1]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [left, mid-1]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [mid+1, right]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// console.log('left:', left, 'mid:', mid, 'right:', right);</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数组越界情况</span></span><br><span class=\"line\">  <span class=\"comment\">// target&gt;所有值(left==nums.length) || target&lt;所有值(right==-1)</span></span><br><span class=\"line\">  <span class=\"comment\">// nums[left] != target ps.即使right == -1 left==0 nums[0]也有可能是target</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left == len || nums[left] != target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"寻找右侧边界的二分查找-模板\"><a href=\"#寻找右侧边界的二分查找-模板\" class=\"headerlink\" title=\"寻找右侧边界的二分查找(模板)\"></a>寻找右侧边界的二分查找(模板)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> search_right = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 循环停止条件是 left = right + 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) &#123; <span class=\"comment\">// 关键!!! 向右缩小区域</span></span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [mid+1, right]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [left, mid-1]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [mid+1, right]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// console.log('left:', left, 'mid:', mid, 'right:', right);</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数组越界情况</span></span><br><span class=\"line\">  <span class=\"comment\">// target&gt;所有值(left==nums.length) || target&lt;所有值(right==-1)</span></span><br><span class=\"line\">  <span class=\"comment\">// 即使left==len 但是 right==len-1 nums[right]也有可能是target</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[right] != target || right == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"33-Search-in-Rotated-Sorted-Array\"><a href=\"#33-Search-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"[33] Search in Rotated Sorted Array\"></a>[33] Search in Rotated Sorted Array</h4><blockquote>\n<p>You are given an integer array <code>nums</code> sorted in ascending order, and an integer <code>target</code>.</p>\n<p>Suppose that <code>nums</code> is rotated at some pivot unknown to you beforehand (i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>\n<p><em>If <code>target</code> is found in the array return its index, otherwise, return <code>-1</code>.</em></p>\n</blockquote>\n<ol>\n<li>确定有序部分 判断target在哪个部分</li>\n<li>边界 当数组两端或者中间找不到target时的情况处理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较中间元素与最后一个元素的大小 确定有序区间</span></span><br><span class=\"line\"><span class=\"comment\">// 再将目标值与该区间的首尾元素比较 确定是否在该区域内</span></span><br><span class=\"line\"><span class=\"comment\">// 给定的nums中无重复元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> search = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// 处理特殊情况</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">/** 需要注意的是 有序区间的另外半边 </span></span><br><span class=\"line\"><span class=\"comment\">   * 根据其中间元素与末尾元素(right)对比</span></span><br><span class=\"line\"><span class=\"comment\">   * 仍然可以划分出有序区间 </span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"comment\">// 处理在数组中间left==right但是nums[mid]!=target的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时也没有找到目标元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left == right &amp;&amp; nums[mid] != target) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 先判断哪边是有序序列 再看目标元素是否在有序区间内</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于没有重复元素 则不会出现 nums[mid] = nums[right] 的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 一定会存在升序序列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &lt; nums[right]) &#123; <span class=\"comment\">// 右边有序</span></span><br><span class=\"line\">      <span class=\"comment\">// 看目标元素是否在右侧有序区间内</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[right]) &#123; <span class=\"comment\">// 左边有序</span></span><br><span class=\"line\">      <span class=\"comment\">// 看目标元素是否在左侧有序区间内</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理target&lt;min(nums)或者target&gt;max(nums) 两种情况</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"35-Search-Insert-Position\"><a href=\"#35-Search-Insert-Position\" class=\"headerlink\" title=\"[35] Search Insert Position\"></a>[35] Search Insert Position</h4><blockquote>\n<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n<p>You may assume no duplicates in the array.</p>\n</blockquote>\n<h6 id=\"My-solution\"><a href=\"#My-solution\" class=\"headerlink\" title=\"My solution\"></a>My solution</h6><p>我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了…..</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchInsert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"number\">0</span>,</span><br><span class=\"line\">    end = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = start + index(end - start);</span><br><span class=\"line\">  <span class=\"comment\">// 数组len=1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[end])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> start</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (end - start == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 数组len=2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[end])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> end + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> start</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> end</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 数组len&gt;2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (end - start &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &lt; nums[mid]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target:'</span> + target + <span class=\"string\">'&lt;'</span> + <span class=\"string\">\"nums[\"</span> + mid + <span class=\"string\">\"]:\"</span> + nums[mid]);</span><br><span class=\"line\">        end = mid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (end - start == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (target == nums[start]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> start</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[start]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> start + <span class=\"number\">1</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          mid = start + index(end - start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt; nums[mid]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target:'</span> + target + <span class=\"string\">'&gt;'</span> + <span class=\"string\">\"nums[\"</span> + mid + <span class=\"string\">\"]:\"</span> + nums[mid]);</span><br><span class=\"line\">        start = mid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (end - start == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (target == nums[end]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> end</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt; nums[end]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> end + <span class=\"number\">1</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> start + <span class=\"number\">1</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          mid = start + index(end - start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// console.log(mid);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"function\">(<span class=\"params\">gap</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (gap % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gap / <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (gap + <span class=\"number\">1</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"solution-on-the-Internet\"><a href=\"#solution-on-the-Internet\" class=\"headerlink\" title=\"solution on the Internet\"></a>solution on the Internet</h6><p>参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchInsert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"number\">0</span>, end = nums.length - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target &gt; nums[end])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// if (target &lt; nums[start])</span></span><br><span class=\"line\">  <span class=\"comment\">//   return 0;</span></span><br><span class=\"line\">  <span class=\"comment\">// if (target == nums[start])</span></span><br><span class=\"line\">  <span class=\"comment\">//   return start</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (end &gt; start) &#123;</span><br><span class=\"line\">    mid = start + <span class=\"built_in\">parseInt</span>((end - start) / <span class=\"number\">2</span>); <span class=\"comment\">// parseInt 直接丢弃小数部分, 保留整数部分</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'mid: '</span>, mid, <span class=\"string\">' start: '</span>, start, <span class=\"string\">' end: '</span>, end);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[end])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[mid])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[mid]) &#123;</span><br><span class=\"line\">      start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"comment\">// console.log('target &gt; mid', 'start: ', start);</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      end = mid;</span><br><span class=\"line\">      <span class=\"comment\">// console.log('target &lt; mid', 'end: ', end);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> start</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"81-Search-in-Rotated-Sorted-Array-II\"><a href=\"#81-Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"[81] Search in Rotated Sorted Array II\"></a>[81] Search in Rotated Sorted Array II</h4><blockquote>\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>\n<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>This is a follow up problem to <a href=\"vscode-webview://5ad24d3b-f3dc-4f27-82d5-8e23615b83c1/problems/search-in-rotated-sorted-array/description/\">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>\n<li>Would this affect the run-time complexity? How and why?</li>\n</ul>\n</blockquote>\n<p>有重复元素的有序数组分为了两个部分, 颠倒之后的数组的第一个元素一定&gt;=第二部分的任意元素.</p>\n<p>将需要搜索的部分分为三个部分, 前半个数组[left, mid)/中间元素mid/后半个数组(mid, right]</p>\n<p>mid和target可能分别在左右部分, 对这两者的位置组合进行分情况讨论. 如果target在左min(left)和max(right)之间, 则直接返回false.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原来没有重复元素时 判断有序数组比较好判断 直接比较大小</span></span><br><span class=\"line\"><span class=\"comment\">// 现在有重复元素 无法通过比较中间元素与最右元素的大小来确定哪一边数组是有序的</span></span><br><span class=\"line\"><span class=\"comment\">// 也就无法知道target应该在mid的哪一边</span></span><br><span class=\"line\"><span class=\"comment\">// eg. 1,1,2,3,1,1,1,1,1,1,1,1</span></span><br><span class=\"line\"><span class=\"comment\">// 普遍意义的二分查找不能使用了 但是不能使用遍历的方法(O(N))</span></span><br><span class=\"line\"><span class=\"comment\">// 为了O(logN)的时间复杂度必须想其他方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> search = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先写一个标准的二分查找</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 找到目标元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[mid]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 看mid在哪个部分</span></span><br><span class=\"line\">    <span class=\"comment\">// mid in left part</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt; nums[left]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &gt; nums[mid]) &#123; <span class=\"comment\">// target in left and &gt; mid</span></span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[left]) &#123; <span class=\"comment\">// target in left and &lt; mid</span></span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt;= nums[right]) &#123; <span class=\"comment\">// target in right</span></span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// target 左右部分均不在</span></span><br><span class=\"line\">        <span class=\"comment\">// 考虑测试案例 [1,3,1,1,1] 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// mid in right part</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[left]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &lt; nums[mid]) &#123; <span class=\"comment\">// target in right and &lt; mid</span></span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; <span class=\"comment\">// target in right and &gt; mid</span></span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt;= nums[left]) &#123; <span class=\"comment\">// target in left</span></span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// target 左右部分均不在</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] == nums[left]) &#123; <span class=\"comment\">// mid in left or right</span></span><br><span class=\"line\">      <span class=\"comment\">// 此时不能根据nums[mid]与target的大小比较确定接下来的收缩范围</span></span><br><span class=\"line\">      <span class=\"comment\">// 不确定是 left=mid+1 or right=mid-1</span></span><br><span class=\"line\">      left = left + <span class=\"number\">1</span>; <span class=\"comment\">// or right=right-1; 逐步缩小搜索范围</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"153-Find-Minimum-in-Rotated-Sorted-Array\"><a href=\"#153-Find-Minimum-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"[153] Find Minimum in Rotated Sorted Array\"></a>[153] Find Minimum in Rotated Sorted Array</h4><blockquote>\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>\n<p>Find the minimum element.</p>\n<p>You may assume no duplicate exists in the array.</p>\n</blockquote>\n<p>总体思路: 使用二分查找, 不断寻找有序部分的最小值, 返回最小值中的最小值.</p>\n<p>时间复杂度: logN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先确定有序的部分 保留其最小值x</span></span><br><span class=\"line\"><span class=\"comment\">// 然后再使用二分查找查找剩下无序部分中的升序部分的最小值 与x比较保留较小值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findMin = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>, min = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此时判断一下最小值</span></span><br><span class=\"line\">    <span class=\"comment\">// eg [3,4,5,0,1,2]</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后left==right==3(index)而此时 nums[3]==0 是最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left == right) &#123;</span><br><span class=\"line\">      min = <span class=\"built_in\">Math</span>.min(nums[left], min);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &lt; nums[right]) &#123; <span class=\"comment\">// right is ordered</span></span><br><span class=\"line\">      min = <span class=\"built_in\">Math</span>.min(nums[mid], min); <span class=\"comment\">// 获取有序列表的最小值</span></span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[right]) &#123; <span class=\"comment\">// left is ordered</span></span><br><span class=\"line\">      min = <span class=\"built_in\">Math</span>.min(nums[left], min); <span class=\"comment\">// 获取有序列表的最小值</span></span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"二分查找-折半查找\"><a href=\"#二分查找-折半查找\" class=\"headerlink\" title=\"二分查找/折半查找\"></a>二分查找/折半查找</h3><h4 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h4><p>数列有序; </p>\n<p>数列使用顺序存储结构</p>\n<h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><p>将目标元素与有序数列的中间元素比较大小, 比中间元素大, 则在数列的右半部分查找, 比中间元素小, 则在数列的左半部分查找, 如果相等, 则找到.</p>\n<p>不会查找所有的元素, 查找的数据量正好符合元素的对数, 正常情况每次查找的元素都在对半减少.所以时间复杂度为 $O(log_2N)$.</p>\n<p><img src=\"Binary-Search/binary-search.png\" height=\"70%\" width=\"70%\"></p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>根据要找的key的大小, 从更接近的位置进行查找.eg.1-100000找10, 肯定采取顺序查找而不是折半查找.</p>\n<p>called 插值查找. 适用于数列比较大&amp;均匀的数列.</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><p>有序; 元素个数较多; 不进行频繁增删</p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><h5 id=\"普通的二分查找\"><a href=\"#普通的二分查找\" class=\"headerlink\" title=\"普通的二分查找\"></a>普通的二分查找</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 标准的二分查找模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> binary_search = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>; <span class=\"comment\">// 注意! [0, nums.length-1] 闭区间</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 停止条件: 找不到/数组为空</span></span><br><span class=\"line\">  <span class=\"comment\">// 找不到时是区间为空 当 left=right+1 时区间为空</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意!</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 防止使用 (left+right)/2 计算 mid 时溢出 </span></span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123; <span class=\"comment\">// 对于已经比较过的mid 不应该在下一次进行搜索的区间内</span></span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 注意!</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 注意!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"寻找左侧边界的二分查找-模板\"><a href=\"#寻找左侧边界的二分查找-模板\" class=\"headerlink\" title=\"寻找左侧边界的二分查找(模板)\"></a>寻找左侧边界的二分查找(模板)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> search_left = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 循环停止条件是 left = right + 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) &#123; <span class=\"comment\">// 关键 !!! 向左缩小区域</span></span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [left, mid-1]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [left, mid-1]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [mid+1, right]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// console.log('left:', left, 'mid:', mid, 'right:', right);</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数组越界情况</span></span><br><span class=\"line\">  <span class=\"comment\">// target&gt;所有值(left==nums.length) || target&lt;所有值(right==-1)</span></span><br><span class=\"line\">  <span class=\"comment\">// nums[left] != target ps.即使right == -1 left==0 nums[0]也有可能是target</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left == len || nums[left] != target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"寻找右侧边界的二分查找-模板\"><a href=\"#寻找右侧边界的二分查找-模板\" class=\"headerlink\" title=\"寻找右侧边界的二分查找(模板)\"></a>寻找右侧边界的二分查找(模板)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> search_right = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 循环停止条件是 left = right + 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) &#123; <span class=\"comment\">// 关键!!! 向右缩小区域</span></span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [mid+1, right]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [left, mid-1]</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 探索区间为 [mid+1, right]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// console.log('left:', left, 'mid:', mid, 'right:', right);</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数组越界情况</span></span><br><span class=\"line\">  <span class=\"comment\">// target&gt;所有值(left==nums.length) || target&lt;所有值(right==-1)</span></span><br><span class=\"line\">  <span class=\"comment\">// 即使left==len 但是 right==len-1 nums[right]也有可能是target</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[right] != target || right == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"33-Search-in-Rotated-Sorted-Array\"><a href=\"#33-Search-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"[33] Search in Rotated Sorted Array\"></a>[33] Search in Rotated Sorted Array</h4><blockquote>\n<p>You are given an integer array <code>nums</code> sorted in ascending order, and an integer <code>target</code>.</p>\n<p>Suppose that <code>nums</code> is rotated at some pivot unknown to you beforehand (i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>\n<p><em>If <code>target</code> is found in the array return its index, otherwise, return <code>-1</code>.</em></p>\n</blockquote>\n<ol>\n<li>确定有序部分 判断target在哪个部分</li>\n<li>边界 当数组两端或者中间找不到target时的情况处理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较中间元素与最后一个元素的大小 确定有序区间</span></span><br><span class=\"line\"><span class=\"comment\">// 再将目标值与该区间的首尾元素比较 确定是否在该区域内</span></span><br><span class=\"line\"><span class=\"comment\">// 给定的nums中无重复元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> search = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// 处理特殊情况</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">/** 需要注意的是 有序区间的另外半边 </span></span><br><span class=\"line\"><span class=\"comment\">   * 根据其中间元素与末尾元素(right)对比</span></span><br><span class=\"line\"><span class=\"comment\">   * 仍然可以划分出有序区间 </span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"comment\">// 处理在数组中间left==right但是nums[mid]!=target的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时也没有找到目标元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left == right &amp;&amp; nums[mid] != target) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 先判断哪边是有序序列 再看目标元素是否在有序区间内</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于没有重复元素 则不会出现 nums[mid] = nums[right] 的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 一定会存在升序序列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &lt; nums[right]) &#123; <span class=\"comment\">// 右边有序</span></span><br><span class=\"line\">      <span class=\"comment\">// 看目标元素是否在右侧有序区间内</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[right]) &#123; <span class=\"comment\">// 左边有序</span></span><br><span class=\"line\">      <span class=\"comment\">// 看目标元素是否在左侧有序区间内</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理target&lt;min(nums)或者target&gt;max(nums) 两种情况</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"35-Search-Insert-Position\"><a href=\"#35-Search-Insert-Position\" class=\"headerlink\" title=\"[35] Search Insert Position\"></a>[35] Search Insert Position</h4><blockquote>\n<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n<p>You may assume no duplicates in the array.</p>\n</blockquote>\n<h6 id=\"My-solution\"><a href=\"#My-solution\" class=\"headerlink\" title=\"My solution\"></a>My solution</h6><p>我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了…..</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchInsert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"number\">0</span>,</span><br><span class=\"line\">    end = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = start + index(end - start);</span><br><span class=\"line\">  <span class=\"comment\">// 数组len=1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[end])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> start</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (end - start == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 数组len=2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[end])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> end + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> start</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> end</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 数组len&gt;2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (end - start &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &lt; nums[mid]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target:'</span> + target + <span class=\"string\">'&lt;'</span> + <span class=\"string\">\"nums[\"</span> + mid + <span class=\"string\">\"]:\"</span> + nums[mid]);</span><br><span class=\"line\">        end = mid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (end - start == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (target == nums[start]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> start</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[start]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> start + <span class=\"number\">1</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          mid = start + index(end - start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt; nums[mid]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target:'</span> + target + <span class=\"string\">'&gt;'</span> + <span class=\"string\">\"nums[\"</span> + mid + <span class=\"string\">\"]:\"</span> + nums[mid]);</span><br><span class=\"line\">        start = mid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (end - start == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (target == nums[end]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> end</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt; nums[end]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> end + <span class=\"number\">1</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> start + <span class=\"number\">1</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          mid = start + index(end - start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// console.log(mid);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"function\">(<span class=\"params\">gap</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (gap % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gap / <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (gap + <span class=\"number\">1</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"solution-on-the-Internet\"><a href=\"#solution-on-the-Internet\" class=\"headerlink\" title=\"solution on the Internet\"></a>solution on the Internet</h6><p>参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchInsert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"number\">0</span>, end = nums.length - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target &gt; nums[end])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// if (target &lt; nums[start])</span></span><br><span class=\"line\">  <span class=\"comment\">//   return 0;</span></span><br><span class=\"line\">  <span class=\"comment\">// if (target == nums[start])</span></span><br><span class=\"line\">  <span class=\"comment\">//   return start</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (end &gt; start) &#123;</span><br><span class=\"line\">    mid = start + <span class=\"built_in\">parseInt</span>((end - start) / <span class=\"number\">2</span>); <span class=\"comment\">// parseInt 直接丢弃小数部分, 保留整数部分</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'mid: '</span>, mid, <span class=\"string\">' start: '</span>, start, <span class=\"string\">' end: '</span>, end);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[start])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[end])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[mid])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[mid]) &#123;</span><br><span class=\"line\">      start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"comment\">// console.log('target &gt; mid', 'start: ', start);</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      end = mid;</span><br><span class=\"line\">      <span class=\"comment\">// console.log('target &lt; mid', 'end: ', end);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> start</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"81-Search-in-Rotated-Sorted-Array-II\"><a href=\"#81-Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"[81] Search in Rotated Sorted Array II\"></a>[81] Search in Rotated Sorted Array II</h4><blockquote>\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>\n<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>This is a follow up problem to <a href=\"vscode-webview://5ad24d3b-f3dc-4f27-82d5-8e23615b83c1/problems/search-in-rotated-sorted-array/description/\">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>\n<li>Would this affect the run-time complexity? How and why?</li>\n</ul>\n</blockquote>\n<p>有重复元素的有序数组分为了两个部分, 颠倒之后的数组的第一个元素一定&gt;=第二部分的任意元素.</p>\n<p>将需要搜索的部分分为三个部分, 前半个数组[left, mid)/中间元素mid/后半个数组(mid, right]</p>\n<p>mid和target可能分别在左右部分, 对这两者的位置组合进行分情况讨论. 如果target在左min(left)和max(right)之间, 则直接返回false.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原来没有重复元素时 判断有序数组比较好判断 直接比较大小</span></span><br><span class=\"line\"><span class=\"comment\">// 现在有重复元素 无法通过比较中间元素与最右元素的大小来确定哪一边数组是有序的</span></span><br><span class=\"line\"><span class=\"comment\">// 也就无法知道target应该在mid的哪一边</span></span><br><span class=\"line\"><span class=\"comment\">// eg. 1,1,2,3,1,1,1,1,1,1,1,1</span></span><br><span class=\"line\"><span class=\"comment\">// 普遍意义的二分查找不能使用了 但是不能使用遍历的方法(O(N))</span></span><br><span class=\"line\"><span class=\"comment\">// 为了O(logN)的时间复杂度必须想其他方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> search = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先写一个标准的二分查找</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 找到目标元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == nums[mid]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 看mid在哪个部分</span></span><br><span class=\"line\">    <span class=\"comment\">// mid in left part</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt; nums[left]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &gt; nums[mid]) &#123; <span class=\"comment\">// target in left and &gt; mid</span></span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[left]) &#123; <span class=\"comment\">// target in left and &lt; mid</span></span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt;= nums[right]) &#123; <span class=\"comment\">// target in right</span></span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// target 左右部分均不在</span></span><br><span class=\"line\">        <span class=\"comment\">// 考虑测试案例 [1,3,1,1,1] 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// mid in right part</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[left]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target &lt; nums[mid]) &#123; <span class=\"comment\">// target in right and &lt; mid</span></span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; <span class=\"comment\">// target in right and &gt; mid</span></span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &gt;= nums[left]) &#123; <span class=\"comment\">// target in left</span></span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// target 左右部分均不在</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] == nums[left]) &#123; <span class=\"comment\">// mid in left or right</span></span><br><span class=\"line\">      <span class=\"comment\">// 此时不能根据nums[mid]与target的大小比较确定接下来的收缩范围</span></span><br><span class=\"line\">      <span class=\"comment\">// 不确定是 left=mid+1 or right=mid-1</span></span><br><span class=\"line\">      left = left + <span class=\"number\">1</span>; <span class=\"comment\">// or right=right-1; 逐步缩小搜索范围</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"153-Find-Minimum-in-Rotated-Sorted-Array\"><a href=\"#153-Find-Minimum-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"[153] Find Minimum in Rotated Sorted Array\"></a>[153] Find Minimum in Rotated Sorted Array</h4><blockquote>\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>\n<p>Find the minimum element.</p>\n<p>You may assume no duplicate exists in the array.</p>\n</blockquote>\n<p>总体思路: 使用二分查找, 不断寻找有序部分的最小值, 返回最小值中的最小值.</p>\n<p>时间复杂度: logN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先确定有序的部分 保留其最小值x</span></span><br><span class=\"line\"><span class=\"comment\">// 然后再使用二分查找查找剩下无序部分中的升序部分的最小值 与x比较保留较小值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findMin = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = len - <span class=\"number\">1</span>, mid = <span class=\"number\">0</span>, min = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此时判断一下最小值</span></span><br><span class=\"line\">    <span class=\"comment\">// eg [3,4,5,0,1,2]</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后left==right==3(index)而此时 nums[3]==0 是最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left == right) &#123;</span><br><span class=\"line\">      min = <span class=\"built_in\">Math</span>.min(nums[left], min);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mid = left + <span class=\"built_in\">Math</span>.floor((right - left) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &lt; nums[right]) &#123; <span class=\"comment\">// right is ordered</span></span><br><span class=\"line\">      min = <span class=\"built_in\">Math</span>.min(nums[mid], min); <span class=\"comment\">// 获取有序列表的最小值</span></span><br><span class=\"line\">      right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[right]) &#123; <span class=\"comment\">// left is ordered</span></span><br><span class=\"line\">      min = <span class=\"built_in\">Math</span>.min(nums[left], min); <span class=\"comment\">// 获取有序列表的最小值</span></span><br><span class=\"line\">      left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Dynamic-Programming","abbrlink":"ef1e907a","date":"2020-08-04T09:02:27.000Z","description":"动态规划相关题解","_content":"\n#### [62] Unique Paths\n\n> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).\n>\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> How many possible unique paths are there?\n\n\n\n##### Solution 1: 排列组合\n\n因为机器到底右下角，向下几步，向右几步都是固定的，\n\n比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。\n\n所以结果= (m+n−2)!/((m−1)!*(n-1)!).\n\n```javascript\n// solution 1 : 排列组合\n// 使用数学上的排列组合计算公式\nvar uniquePaths1 = function (m, n) {\n  // 起点到终点一共需要走 m-1+n-1 = m+n-2 步\n  // 其中从总步数中选出向右的 m-1 步\n  return jc(m + n - 2) / (jc(m - 1) * jc(n - 1))\n};\n\nvar jc = (num) => {\n  let res = 1;\n  for (let i = 1; i <= num; i++) {\n    res = res * i;\n  }\n  return res;\n}\n```\n\n\n\n##### Solution 2: 动态规划\n\n关键在于写出状态转移方程.很多解法用的是数组,我这里用的是对象存储.\n\n数组的空间O(mn)可优化为O(n).\n\n```javascript\n// solution 2 : 动态规划\n// 假设到点(i,j)的所有路径数表示为 dp(i,j)\n// 状态转移方程\n// dp(i,j) = dp(i-1,j) + dp(i,j-1)\nvar uniquePaths2 = function (m, n) {\n  let dp = {};\n  // 只能向右或向下\n  // 所以到达边界的点的方法数=1\n  dp[key(0, 0)] = 1;\n  for (let i = 1; i < m; i++) {\n    dp[key(i, 0)] = 1;\n  }\n  for (let j = 1; j < n; j++) {\n    dp[key(0, j)] = 1;\n  }\n  // 时间复杂度O(mn)\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[key(i, j)] = dp[key(i - 1, j)] + dp[key(i, j - 1)];\n    }\n  }\n  return dp[key(m - 1, n - 1)]\n};\n\nvar key = (i, j) => {\n  return i + '/' + j\n}\n```\n\n\n\n#### [63] Unique Paths II\n\n> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).\n>\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> Now consider if some obstacles are added to the grids. How many unique paths would there be?\n\n这里需要修改状态转移方程, 就是, 在计算某一点可到达的路径数时, 如果这一点有障碍, 则为0, 否则按照原来的等式计算.\n\n在初始化到达边缘点的路径数时, 也要考虑障碍的情况.\n\n感觉动态规划主要有两个过程, 重点还是**分析清楚过程**:\n\n1. **初始化数据**\n2. **正确的动态规划方程**\n\n```javascript\nvar uniquePathsWithObstacles = function (obstacleGrid) {\n  let rowNum = obstacleGrid.length;\n  let colNum = obstacleGrid[0].length;\n  let dp = {};\n\n  let flag1 = true;\n  for (let i = 0; i < rowNum; i++) {\n    // 考虑障碍的情况\n    // 边缘一有障碍, 则后面所有点的可到达路径数均为0\n    if (obstacleGrid[i][0] == 1) {\n      for (let t = i; t < rowNum; t++) {\n        dp[key(t, 0)] = 0;\n      }\n      flag1 = false;\n      break;\n    }\n    dp[key(i, 0)] = (flag1 == true) ? 1 : 0;\n  }\n\n  let flag2 = true;\n  for (let j = 0; j < colNum; j++) {\n    if (obstacleGrid[0][j] == 1) {\n      for (let t = j; t < colNum; t++) {\n        dp[key(0, t)] = 0;\n      }\n      flag2 = false;\n      break;\n    }\n    dp[key(0, j)] = (flag2 == true) ? 1 : 0;\n  }\n\n  for (let i = 1; i < rowNum; i++) {\n    for (let j = 1; j < colNum; j++) {\n      // 考虑障碍的动态规划方程\n      if (obstacleGrid[i][j] == 1)\n        dp[key(i, j)] = 0;\n      else\n        dp[key(i, j)] = dp[key(i - 1, j)] + dp[key(i, j - 1)];\n    }\n  }\n  // console.log(dp[key(rowNum - 1, colNum - 1)]);\n  return dp[key(rowNum - 1, colNum - 1)];\n};\n\nvar key = (i, j) => {\n  return i + '/' + j;\n}\n```\n\n\n\n#### [300] Longest Increasing Subsequence\n\n> Given an unsorted array of integers, find the length of longest increasing subsequence.\n\n**动态规划**\n\n时间复杂度:\n\n遍历数组, 遍历到每个元素时, 再次遍历该元素之前的所有元素. $O(N^2)$.\n\n空间复杂度:\n\n使用额外数组保存每个元素的最长子串的长度. $O(N)$ .\n\n```javascript\n// solution 1: 使用动态规划 时间复杂度 O(N^2)\n// 后一个元素的递增子串长度最大值依赖于前面每个元素的递增子串长度最大值\nvar lengthOfLIS = function (nums) {\n  let len = nums.length;\n  // 不存在递增的子串\n  if (len == 0) return [];\n  // 初始化数组 保存到达每个位置的所有递增子串长度的最大值(以每个位置为终点)\n  let dp = new Array(len);\n  dp.fill(1);\n  let maxLen = 1, val = 0;\n  // 计算每一个位置的最长子串长度\n  for (let i = 1; i < len; i++) {\n    // 计算过程中, 每次查找i之前的元素, 看有无比nums[i]还小的\n    // 小的话就是dp[j]+1\n    // 但是还要将 dp[i] 与 dp[j]+1 进行比较, 保留较大值\n    // 则最后dp[i]是所有递增子串中最长子串的长度\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) {\n        val = dp[j] + 1;\n        dp[i] = val > dp[i] ? val : dp[i];\n      }\n    }\n    // 保留dp[i]中的最大值\n    maxLen = maxLen > dp[i] ? maxLen : dp[i];\n  }\n  // 返回的是 最长的递增子串的长度\n  return maxLen;\n};\n```\n\n\n\n#### [70] Climbing Stairs\n\n> You are climbing a stair case. It takes *n* steps to reach to the top.\n>\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n**时间复杂度**:\n\n计算每一层的方法数, $O(N)$\n\n**空间复杂度**:\n\n使用数组保存到达每一层的方法数, $O(N)$\n\n```javascript\n// 楼梯一共有n层\n// 需要返回达到n层总共的路径数\n// 到达每一层都有两种方式, 要不跨一步, 要不跨两步\n// 假设到达i层的方法数为dp[i], 则dp[i] = dp[i-1] + dp[i-2]\nvar climbStairs = function (n) {\n  let way = new Array(n);\n  way.fill(0);\n  way[0] = 1;\n  way[1] = 2;\n  for (let i = 2; i < n; i++) {\n    way[i] = way[i - 1] + way[i - 2];\n  }\n  return way[n - 1];\n};\n```\n\n\n\n\n\n","source":"_posts/Dynamic-Programming.md","raw":"---\ntitle: Dynamic-Programming\nabbrlink: ef1e907a\ndate: 2020-08-04 17:02:27\ntags:\n\t- LeetCode\n\t- Array\n\t- Dynamic-Programming\ndescription: 动态规划相关题解\n---\n\n#### [62] Unique Paths\n\n> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).\n>\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> How many possible unique paths are there?\n\n\n\n##### Solution 1: 排列组合\n\n因为机器到底右下角，向下几步，向右几步都是固定的，\n\n比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。\n\n所以结果= (m+n−2)!/((m−1)!*(n-1)!).\n\n```javascript\n// solution 1 : 排列组合\n// 使用数学上的排列组合计算公式\nvar uniquePaths1 = function (m, n) {\n  // 起点到终点一共需要走 m-1+n-1 = m+n-2 步\n  // 其中从总步数中选出向右的 m-1 步\n  return jc(m + n - 2) / (jc(m - 1) * jc(n - 1))\n};\n\nvar jc = (num) => {\n  let res = 1;\n  for (let i = 1; i <= num; i++) {\n    res = res * i;\n  }\n  return res;\n}\n```\n\n\n\n##### Solution 2: 动态规划\n\n关键在于写出状态转移方程.很多解法用的是数组,我这里用的是对象存储.\n\n数组的空间O(mn)可优化为O(n).\n\n```javascript\n// solution 2 : 动态规划\n// 假设到点(i,j)的所有路径数表示为 dp(i,j)\n// 状态转移方程\n// dp(i,j) = dp(i-1,j) + dp(i,j-1)\nvar uniquePaths2 = function (m, n) {\n  let dp = {};\n  // 只能向右或向下\n  // 所以到达边界的点的方法数=1\n  dp[key(0, 0)] = 1;\n  for (let i = 1; i < m; i++) {\n    dp[key(i, 0)] = 1;\n  }\n  for (let j = 1; j < n; j++) {\n    dp[key(0, j)] = 1;\n  }\n  // 时间复杂度O(mn)\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[key(i, j)] = dp[key(i - 1, j)] + dp[key(i, j - 1)];\n    }\n  }\n  return dp[key(m - 1, n - 1)]\n};\n\nvar key = (i, j) => {\n  return i + '/' + j\n}\n```\n\n\n\n#### [63] Unique Paths II\n\n> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).\n>\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> Now consider if some obstacles are added to the grids. How many unique paths would there be?\n\n这里需要修改状态转移方程, 就是, 在计算某一点可到达的路径数时, 如果这一点有障碍, 则为0, 否则按照原来的等式计算.\n\n在初始化到达边缘点的路径数时, 也要考虑障碍的情况.\n\n感觉动态规划主要有两个过程, 重点还是**分析清楚过程**:\n\n1. **初始化数据**\n2. **正确的动态规划方程**\n\n```javascript\nvar uniquePathsWithObstacles = function (obstacleGrid) {\n  let rowNum = obstacleGrid.length;\n  let colNum = obstacleGrid[0].length;\n  let dp = {};\n\n  let flag1 = true;\n  for (let i = 0; i < rowNum; i++) {\n    // 考虑障碍的情况\n    // 边缘一有障碍, 则后面所有点的可到达路径数均为0\n    if (obstacleGrid[i][0] == 1) {\n      for (let t = i; t < rowNum; t++) {\n        dp[key(t, 0)] = 0;\n      }\n      flag1 = false;\n      break;\n    }\n    dp[key(i, 0)] = (flag1 == true) ? 1 : 0;\n  }\n\n  let flag2 = true;\n  for (let j = 0; j < colNum; j++) {\n    if (obstacleGrid[0][j] == 1) {\n      for (let t = j; t < colNum; t++) {\n        dp[key(0, t)] = 0;\n      }\n      flag2 = false;\n      break;\n    }\n    dp[key(0, j)] = (flag2 == true) ? 1 : 0;\n  }\n\n  for (let i = 1; i < rowNum; i++) {\n    for (let j = 1; j < colNum; j++) {\n      // 考虑障碍的动态规划方程\n      if (obstacleGrid[i][j] == 1)\n        dp[key(i, j)] = 0;\n      else\n        dp[key(i, j)] = dp[key(i - 1, j)] + dp[key(i, j - 1)];\n    }\n  }\n  // console.log(dp[key(rowNum - 1, colNum - 1)]);\n  return dp[key(rowNum - 1, colNum - 1)];\n};\n\nvar key = (i, j) => {\n  return i + '/' + j;\n}\n```\n\n\n\n#### [300] Longest Increasing Subsequence\n\n> Given an unsorted array of integers, find the length of longest increasing subsequence.\n\n**动态规划**\n\n时间复杂度:\n\n遍历数组, 遍历到每个元素时, 再次遍历该元素之前的所有元素. $O(N^2)$.\n\n空间复杂度:\n\n使用额外数组保存每个元素的最长子串的长度. $O(N)$ .\n\n```javascript\n// solution 1: 使用动态规划 时间复杂度 O(N^2)\n// 后一个元素的递增子串长度最大值依赖于前面每个元素的递增子串长度最大值\nvar lengthOfLIS = function (nums) {\n  let len = nums.length;\n  // 不存在递增的子串\n  if (len == 0) return [];\n  // 初始化数组 保存到达每个位置的所有递增子串长度的最大值(以每个位置为终点)\n  let dp = new Array(len);\n  dp.fill(1);\n  let maxLen = 1, val = 0;\n  // 计算每一个位置的最长子串长度\n  for (let i = 1; i < len; i++) {\n    // 计算过程中, 每次查找i之前的元素, 看有无比nums[i]还小的\n    // 小的话就是dp[j]+1\n    // 但是还要将 dp[i] 与 dp[j]+1 进行比较, 保留较大值\n    // 则最后dp[i]是所有递增子串中最长子串的长度\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) {\n        val = dp[j] + 1;\n        dp[i] = val > dp[i] ? val : dp[i];\n      }\n    }\n    // 保留dp[i]中的最大值\n    maxLen = maxLen > dp[i] ? maxLen : dp[i];\n  }\n  // 返回的是 最长的递增子串的长度\n  return maxLen;\n};\n```\n\n\n\n#### [70] Climbing Stairs\n\n> You are climbing a stair case. It takes *n* steps to reach to the top.\n>\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n**时间复杂度**:\n\n计算每一层的方法数, $O(N)$\n\n**空间复杂度**:\n\n使用数组保存到达每一层的方法数, $O(N)$\n\n```javascript\n// 楼梯一共有n层\n// 需要返回达到n层总共的路径数\n// 到达每一层都有两种方式, 要不跨一步, 要不跨两步\n// 假设到达i层的方法数为dp[i], 则dp[i] = dp[i-1] + dp[i-2]\nvar climbStairs = function (n) {\n  let way = new Array(n);\n  way.fill(0);\n  way[0] = 1;\n  way[1] = 2;\n  for (let i = 2; i < n; i++) {\n    way[i] = way[i - 1] + way[i - 2];\n  }\n  return way[n - 1];\n};\n```\n\n\n\n\n\n","slug":"Dynamic-Programming","published":1,"updated":"2020-10-29T10:57:29.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafp000amm9hhxmi89rn","content":"<h4 id=\"62-Unique-Paths\"><a href=\"#62-Unique-Paths\" class=\"headerlink\" title=\"[62] Unique Paths\"></a>[62] Unique Paths</h4><blockquote>\n<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>How many possible unique paths are there?</p>\n</blockquote>\n<h5 id=\"Solution-1-排列组合\"><a href=\"#Solution-1-排列组合\" class=\"headerlink\" title=\"Solution 1: 排列组合\"></a>Solution 1: 排列组合</h5><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p>\n<p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p>\n<p>所以结果= (m+n−2)!/((m−1)!*(n-1)!).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1 : 排列组合</span></span><br><span class=\"line\"><span class=\"comment\">// 使用数学上的排列组合计算公式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> uniquePaths1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 起点到终点一共需要走 m-1+n-1 = m+n-2 步</span></span><br><span class=\"line\">  <span class=\"comment\">// 其中从总步数中选出向右的 m-1 步</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> jc(m + n - <span class=\"number\">2</span>) / (jc(m - <span class=\"number\">1</span>) * jc(n - <span class=\"number\">1</span>))</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jc = <span class=\"function\">(<span class=\"params\">num</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= num; i++) &#123;</span><br><span class=\"line\">    res = res * i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Solution-2-动态规划\"><a href=\"#Solution-2-动态规划\" class=\"headerlink\" title=\"Solution 2: 动态规划\"></a>Solution 2: 动态规划</h5><p>关键在于写出状态转移方程.很多解法用的是数组,我这里用的是对象存储.</p>\n<p>数组的空间O(mn)可优化为O(n).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 2 : 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// 假设到点(i,j)的所有路径数表示为 dp(i,j)</span></span><br><span class=\"line\"><span class=\"comment\">// 状态转移方程</span></span><br><span class=\"line\"><span class=\"comment\">// dp(i,j) = dp(i-1,j) + dp(i,j-1)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> uniquePaths2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dp = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 只能向右或向下</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以到达边界的点的方法数=1</span></span><br><span class=\"line\">  dp[key(<span class=\"number\">0</span>, <span class=\"number\">0</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    dp[key(i, <span class=\"number\">0</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">    dp[key(<span class=\"number\">0</span>, j)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 时间复杂度O(mn)</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      dp[key(i, j)] = dp[key(i - <span class=\"number\">1</span>, j)] + dp[key(i, j - <span class=\"number\">1</span>)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[key(m - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>)]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"function\">(<span class=\"params\">i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"string\">'/'</span> + j</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"63-Unique-Paths-II\"><a href=\"#63-Unique-Paths-II\" class=\"headerlink\" title=\"[63] Unique Paths II\"></a>[63] Unique Paths II</h4><blockquote>\n<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>\n</blockquote>\n<p>这里需要修改状态转移方程, 就是, 在计算某一点可到达的路径数时, 如果这一点有障碍, 则为0, 否则按照原来的等式计算.</p>\n<p>在初始化到达边缘点的路径数时, 也要考虑障碍的情况.</p>\n<p>感觉动态规划主要有两个过程, 重点还是<strong>分析清楚过程</strong>:</p>\n<ol>\n<li><strong>初始化数据</strong></li>\n<li><strong>正确的动态规划方程</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uniquePathsWithObstacles = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obstacleGrid</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rowNum = obstacleGrid.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> colNum = obstacleGrid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dp = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag1 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 考虑障碍的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 边缘一有障碍, 则后面所有点的可到达路径数均为0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[i][<span class=\"number\">0</span>] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = i; t &lt; rowNum; t++) &#123;</span><br><span class=\"line\">        dp[key(t, <span class=\"number\">0</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      flag1 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[key(i, <span class=\"number\">0</span>)] = (flag1 == <span class=\"literal\">true</span>) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag2 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; colNum; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[<span class=\"number\">0</span>][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = j; t &lt; colNum; t++) &#123;</span><br><span class=\"line\">        dp[key(<span class=\"number\">0</span>, t)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      flag2 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[key(<span class=\"number\">0</span>, j)] = (flag2 == <span class=\"literal\">true</span>) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; rowNum; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; colNum; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 考虑障碍的动态规划方程</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obstacleGrid[i][j] == <span class=\"number\">1</span>)</span><br><span class=\"line\">        dp[key(i, j)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        dp[key(i, j)] = dp[key(i - <span class=\"number\">1</span>, j)] + dp[key(i, j - <span class=\"number\">1</span>)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(dp[key(rowNum - 1, colNum - 1)]);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[key(rowNum - <span class=\"number\">1</span>, colNum - <span class=\"number\">1</span>)];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"function\">(<span class=\"params\">i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"string\">'/'</span> + j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"300-Longest-Increasing-Subsequence\"><a href=\"#300-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"[300] Longest Increasing Subsequence\"></a>[300] Longest Increasing Subsequence</h4><blockquote>\n<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>\n</blockquote>\n<p><strong>动态规划</strong></p>\n<p>时间复杂度:</p>\n<p>遍历数组, 遍历到每个元素时, 再次遍历该元素之前的所有元素. $O(N^2)$.</p>\n<p>空间复杂度:</p>\n<p>使用额外数组保存每个元素的最长子串的长度. $O(N)$ .</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1: 使用动态规划 时间复杂度 O(N^2)</span></span><br><span class=\"line\"><span class=\"comment\">// 后一个元素的递增子串长度最大值依赖于前面每个元素的递增子串长度最大值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLIS = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"comment\">// 不存在递增的子串</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"comment\">// 初始化数组 保存到达每个位置的所有递增子串长度的最大值(以每个位置为终点)</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len);</span><br><span class=\"line\">  dp.fill(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxLen = <span class=\"number\">1</span>, val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 计算每一个位置的最长子串长度</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算过程中, 每次查找i之前的元素, 看有无比nums[i]还小的</span></span><br><span class=\"line\">    <span class=\"comment\">// 小的话就是dp[j]+1</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是还要将 dp[i] 与 dp[j]+1 进行比较, 保留较大值</span></span><br><span class=\"line\">    <span class=\"comment\">// 则最后dp[i]是所有递增子串中最长子串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class=\"line\">        val = dp[j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[i] = val &gt; dp[i] ? val : dp[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 保留dp[i]中的最大值</span></span><br><span class=\"line\">    maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回的是 最长的递增子串的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"70-Climbing-Stairs\"><a href=\"#70-Climbing-Stairs\" class=\"headerlink\" title=\"[70] Climbing Stairs\"></a>[70] Climbing Stairs</h4><blockquote>\n<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>计算每一层的方法数, $O(N)$</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>使用数组保存到达每一层的方法数, $O(N)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 楼梯一共有n层</span></span><br><span class=\"line\"><span class=\"comment\">// 需要返回达到n层总共的路径数</span></span><br><span class=\"line\"><span class=\"comment\">// 到达每一层都有两种方式, 要不跨一步, 要不跨两步</span></span><br><span class=\"line\"><span class=\"comment\">// 假设到达i层的方法数为dp[i], 则dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> climbStairs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> way = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">  way.fill(<span class=\"number\">0</span>);</span><br><span class=\"line\">  way[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  way[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    way[i] = way[i - <span class=\"number\">1</span>] + way[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> way[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"62-Unique-Paths\"><a href=\"#62-Unique-Paths\" class=\"headerlink\" title=\"[62] Unique Paths\"></a>[62] Unique Paths</h4><blockquote>\n<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>How many possible unique paths are there?</p>\n</blockquote>\n<h5 id=\"Solution-1-排列组合\"><a href=\"#Solution-1-排列组合\" class=\"headerlink\" title=\"Solution 1: 排列组合\"></a>Solution 1: 排列组合</h5><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p>\n<p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p>\n<p>所以结果= (m+n−2)!/((m−1)!*(n-1)!).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1 : 排列组合</span></span><br><span class=\"line\"><span class=\"comment\">// 使用数学上的排列组合计算公式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> uniquePaths1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 起点到终点一共需要走 m-1+n-1 = m+n-2 步</span></span><br><span class=\"line\">  <span class=\"comment\">// 其中从总步数中选出向右的 m-1 步</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> jc(m + n - <span class=\"number\">2</span>) / (jc(m - <span class=\"number\">1</span>) * jc(n - <span class=\"number\">1</span>))</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jc = <span class=\"function\">(<span class=\"params\">num</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= num; i++) &#123;</span><br><span class=\"line\">    res = res * i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Solution-2-动态规划\"><a href=\"#Solution-2-动态规划\" class=\"headerlink\" title=\"Solution 2: 动态规划\"></a>Solution 2: 动态规划</h5><p>关键在于写出状态转移方程.很多解法用的是数组,我这里用的是对象存储.</p>\n<p>数组的空间O(mn)可优化为O(n).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 2 : 动态规划</span></span><br><span class=\"line\"><span class=\"comment\">// 假设到点(i,j)的所有路径数表示为 dp(i,j)</span></span><br><span class=\"line\"><span class=\"comment\">// 状态转移方程</span></span><br><span class=\"line\"><span class=\"comment\">// dp(i,j) = dp(i-1,j) + dp(i,j-1)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> uniquePaths2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dp = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 只能向右或向下</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以到达边界的点的方法数=1</span></span><br><span class=\"line\">  dp[key(<span class=\"number\">0</span>, <span class=\"number\">0</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    dp[key(i, <span class=\"number\">0</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">    dp[key(<span class=\"number\">0</span>, j)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 时间复杂度O(mn)</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      dp[key(i, j)] = dp[key(i - <span class=\"number\">1</span>, j)] + dp[key(i, j - <span class=\"number\">1</span>)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[key(m - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>)]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"function\">(<span class=\"params\">i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"string\">'/'</span> + j</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"63-Unique-Paths-II\"><a href=\"#63-Unique-Paths-II\" class=\"headerlink\" title=\"[63] Unique Paths II\"></a>[63] Unique Paths II</h4><blockquote>\n<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>\n</blockquote>\n<p>这里需要修改状态转移方程, 就是, 在计算某一点可到达的路径数时, 如果这一点有障碍, 则为0, 否则按照原来的等式计算.</p>\n<p>在初始化到达边缘点的路径数时, 也要考虑障碍的情况.</p>\n<p>感觉动态规划主要有两个过程, 重点还是<strong>分析清楚过程</strong>:</p>\n<ol>\n<li><strong>初始化数据</strong></li>\n<li><strong>正确的动态规划方程</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uniquePathsWithObstacles = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obstacleGrid</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rowNum = obstacleGrid.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> colNum = obstacleGrid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dp = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag1 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 考虑障碍的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 边缘一有障碍, 则后面所有点的可到达路径数均为0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[i][<span class=\"number\">0</span>] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = i; t &lt; rowNum; t++) &#123;</span><br><span class=\"line\">        dp[key(t, <span class=\"number\">0</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      flag1 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[key(i, <span class=\"number\">0</span>)] = (flag1 == <span class=\"literal\">true</span>) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag2 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; colNum; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[<span class=\"number\">0</span>][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = j; t &lt; colNum; t++) &#123;</span><br><span class=\"line\">        dp[key(<span class=\"number\">0</span>, t)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      flag2 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[key(<span class=\"number\">0</span>, j)] = (flag2 == <span class=\"literal\">true</span>) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; rowNum; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; colNum; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 考虑障碍的动态规划方程</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obstacleGrid[i][j] == <span class=\"number\">1</span>)</span><br><span class=\"line\">        dp[key(i, j)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        dp[key(i, j)] = dp[key(i - <span class=\"number\">1</span>, j)] + dp[key(i, j - <span class=\"number\">1</span>)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(dp[key(rowNum - 1, colNum - 1)]);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[key(rowNum - <span class=\"number\">1</span>, colNum - <span class=\"number\">1</span>)];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"function\">(<span class=\"params\">i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"string\">'/'</span> + j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"300-Longest-Increasing-Subsequence\"><a href=\"#300-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"[300] Longest Increasing Subsequence\"></a>[300] Longest Increasing Subsequence</h4><blockquote>\n<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>\n</blockquote>\n<p><strong>动态规划</strong></p>\n<p>时间复杂度:</p>\n<p>遍历数组, 遍历到每个元素时, 再次遍历该元素之前的所有元素. $O(N^2)$.</p>\n<p>空间复杂度:</p>\n<p>使用额外数组保存每个元素的最长子串的长度. $O(N)$ .</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1: 使用动态规划 时间复杂度 O(N^2)</span></span><br><span class=\"line\"><span class=\"comment\">// 后一个元素的递增子串长度最大值依赖于前面每个元素的递增子串长度最大值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLIS = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"comment\">// 不存在递增的子串</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  <span class=\"comment\">// 初始化数组 保存到达每个位置的所有递增子串长度的最大值(以每个位置为终点)</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len);</span><br><span class=\"line\">  dp.fill(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxLen = <span class=\"number\">1</span>, val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 计算每一个位置的最长子串长度</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算过程中, 每次查找i之前的元素, 看有无比nums[i]还小的</span></span><br><span class=\"line\">    <span class=\"comment\">// 小的话就是dp[j]+1</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是还要将 dp[i] 与 dp[j]+1 进行比较, 保留较大值</span></span><br><span class=\"line\">    <span class=\"comment\">// 则最后dp[i]是所有递增子串中最长子串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class=\"line\">        val = dp[j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[i] = val &gt; dp[i] ? val : dp[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 保留dp[i]中的最大值</span></span><br><span class=\"line\">    maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回的是 最长的递增子串的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"70-Climbing-Stairs\"><a href=\"#70-Climbing-Stairs\" class=\"headerlink\" title=\"[70] Climbing Stairs\"></a>[70] Climbing Stairs</h4><blockquote>\n<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n</blockquote>\n<p><strong>时间复杂度</strong>:</p>\n<p>计算每一层的方法数, $O(N)$</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>使用数组保存到达每一层的方法数, $O(N)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 楼梯一共有n层</span></span><br><span class=\"line\"><span class=\"comment\">// 需要返回达到n层总共的路径数</span></span><br><span class=\"line\"><span class=\"comment\">// 到达每一层都有两种方式, 要不跨一步, 要不跨两步</span></span><br><span class=\"line\"><span class=\"comment\">// 假设到达i层的方法数为dp[i], 则dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> climbStairs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> way = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">  way.fill(<span class=\"number\">0</span>);</span><br><span class=\"line\">  way[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  way[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    way[i] = way[i - <span class=\"number\">1</span>] + way[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> way[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Greedy Algorithm","abbrlink":"9adfc48b","date":"2020-08-03T02:16:53.000Z","description":"贪心算法相关题解","_content":"\n#### [45] Jump Game II\n\n>  Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n>  Each element in the array represents your maximum jump length at that position.\n>\n>  Your goal is to reach the last index in the minimum number of jumps.\n\n\n\n贪心算法, 局部解得到最优解.\n\n解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.\n\n但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.\n\n![45_fig1](Greedy-Algorithm/45_fig1.png)\n\n```javascript\n// 对于当前index, 每次在能跳到的范围内\n// 跳到能跳到更远地方的index\nvar jump = function (nums) {\n  let len = nums.length;\n  if (len == 1)\n    return 0;\n  if (nums[0] >= len - 1)\n    return 1\n\n  let step = 0;\n  let nextPosMap = { 'index': 0, 'maxIndex': 0 + nums[0] };\n\n  for (let i = 0; i < len;) {\n    let indexLimit = i + nums[i];\n    // 在寻找下一步跳的位置时, 步数加一\n    step++;\n    for (let j = i + 1; j <= indexLimit && j < len; j++) {\n      if (j + nums[j] > nextPosMap.maxIndex) {\n        nextPosMap.index = j;\n        nextPosMap.maxIndex = j + nums[j];\n      }\n    }\n    // index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index\n    // 其实肯定更新, 题目已经说了能跳到最后\n    // 移动才算跳了一步\n    // 同时能跳到的最远位置不要超过数组边界\n    // 超过数组边界则表示步数已经能计算出来了 return\n    if (nextPosMap.maxIndex < len - 1) {\n      i = nextPosMap.index;\n    } else {\n      // 当最大位置能到达最后时, 返回step+1\n      // 把跳到最后位置的一步也加上\n      return step + 1;\n    }\n  }\n};\n```\n\n\n\n#### [55] Jump Game\n\n> Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n> Each element in the array represents your maximum jump length at that position.\n>\n> Determine if you are able to reach the last index.\n\n\n\n一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.\n\n于是就去看网上解法, 这里的考点是**贪心算法**.\n\n> 贪心算法（又称贪婪算法）是指，在对[问题求解](https://baike.baidu.com/item/问题求解/6693186)时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解\n\n\n\n该题的大概思路是:\n\n数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.\n\n![largen-reach](Greedy-Algorithm/largen-reach.png)\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\n// 递归超时 使用贪心算法求解\n// 局部能够到达的最大范围, 也是全局能够到达的最大范围\nvar canJump = function (nums) {\n  let reach = nums[0];\n  // 需要注意的点是,这里reach的值不一定就>1, 所以i不一定就从1开始\n  // 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]\n  // 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach\n  for (let i = 0; i < nums.length && i <= reach; i++) {\n    if (nums[i] + i > reach) {\n      reach = nums[i] + i;\n      // console.log(reach);\n    }\n    // 当能到达的范围超过数组的最后 index 时, 返回 true\n    if (reach >= nums.length - 1)\n      return true\n  }\n  // 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素\n  return false\n};\n```\n\n\n\n","source":"_posts/Greedy-Algorithm.md","raw":"---\ntitle: Greedy Algorithm\ntags:\n  - LeetCode\ncategories: Algorithm\nabbrlink: 9adfc48b\ndate: 2020-08-03 10:16:53\ndescription: 贪心算法相关题解\n---\n\n#### [45] Jump Game II\n\n>  Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n>  Each element in the array represents your maximum jump length at that position.\n>\n>  Your goal is to reach the last index in the minimum number of jumps.\n\n\n\n贪心算法, 局部解得到最优解.\n\n解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.\n\n但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.\n\n![45_fig1](Greedy-Algorithm/45_fig1.png)\n\n```javascript\n// 对于当前index, 每次在能跳到的范围内\n// 跳到能跳到更远地方的index\nvar jump = function (nums) {\n  let len = nums.length;\n  if (len == 1)\n    return 0;\n  if (nums[0] >= len - 1)\n    return 1\n\n  let step = 0;\n  let nextPosMap = { 'index': 0, 'maxIndex': 0 + nums[0] };\n\n  for (let i = 0; i < len;) {\n    let indexLimit = i + nums[i];\n    // 在寻找下一步跳的位置时, 步数加一\n    step++;\n    for (let j = i + 1; j <= indexLimit && j < len; j++) {\n      if (j + nums[j] > nextPosMap.maxIndex) {\n        nextPosMap.index = j;\n        nextPosMap.maxIndex = j + nums[j];\n      }\n    }\n    // index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index\n    // 其实肯定更新, 题目已经说了能跳到最后\n    // 移动才算跳了一步\n    // 同时能跳到的最远位置不要超过数组边界\n    // 超过数组边界则表示步数已经能计算出来了 return\n    if (nextPosMap.maxIndex < len - 1) {\n      i = nextPosMap.index;\n    } else {\n      // 当最大位置能到达最后时, 返回step+1\n      // 把跳到最后位置的一步也加上\n      return step + 1;\n    }\n  }\n};\n```\n\n\n\n#### [55] Jump Game\n\n> Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n> Each element in the array represents your maximum jump length at that position.\n>\n> Determine if you are able to reach the last index.\n\n\n\n一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.\n\n于是就去看网上解法, 这里的考点是**贪心算法**.\n\n> 贪心算法（又称贪婪算法）是指，在对[问题求解](https://baike.baidu.com/item/问题求解/6693186)时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解\n\n\n\n该题的大概思路是:\n\n数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.\n\n![largen-reach](Greedy-Algorithm/largen-reach.png)\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\n// 递归超时 使用贪心算法求解\n// 局部能够到达的最大范围, 也是全局能够到达的最大范围\nvar canJump = function (nums) {\n  let reach = nums[0];\n  // 需要注意的点是,这里reach的值不一定就>1, 所以i不一定就从1开始\n  // 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]\n  // 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach\n  for (let i = 0; i < nums.length && i <= reach; i++) {\n    if (nums[i] + i > reach) {\n      reach = nums[i] + i;\n      // console.log(reach);\n    }\n    // 当能到达的范围超过数组的最后 index 时, 返回 true\n    if (reach >= nums.length - 1)\n      return true\n  }\n  // 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素\n  return false\n};\n```\n\n\n\n","slug":"Greedy-Algorithm","published":1,"updated":"2020-10-29T10:57:39.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafq000bmm9h2zzw2zia","content":"<h4 id=\"45-Jump-Game-II\"><a href=\"#45-Jump-Game-II\" class=\"headerlink\" title=\"[45] Jump Game II\"></a>[45] Jump Game II</h4><blockquote>\n<p> Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p> Each element in the array represents your maximum jump length at that position.</p>\n<p> Your goal is to reach the last index in the minimum number of jumps.</p>\n</blockquote>\n<p>贪心算法, 局部解得到最优解.</p>\n<p>解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.</p>\n<p>但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.</p>\n<img src=\"/2020/08/03/Greedy-Algorithm/45_fig1.png\" class=\"\" title=\"45_fig1\">\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于当前index, 每次在能跳到的范围内</span></span><br><span class=\"line\"><span class=\"comment\">// 跳到能跳到更远地方的index</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jump = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[<span class=\"number\">0</span>] &gt;= len - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> step = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextPosMap = &#123; <span class=\"string\">'index'</span>: <span class=\"number\">0</span>, <span class=\"string\">'maxIndex'</span>: <span class=\"number\">0</span> + nums[<span class=\"number\">0</span>] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> indexLimit = i + nums[i];</span><br><span class=\"line\">    <span class=\"comment\">// 在寻找下一步跳的位置时, 步数加一</span></span><br><span class=\"line\">    step++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt;= indexLimit &amp;&amp; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j + nums[j] &gt; nextPosMap.maxIndex) &#123;</span><br><span class=\"line\">        nextPosMap.index = j;</span><br><span class=\"line\">        nextPosMap.maxIndex = j + nums[j];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index</span></span><br><span class=\"line\">    <span class=\"comment\">// 其实肯定更新, 题目已经说了能跳到最后</span></span><br><span class=\"line\">    <span class=\"comment\">// 移动才算跳了一步</span></span><br><span class=\"line\">    <span class=\"comment\">// 同时能跳到的最远位置不要超过数组边界</span></span><br><span class=\"line\">    <span class=\"comment\">// 超过数组边界则表示步数已经能计算出来了 return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextPosMap.maxIndex &lt; len - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      i = nextPosMap.index;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当最大位置能到达最后时, 返回step+1</span></span><br><span class=\"line\">      <span class=\"comment\">// 把跳到最后位置的一步也加上</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> step + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"55-Jump-Game\"><a href=\"#55-Jump-Game\" class=\"headerlink\" title=\"[55] Jump Game\"></a>[55] Jump Game</h4><blockquote>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p>Each element in the array represents your maximum jump length at that position.</p>\n<p>Determine if you are able to reach the last index.</p>\n</blockquote>\n<p>一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.</p>\n<p>于是就去看网上解法, 这里的考点是<strong>贪心算法</strong>.</p>\n<blockquote>\n<p>贪心算法（又称贪婪算法）是指，在对<a href=\"https://baike.baidu.com/item/问题求解/6693186\" target=\"_blank\" rel=\"noopener\">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</p>\n</blockquote>\n<p>该题的大概思路是:</p>\n<p>数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.</p>\n<img src=\"/2020/08/03/Greedy-Algorithm/largen-reach.png\" class=\"\" title=\"largen-reach\">\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 递归超时 使用贪心算法求解</span></span><br><span class=\"line\"><span class=\"comment\">// 局部能够到达的最大范围, 也是全局能够到达的最大范围</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> canJump = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> reach = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"comment\">// 需要注意的点是,这里reach的值不一定就&gt;1, 所以i不一定就从1开始</span></span><br><span class=\"line\">  <span class=\"comment\">// 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]</span></span><br><span class=\"line\">  <span class=\"comment\">// 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length &amp;&amp; i &lt;= reach; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] + i &gt; reach) &#123;</span><br><span class=\"line\">      reach = nums[i] + i;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(reach);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当能到达的范围超过数组的最后 index 时, 返回 true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reach &gt;= nums.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"45-Jump-Game-II\"><a href=\"#45-Jump-Game-II\" class=\"headerlink\" title=\"[45] Jump Game II\"></a>[45] Jump Game II</h4><blockquote>\n<p> Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p> Each element in the array represents your maximum jump length at that position.</p>\n<p> Your goal is to reach the last index in the minimum number of jumps.</p>\n</blockquote>\n<p>贪心算法, 局部解得到最优解.</p>\n<p>解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.</p>\n<p>但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.</p>\n<img src=\"/2020/08/03/Greedy-Algorithm/45_fig1.png\" class=\"\" title=\"45_fig1\">\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于当前index, 每次在能跳到的范围内</span></span><br><span class=\"line\"><span class=\"comment\">// 跳到能跳到更远地方的index</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jump = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[<span class=\"number\">0</span>] &gt;= len - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> step = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextPosMap = &#123; <span class=\"string\">'index'</span>: <span class=\"number\">0</span>, <span class=\"string\">'maxIndex'</span>: <span class=\"number\">0</span> + nums[<span class=\"number\">0</span>] &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> indexLimit = i + nums[i];</span><br><span class=\"line\">    <span class=\"comment\">// 在寻找下一步跳的位置时, 步数加一</span></span><br><span class=\"line\">    step++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt;= indexLimit &amp;&amp; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j + nums[j] &gt; nextPosMap.maxIndex) &#123;</span><br><span class=\"line\">        nextPosMap.index = j;</span><br><span class=\"line\">        nextPosMap.maxIndex = j + nums[j];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index</span></span><br><span class=\"line\">    <span class=\"comment\">// 其实肯定更新, 题目已经说了能跳到最后</span></span><br><span class=\"line\">    <span class=\"comment\">// 移动才算跳了一步</span></span><br><span class=\"line\">    <span class=\"comment\">// 同时能跳到的最远位置不要超过数组边界</span></span><br><span class=\"line\">    <span class=\"comment\">// 超过数组边界则表示步数已经能计算出来了 return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextPosMap.maxIndex &lt; len - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      i = nextPosMap.index;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当最大位置能到达最后时, 返回step+1</span></span><br><span class=\"line\">      <span class=\"comment\">// 把跳到最后位置的一步也加上</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> step + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"55-Jump-Game\"><a href=\"#55-Jump-Game\" class=\"headerlink\" title=\"[55] Jump Game\"></a>[55] Jump Game</h4><blockquote>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p>Each element in the array represents your maximum jump length at that position.</p>\n<p>Determine if you are able to reach the last index.</p>\n</blockquote>\n<p>一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.</p>\n<p>于是就去看网上解法, 这里的考点是<strong>贪心算法</strong>.</p>\n<blockquote>\n<p>贪心算法（又称贪婪算法）是指，在对<a href=\"https://baike.baidu.com/item/问题求解/6693186\" target=\"_blank\" rel=\"noopener\">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</p>\n</blockquote>\n<p>该题的大概思路是:</p>\n<p>数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.</p>\n<img src=\"/2020/08/03/Greedy-Algorithm/largen-reach.png\" class=\"\" title=\"largen-reach\">\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 递归超时 使用贪心算法求解</span></span><br><span class=\"line\"><span class=\"comment\">// 局部能够到达的最大范围, 也是全局能够到达的最大范围</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> canJump = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> reach = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"comment\">// 需要注意的点是,这里reach的值不一定就&gt;1, 所以i不一定就从1开始</span></span><br><span class=\"line\">  <span class=\"comment\">// 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]</span></span><br><span class=\"line\">  <span class=\"comment\">// 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length &amp;&amp; i &lt;= reach; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] + i &gt; reach) &#123;</span><br><span class=\"line\">      reach = nums[i] + i;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(reach);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当能到达的范围超过数组的最后 index 时, 返回 true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reach &gt;= nums.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Linked-list","abbrlink":34403,"date":"2020-09-11T06:57:16.000Z","description":"链表相关题解","_content":"\n\n\n#### [2] Add Two Numbers\n\n> You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n>\n> You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n复杂的数据结构是我的超级短板. 但是也算勉强看懂了js是如何表示链表的.\n\n```javascript\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\n// 这个链表的存储结构是嵌套的, 即next指向的是嵌套的.\nvar addTwoNumbers = function (l1, l2) {\n  // 定义存储想关节点的变量\n  let result = new ListNode(null);\n  let lastNode = result;\n  let carry = 0; // 进位\n  let val = 0; // 相加之后赋给当前位置的值\n  // 当l1或者l2任何一方有值时, 都需要进行相加\n  while (l1 || l2) {\n    // 获取两个链表的初始值\n    let x = l1 == null ? 0 : l1.val;\n    let y = l2 == null ? 0 : l2.val;\n    // 两者相加\n    let num = x + y + carry;\n    carry = Math.floor(num / 10); // 商\n    val = num % 10; // 相加之后赋给当前位置的值\n    // 新建节点添加到链表末尾\n    lastNode.next = new ListNode(val);\n    // 最后节点位置更新\n    lastNode = lastNode.next;\n    // 进行下一位置的加法\n    if (l1 !== null) l1 = l1.next;\n    if (l2 !== null) l2 = l2.next;\n  }\n  // 当两个加数位数都加完了\n  // 但是仍然可能会有进位的可能\n  if (carry != 0) {\n    lastNode.next = new ListNode(carry);\n  }\n  return result.next;\n};\n\n/*\n示例结果\n====result.next\nListNode {\n  val: 7,\n  next: ListNode {\n    val: 0,\n    next: ListNode {\n      val: 8,\n      next: null\n    }\n  }\n}\n*/\n```\n\n\n\n#### [21] Merge Two Sorted Lists\n\n> Merge two sorted linked lists and return it as a new **sorted** list. The new list should be made by splicing together the nodes of the first two lists.\n\n解题的重点在于, 一直将l1和l2的链表头作比较, 不断将较小的node加入结果链表, 直至l1或者l2为空, 说明遍历结束. 把不为空的链表剩余的部分直接接入结果列表.\n\n```javascript\nvar mergeTwoLists = function (l1, l2) {\n  // 处理有链表为空的情况\n  if (l1 == null) {\n    return l2;\n  }\n  if (l2 == null) {\n    return l1\n  }\n  let res = new ListNode(null);\n  let curr = res;\n  // 网上的做法好简洁\n  while (l1 && l2) {\n    if (l1.val > l2.val) {\n      curr.next = l2;\n      l2 = l2.next;\n    } else {\n      curr.next = l1;\n      l1 = l1.next;\n    }\n    curr = curr.next;\n  }\n  curr.next = l1 == null ? l2 : l1;\n  return res.next;\n};\n```\n\n\n\n#### [24] Swap Nodes in Pairs\n\n> Given a linked list, swap every two adjacent nodes and return its head.\n>\n> You may **not** modify the values in the list's nodes, only nodes itself may be changed.\n\n在交换链表的时候, 第一次交换需要记住链表头.\n\n确定 `curr` 之后, 只有 `curr.next!=null` 时才有交换的必要, 否则说明交换到头了, 返回 `head` 即可.\n\n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  let curr = head;\n  let left = new ListNode(null);\n  let i = 0; // 第一次交换的时候 需要记住链表头 后面就不需要了\n  // 只有当 curr.next 也有值的时候, 才交换\n  // 否则就直接返回\n  while (curr && curr.next) {\n    let temp = curr.next.next;\n    let nextNode = curr.next;\n    nextNode.next = curr;\n    left.next = nextNode;\n    curr.next = temp;\n    left = curr;\n    curr = curr.next;\n    if (i == 0)\n      head = nextNode;\n    i++;\n  }\n  return head;\n};\n```\n\n\n\n#### [61] Rotate List\n\n> Given a linked list, rotate the list to the right by *k* places, where *k* is non-negative.\n\n```javascript\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n * 大体思路是: \n * 先计算出链表的长度len, 再将k与len进行比较, \n * k>len的话, 将k中len的整数倍减去之后, 就是最后需要移动的元素的个数\n */\n\nvar rotateRight = function (head, k) {\n  if (head == null) {\n    return null;\n  }\n  // 计算链表长度\n  // 此时right指向最后一个元素\n  let left = head, right = head, len = 1;\n  while (right.next) {\n    right = right.next;\n    len++;\n  }\n  if (len == 1 || k == len) {\n    return head;\n  }\n  // 取余之后是实际上需要移动的元素\n  let num = k % len;\n  // 由于在计算链表长度的时候, right已经指向链表尾部\n  // 左右指针间隔k-1个元素\n  // 所以左指针需要向右移动len-num-1个位置\n  // 具体的边界条件可以在测试中验证是否正确\n  for (let i = 0; i < len - num - 1; i++) {\n    left = left.next;\n  }\n  right.next = head;\n  head = left.next;\n  left.next = null;\n  return head;\n};\n```\n\n\n\n#### [23] Merge k Sorted Lists\n\n> You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n>\n> *Merge all the linked-lists into one sorted linked-list and return it.*\n\n**solution1** 的时间复杂度分析:\n\n时间复杂度: 遍历链表+排序+遍历数组\n\t假设总node数为 $N$ , 则总时间复杂度为 $O(N)+O(NlogN)+O(N)=O(N)$\n空间复杂度为: $O(N)$ , 主要是存储节点的数组的消耗\n\n**solution2** 的时间复杂度分析:\n\n设k=lists.length, $N$ 为所有节点数, 则复杂度为=归并次数*每一次归并的时间复杂度\n每一次归并需要遍历所有的节点, 但是不需要排序, 仅仅是大小比较, $O(N)$\n设一共归并的次数为x, 则有 $2^x = k$ , 则 $ x = \\log_2 k$ (以2为底k的对数)\n所以总共的时间复杂度是 $\\sum_0^x * O(N)=O(N\\log k)$\n\n```javascript\n// solution 1\n// 把链表中的节点值都拿出来放在一个数组里\n// 然后对数组进行排序\nvar mergeKLists1 = function (lists) {\n\n  let len = lists.length;\n  if (len == 0) {\n    return null\n  }\n  let arr = [], l;\n  for (let i = 0; i < len; i++) {\n    l = lists[i];\n    while (l) {\n      arr.push(l.val);\n      l = l.next;\n    }\n  }\n  arr.sort((a, b) => a - b); // 正序排列\n  let res = new ListNode(null);\n  let curr = res;\n  for (let i = 0; i < arr.length; i++) {\n    curr.next = new ListNode(arr[i]);\n    curr = curr.next;\n  }\n  return res.next;\n};\n\n// solution 2\n// 分治算法 这是一开始就想到的方法 但是不会实现🤦‍♀️\n// 两两链表合并排序, 再将结果再合并, 直至只有一个结果\n// 数组长度为奇数, 最后一次合并时, 是第一个与最后一个元素合并, interval*2之后会<len, 继续进行最后一次合并\n// 数组长度为奇数, 最后一次合并时, 是第一个与中间元素合并, interval*2之后会=len, 跳出循环\nvar mergeKLists = function (lists) {\n  let len = lists.length;\n  // 没有链表返回空链表\n  if (len == 0) {\n    return null;\n  }\n  let interval = 1;// 标志需要合并的两个链表之间的距离\n  // 归并排序的代码更像模板\n  // 只要两个元素之间的距离没有超过数组长度, 说明没有归并完毕\n  while (interval < len) {\n    for (let i = 0; i < len - interval; i = i + interval * 2) {\n      // i的作用是, 找到所有需要合并的链表中的第一个\n      // 不断地把相隔interval距离的两个链表合并\n      lists[i] = mergeTwoLists(lists[i], lists[i + interval])\n    }\n    interval = interval * 2;\n  }\n  return lists[0];\n}\n\n// 合并两个链表\nvar mergeTwoLists = (l1, l2) => {\n  if (!l1) return l2;\n  if (!l2) return l1;\n  let res = new ListNode(null);\n  let curr = res;\n  while (l1 && l2) {\n    if (l1.val < l2.val) {\n      curr.next = l1;\n      l1 = l1.next;\n    } else {\n      curr.next = l2;\n      l2 = l2.next;\n    }\n    curr = curr.next;\n  }\n  curr.next = l1 == null ? l2 : l1;\n  return res.next;\n}\n```\n\n\n\n#### [25] Reverse Nodes in k-Group\n\n> Given a linked list, reverse the nodes of a linked list *k* at a time and return its modified list.\n>\n> *k* is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of *k* then left-out nodes in the end should remain as it is.\n\n时间复杂度分析:\n\n$O(N)$ , $N$为链表总节点数, 翻转时需要遍历所有的节点. 一共会进行$\\lfloor N/k \\rfloor$ 次翻转, 每一次翻转需要$O(k)$的时间.\n\n空间复杂度: 常量级别.\n\n```javascript\n// 大体思路是 每k个元素进行一次翻转\n// 在翻转之前查看接下来的链表长度是否足够\n// 足够则翻转 不够则停下并返回结果\n// 翻转时注意连接前后链表的部分\nvar reverseKGroup = function (head, k) {\n  // 在链表头节点前加一个节点\n  // 后面翻转后的链表再与原来的链表连接要用到\n  let hair = new ListNode(null, head);\n  let pre = hair;\n  // tail需要以pre为起点, 向后移动k个位置\n  let tail = hair, right;\n  while (tail) {\n    // 将 tail 移动至需要翻转的链表部分的末尾\n    for (let i = 0; i < k; i++) {\n      tail = tail.next;\n      // 如果 tail 在向后移动但是还没有到目标位置时\n      // 出现 tail 为 null 的情况\n      // 说明剩余的元素已经不够翻转的数量\n      // 直接返回现有结果即可\n      if (!tail) return hair.next;\n    }\n    // head-tail的链表部分需要翻转\n    // 且翻转需要head和tail仍指向翻转后链表的头和尾\n    // 保留tail的后面部分\n    right = tail.next;\n    [head, tail] = reverse(head, tail);\n    // 进行与原链表的拼接\n    pre.next = head;\n    tail.next = right;\n    // 改变pre head的位置\n    pre = tail;\n    head = right;\n  }\n  return hair.next;\n};\n\n// 翻转链表\n// 这里不用再初始化res来存储翻转后的结果\n// 因为tail.next是存在的\n// 可以看做已有的res使用\n// 使用常数级的内存空间\nvar reverse = (head, tail) => {\n  let p = head;\n  let remain = tail.next; // 表示剩余不用翻转的部分\n  let nex;\n  while (p !== tail) {\n    nex = p.next;\n    p.next = remain;\n    remain = p;\n    p = nex;\n  }\n  tail.next = remain;\n  return [tail, head];\n}\n```\n\n\n\n#### [83] Remove Duplicates from Sorted List\n\n> Given a sorted linked list, delete all duplicates such that each element appear only *once*.\n\n思路比较简单, 由于最坏情况是遍历链表的所有节点(当所有节点的值均不相同),  时间复杂度为 $O(N)$ .\n\n```javascript\n// 由于是排过序的链表\n// 所以重复元素都会在一块\n// 不断比较curr与curr.next的val是否相等\n// 相等则跳过该重复元素,不等才改变curr的位置\n// 直至curr遍历完链表的所有元素\nvar deleteDuplicates = function (head) {\n  if (!head) return null;\n  let curr = head;\n  while (curr) {\n    // 最后一个元素是不同元素 到达链表末尾\n    if (!curr.next) return head;\n    while (curr.val == curr.next.val) {\n      curr.next = curr.next.next;\n      // 最后一个元素是相同元素 到达链表末尾\n      if (!curr.next) {\n        return head;\n      }\n    }\n    curr = curr.next;\n  }\n};\n```\n\n\n\n#### [82] Remove Duplicates from Sorted List II\n\n> Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only *distinct* numbers from the original list.\n>\n> Return the linked list sorted as well.\n\n遍历链表的所有节点两次,  时间复杂度为 $2*O(N) = O(N)$ .\n\n```javascript\n// 遍历两次链表\n// 第一次按照顺序将所有不同的元素组成链表, 并给有重复元素的节点增加dup属性\n// 第二次将有dup属性的节点删除, 返回结果\nvar deleteDuplicates = function (head) {\n  let curr = head;\n  while (curr) {\n    if (!curr.next) break;\n    while (curr.val == curr.next.val) {\n      curr.dup = true;\n      curr.next = curr.next.next;\n      if (!curr.next) break;\n    }\n    curr = curr.next;\n  }\n  if (!head) return null;\n\n  let hair = new ListNode(null, head);\n  let pre = hair, point = head;\n  while (point) {\n    while (point.dup) {\n      point = point.next;\n      if (!point) {\n        pre.next = null;\n        return hair.next;\n      }\n    }\n    pre.next = point;\n    pre = point;\n    point = point.next;\n  }\n  return hair.next;\n};\n```\n\n\n\n#### [142] Linked List Cycle II\n\n> Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n>\n> There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n>\n> **Notice** that you **should not modify** the linked list.\n\n这里需要证明下有环情况下, 为什么快慢指针第一次相遇之后, 快指针到链表头, 再和慢指针一起以每次一步的速度前进, 当二者相等时, 即是环的起点.\n\n**证明**:\n\n![image.png](Linked-list/image.png)\n\n我们最终需要证明a=b. 假设链表总长度为L, 环的长度为R, 快慢指针第一次相遇的节点为M, 环的开始节点为C, 其中各个点之间的距离分别为 H->C=a, C->M=c, M->C=b, H->M=s. 第一次相遇时, 假设fast已经围绕着环走了n圈, 则有:\n\n由于快慢指针的速度差两倍, 所以相同时间内, 快指针走过的距离是慢指针的两倍.\n\n$2s = s + nR \\\\-> s = nR \\tag{1}$\n\n已知慢指针走的长度为(套用$(1)$):\n\n$a+c = s \\\\-> a+c=nR \\\\-> a + c = (n-1)R + R \\\\-> a = (n-1)R + (R - c) \\\\->  a = (n-1)R +b$\n\n则得出结论 $a=b$, (这个还要再想下).\n\n所以fast移动到head, slow位置不变, 两个同时开始走, 每次走一步, 当走了a步时,两者相遇的点即为环的起点.\n\n\n\n**时间复杂度**:\n\n可知快慢指针走的步数是一样的, 只是一个快一个慢, 慢指针最后遍历了整个链表, 走了N步, 则快指针也走了N步, 则时间复杂度为: $2*O(N)= O(N)$.\n\n```javascript\n// 使用快慢指针\nvar detectCycle = function (head) {\n  if (!head || !head.next) return null;\n  // 快慢指针的起始点应该一样\n  let fast = head;\n  let slow = head;\n  while (slow) {\n    // 快指针的速度是慢指针的2倍\n    slow = slow.next;\n    // 在没有环的情况下\n    // fast指针会最先到达链表尾部, 直接返回null;\n    // fast指针最后的位置,要不倒数第一,要不倒数第二\n    // 与链表长度的奇偶数以及每次走的步数有关\n    // 这里fast指针是每次走两步\n    if (!fast.next) return null\n    fast = fast.next.next;\n    if (!fast) return null\n    // 说明有环 两指针第一次相遇\n    if (fast == slow) {\n      // 快指针移动至链表头\n      // 慢指针停在原地\n      fast = head;\n      // 二者均以每次一步的速度继续向前走, 直至再次相遇\n      // 这里方法需要证明\n      while (fast != slow) {\n        fast = fast.next;\n        slow = slow.next;\n      }\n      // 返回的是环的起始节点的指针\n      return fast;\n    }\n  }\n};\n```\n\n\n\n#### [138] Copy List with Random Pointer\n\n> A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\n>\n> Return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the list.\n>\n> The Linked List is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where:\n>\n> - `val`: an integer representing `Node.val`\n> - `random_index`: the index of the node (range from `0` to `n-1`) where random pointer points to, or `null` if it does not point to any node.\n\n**时间复杂度:** 遍历两遍数组 $O(N)$.\n\n**经验/收获**: \n\n1. 一开始我的问题在于试错, 都没有搞清楚`random_index`属性是否在题目给的链表结构中存在, 我还以为有`random_index`这个属性呢, 实际上没有.  `random`数据类型仍然是指针而非number.\n2. 搞清楚题目是深拷贝, 不能改变原有链表结构. **需要重新生成新链表**.\n3. 收获在于知道如何使用hashMap存储链表间的 links.\n\n```javascript\n// 题目要求是深拷贝\n// 就是不改变原有的链表\n// 第一遍是copy all nodes, 使用map存储\n// 第二遍是copy links\nvar copyRandomList = function (head) {\n  if (!head) return null;\n  // copy nodes\n  let curr = head;\n  let map = new Map(); // map的key可以是任何对象, 不限于字符串\n  while (curr) {\n    map.set(curr, new Node(curr.val));\n    curr = curr.next;\n  }\n  // copy links\n  curr = head;\n  let node = map.get(curr);\n  while (curr) {\n    node.next = curr.next ? map.get(curr.next) : null;\n    node.random = curr.random ? map.get(curr.random) : null;\n    curr = curr.next;\n    node = node.next;\n  }\n  return map.get(head);\n};\n```\n\n\n\n#### [92] Reverse Linked List II\n\n> Reverse a linked list from position *m* to *n*. Do it in one-pass.\n>\n> **Note:** 1 ≤ *m* ≤ *n* ≤ length of list.\n\n**时间复杂度分析**:\n\n假设链表总长度为$N$, 在定位m/n节点的过程中, 一共遍历链表一次, 每次遍历至第n个节点, 最差情况遍历到链表末尾.\n\n翻转时一共需要翻转 $n-m+1$ 个节点, 需要的时间是 $ O(n-m+1)$ .\n\n所以时间复杂度为 $O(N)$ \n\n**注意**:\n\n初始化一个节点时, hair不是空, hair.val是空. 刚开始判断pre==null就写错了, 应该是pre.val是否null.\n\n```javascript\nvar reverseBetween = function (head, m, n) {\n  // 特殊情况\n  if (!head) return null\n  if (!head.next) return head;\n  // 当链表长度足够翻转时, 在head前添加hair节点\n  // 为了使用pre节点, pre是pm的前一个节点\n  let hair = new ListNode(null, head);\n  let pre = hair, curr = head;\n  // 定义变量 注意需要tail指针\n  let pm, pn, tail;\n\n  // 定位m节点\n  if (m == 1) {\n    pm = head; // pm直接是头节点\n  } else {\n    // m-1次循环到达pm节点\n    for (let i = 0; i < m - 1; i++) {\n      // pre节点也需要同时向后移动\n      // 保证在pm前一位\n      curr = curr.next;\n      pre = pre.next;\n    }\n    pm = curr;\n  }\n  // 定位n节点\n  for (let i = 0; i < n - m; i++) {\n    curr = curr.next;\n  }\n  pn = curr;\n  // 翻转前保留尾部数据\n  tail = curr.next;\n  // 翻转\n  while (pm != pn) {\n    let temp = pm.next;\n    pm.next = tail;\n    tail = pm;\n    pm = temp;\n    pre.next = tail;\n  }\n  // pm==pn时还需要连接下tail\n  pm.next = tail;\n  // 连接\n  pre.next = pm;\n  // 这里返回hair.next即可\n  // 不用分析pre是否为空\n  return hair.next;\n};\n```\n\n\n\n#### [147] Insertion Sort List\n\n> Sort a linked list using insertion sort.\n\n时间复杂度分析:\n\n遍历链表一次, $O(N)$\n\n每到链表的一个节点, 就会扫描排好序的链表部分, 时间为 $O(1)+O(2)+O(3)+...+O(N-1)$\n\n则时间复杂度为: $O(1)+O(2)+...+O(N)=O((N^2+N)/2)=O(N^2)$\n\n```javascript\n// 使用插入排序对链表进行排序\n// 插入排序是: 不断将没有排序的元素加入已经排好序的部分\n// 单向链表只能从前往后遍历\n// 这里顺便学习了单向链表\nvar insertionSortList = function (head) {\n  if (!head) return null;\n  if (!head.next) return head;\n  // 第一个元素默认已经排好序\n  // curr 从下一位开始\n  let curr = head.next;\n  // 初始化\n  // 排好序的部分此时只有head一个元素\n  // 末尾指向null\n  // 与需要排序的部分分开\n  head.next = null;\n  let cn, hn;\n  while (curr) {\n    // 保留curr的后一部分\n    cn = curr.next;\n    // curr比有序的第一个元素小\n    // 则直接置于有序部分的头部\n    if (curr.val <= head.val) {\n      curr.next = head;\n      head = curr;\n    } else {\n      // curr 比第一个有序元素大\n      // 则需要遍历后面的有序元素\n      // 直到找到有序排列中比curr大的元素x\n      // 则curr插入到 x的前面\n      // 为了保留 x 的前一个节点\n      // 将curr.val与h.next.val进行比较, 而不是h.val\n      let h = head;\n      while (h.next && curr.val > h.next.val) {\n        h = h.next;\n      }\n      // 将curr插入至 h 与 x 节点之间\n      hn = h.next;\n      h.next = curr;\n      curr.next = hn;\n    }\n    // curr向后移动一位\n    curr = cn;\n  }\n  return head;\n};\n```\n\n\n\n#### [203] Remove Linked List Elements\n\n> Remove all elements from a linked list of integers that have value ***val\\***.\n\n时间复杂度: 遍历链表 $O(N)$\n\n```javascript\nvar removeElements = function (head, val) {\n  if (!head) return null;\n  let hair = new ListNode(null, head);\n  let pre = hair, curr = head;\n  // pre的移动也是在head表示的这条链表上\n  // pre改变的是head本身\n  while (curr) {\n    if (curr.val == val) {\n      pre.next = curr.next;\n    } else {\n      pre = curr;\n    }\n    curr = curr.next;\n  }\n  // 有个特殊情况需要注意\n  // 比如 [1] 1\n  // 此时pre还没后移到head链表上\n  // 所以pre指向null没有改变head链表\n  // head仍然是 [1]\n  return hair.next;\n};\n```\n\n\n\n#### [206] Reverse Linked List\n\n> Reverse a singly linked list.\n>\n> **Follow up:**\n>\n> A linked list can be reversed either iteratively or recursively. Could you implement both?\n\n**递归过程**需要详细的过程分析图(**TO DO**).\n\n两种时间复杂度均为 $O(N)$. \n\n递归方法的时间复杂度分析: 遍历整个链表, 递归调用N次.\n\n```javascript\n// 迭代翻转\n// 空间复杂度 O(1)\nvar reverseList1 = function (head) {\n  let rever = new ListNode(null);\n  let temp;\n  while (head) {\n    temp = head.next;\n    head.next = rever.next;\n    rever.next = head;\n    head = temp;\n  }\n  return rever.next;\n};\n\n// 递归翻转\n// 需要注意的是, p是指向head的一个指针\n// 并不是另外的链表\n// 但是由于每一次都会生成p指针重新指向目前已经倒好序的链表\n// 所以递归过程中的空间复杂度为O(1)+O(2)+...+O(N)=O(N)\nvar reverseList = function (head) {\n  if (!head || !head.next) return head;\n  let p = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n  return p;\n};\n```\n\n\n\n#### [237] Delete Node in a Linked List\n\n> Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.\n>\n> It is **guaranteed** that the node to be deleted is **not a tail node** in the list.\n\n注意看题目条件, 时间/空间复杂度均为 $O(N)$.\n\n```javascript\n// 一时没有想起来用什么解法\n// 因为之前删除节点都是不能改变节点自身的值\n// 现在这个能改变了 害\n// 这个方法令我哭笑不得, 也提醒自己注意看题目条件\nvar deleteNode = function(node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n};\n```\n\n\n\n#### [234] Palindrome Linked List\n\n> Given a singly linked list, determine if it is a palindrome.\n>\n> **Follow up:**\n> Could you do it in O(n) time and O(1) space?\n\n时间复杂度: \n\n遍历链表一次, $O(N)$, 后半部分翻转链表的时候, 时间为$O(N/2)$.\n\n所以时间复杂度为: $O(N)+O(N/2)=O(N)$.\n\n方法:\n\n判断回文链表,要求只能遍历一次链表.\n\n将链表**后半段翻转** 再将前后部分分别比较.\n\n然后还有需要注意的是: **快慢指针法寻找链表中心点**\n\n```javascript\nvar isPalindrome = function (head) {\n  if (!head || !head.next) return true;\n  let fast = head, slow = head;\n  while (fast.next && fast.next.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  // 不管链表长度是奇数还是偶数 需要进行的操作都是一样的\n  // slow 为后半部分链表的起点\n  slow.next = reverse(slow.next);\n  slow = slow.next;\n  // 将前后两部分链表逐个节点对值进行比较\n  // 如果有值不等 说明不是回文\n  // 前半部分的长度是>=后半部分的\n  // 所以当slow=null时, head=null或者head是最后一个节点\n  // 由于回文的两种形式, 此时就可以结束比较了\n  while (slow) {\n    if (head.val != slow.val) {\n      return false;\n    }\n    head = head.next;\n    slow = slow.next;\n  }\n  return true;\n};\n\n// 翻转链表\nvar reverse = (head) => {\n  let res = new ListNode(null);\n  let curr = head, cn, rn;\n  while (curr) {\n    cn = curr.next;\n    rn = res.next;\n    res.next = curr;\n    curr.next = rn;\n    curr = cn;\n  }\n  return res.next;\n}\n```\n\n\n\n#### [160] Intersection of Two Linked Lists\n\n> Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n> **Notes:**\n>\n> - If the two linked lists have no intersection at all, return `null`.\n> - The linked lists must retain their original structure after the function returns.\n> - You may assume there are no cycles anywhere in the entire linked structure.\n> - Each value on each linked list is in the range `[1, 10^9]`.\n> - Your code should preferably run in O(n) time and use only O(1) memory.\n\n![image1.png](Linked-list/image1.png)\n\n由图可知:\n\n$headA = A + C$\n\n$headB = B + C$\n\n所以:\n\n$newA = headA + headB = A + C + B + C$\n\n$newB = headB + headA = B + C + A + C$\n\n已知:\n\n$A + C + B = B + C + A$\n\n所以 `newA`与`newB`同时出发, 每次都走一步. \n\n`newA`走完`headA`再走完`B`,  `newB`走完`headB`再走完`A`, 如果两者有交点, 则此时会相等且不为`null`;\n\n如果不相交, 则走到最后两者也相等, 但是为`null`.\n\n时间复杂度:\n\n假设`headA`和`headB`总共的长度为`N`, 则一共遍历了两次, 时间为$2*O(N)$, 时间复杂度为$O(N)$.\n\n```javascript\n// 思路很巧妙 需要分析下 最后两个节点一定会相等\n// 只是是地址还是null的问题\n// 最差情况是不相交\n// 每个链表均遍历了两遍\n// 但是额外空间只使用了两个指针变量,为常数级\nvar getIntersectionNode = function (headA, headB) {\n  let currA = headA, currB = headB;\n  while (currA != currB) {\n    currA = !currA ? headB : currA.next;\n    currB = !currB ? headA : currB.next;\n  }\n  // 不相交最后也会相等的 均是null\n  // 即： 相交或者是不相交， 二者均会相等\n  // 相等的话，返回的是及交点地址\n  // 不相等的话，返回的是null\n  return currA;\n};\n```\n\n\n\n#### [328] Odd Even Linked List\n\n> Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\n>\n> You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\n\n时间复杂度: 两个指针同时遍历, 一共遍历一遍链表. $O(N)$\n\n空间复杂度: 只是新建了两个指针, 改动原有链表, 没有重新生成head的copy版本. $O(1)$\n\n```javascript\n// 完全自己想的法子 太棒了\n// 大体思路就是,用两个指针, 一个指向奇数节点, 一个指向偶数节点\n// 遍历完head之后, 再将两个链表进行拼接\nvar oddEvenList = function (head) {\n  if (!head || !head.next || !head.next.next) return head;\n  let oddList = new ListNode(null);\n  let evenList = new ListNode(null);\n  let odd = oddList, even = evenList;\n  // 初始化第一个奇数节点\n  odd.next = head;\n  odd = odd.next;\n  // 初始化第一个偶数节点\n  even.next = head.next;\n  even = even.next;\n  while (even && even.next) {\n    odd.next = odd.next.next;\n    odd = odd.next;\n    even.next = even.next.next;\n    even = even.next;\n    // 链表长度为奇数 此时 even==null\n    // 链表长度为偶数 此时 even.next==null\n    // 两种情况的任何一种情况都应该退出循环\n  }\n  // 对奇数链与偶数链进行拼接\n  odd.next = evenList.next;\n  return oddList.next;\n};\n```\n\n\n\n#### [725] Split Linked List in Parts\n\n> Given a (singly) linked list with head node `root`, write a function to split the linked list into `k` consecutive linked list \"parts\".\n>\n> The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.\n>\n> The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n>\n> Return a List of ListNode's representing the linked list parts that are formed.\n>\n> Examples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]\n\n理解题意 一共分为 k 部分 而不是长度是 k !!\n\n*时间复杂度**:\n\n在计算链表长度时, 遍历了一次. 后面将链表片段加入时, 又遍历了一遍.\n\n所以时间复杂度为 $O(N+k)$, 在`k>len`时, 需要继续向结果中加入片段.\n\n**空间复杂度**:\n\n生成`answer`时res数组中包含的节点个数, `k>len`, k个链表节点, 反之, len个链表节点. 所以空间复杂度为$O(max(N, k))$.\n\n```javascript\nvar splitListToParts = function (root, k) {\n  // 先计算root的长度\n  let curr = root, len = 0;\n  while (curr) {\n    len++;\n    curr = curr.next;\n  }\n  curr = root;\n  // 计算宽度\n  let width = Math.floor(len / k);\n  let extra = len % k; // 需要长度被加一的组数\n  let res = []; // 初始化长度为k的结果数组\n  for (let i = 0; i < k; i++) {\n    // 当k<=len的时候,curr指向null时, for循环也就结束了\n    // 因为组数已经达到了k组\n    // 出现curr为null的情况时, 并且走到了这里\n    // 说明k>len\n    // 此时只需要将null不断加入数组直至数组长度达到k\n    if (!curr) {\n      res.push(null);\n      continue;\n    }\n    // 多余没有入组的元素需要加入前面的每一个组\n    // 因此前extra组, 每组的元素长度需要+1\n    let l = i < extra ? width + 1 : width;\n    // l-1是为了控制curr指向part的最后一个元素而不是下一个\n    // 便于将该链表片段加入res\n    for (let j = 0; j < l - 1; j++) {\n      curr = curr.next;\n    }\n    // curr 到达part的最后一个元素      \n    let cn = curr.next;\n    curr.next = null;\n    res.push(root);\n    curr = root = cn;\n  }\n  return res;\n};\n```\n\n\n\n#### [445] Add Two Numbers II\n\n> You are given two **non-empty** linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n>\n> You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n>\n> **Follow up:**\n> What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\n\n题目要求不能翻转链表, 于是遍历链表, 将链表中的数都存进栈中. 再通过将栈弹出, 进行相加操作.\n\n**时间复杂度**:\n\n遍历两个链表, O(N). 两个栈均弹出进行相加操作, O(N). 因此时间为 $2O(N)=O(N)$\n\n**空间复杂度**:\n\n使用两个栈存储数字, O(N), 相加之后得到新的结果列表的长度 O(max(m, n)) ps.是两个链表中较长的那一个Lmax, 结果链表长度可能由于进位问题会是Lmax+1, 因此空间复杂度为 $O(N)+O(max(m, n))$.\n\n```javascript\n// 不能够翻转链表\n// 使用两个栈存储数字\nvar addTwoNumbers = function (l1, l2) {\n  // 将两个链表中的值分别存进两个栈中\n  let stack1 = [], stack2 = [];\n  while (l1) {\n    stack1.push(l1.val);\n    l1 = l1.next;\n  }\n  while (l2) {\n    stack2.push(l2.val);\n    l2 = l2.next;\n  }\n  // 初始化变量\n  let sum = 0, carry = 0, num = 0;\n  let res = new ListNode(null), rn;\n  let add1, add2;\n  // 当两个栈有至少一个不为空时, 都进行相加操作\n  // 为空的那个栈的加数为 0\n  while (stack1.length != 0 || stack2.length != 0) {\n    add1 = stack1.length == 0 ? 0 : stack1.pop();\n    add2 = stack2.length == 0 ? 0 : stack2.pop();\n    sum = add1 + add2 + carry;\n    // 商是进位 大于10为1,小于10为0\n    carry = Math.floor(sum / 10);\n    // 余数是相加之后结果中的数字\n    num = sum % 10;\n    // 将结果添加进结果列表中\n    rn = res.next;\n    res.next = new ListNode(num);\n    res.next.next = rn;\n  }\n  // 当两个链表均为空时, 看是否还有进位\n  // 有进位则添加进结果列表中\n  if (carry != 0) {\n    rn = res.next;\n    res.next = new ListNode(carry);\n    res.next.next = rn;\n  }\n  return res.next;\n};\n```\n\n\n\n\n\n\n\n","source":"_posts/Linked-list.md","raw":"---\ntitle: Linked-list\nabbrlink: 34403\ndate: 2020-09-11 14:57:16\ntags:\ndescription: 链表相关题解\n---\n\n\n\n#### [2] Add Two Numbers\n\n> You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n>\n> You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n复杂的数据结构是我的超级短板. 但是也算勉强看懂了js是如何表示链表的.\n\n```javascript\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\n// 这个链表的存储结构是嵌套的, 即next指向的是嵌套的.\nvar addTwoNumbers = function (l1, l2) {\n  // 定义存储想关节点的变量\n  let result = new ListNode(null);\n  let lastNode = result;\n  let carry = 0; // 进位\n  let val = 0; // 相加之后赋给当前位置的值\n  // 当l1或者l2任何一方有值时, 都需要进行相加\n  while (l1 || l2) {\n    // 获取两个链表的初始值\n    let x = l1 == null ? 0 : l1.val;\n    let y = l2 == null ? 0 : l2.val;\n    // 两者相加\n    let num = x + y + carry;\n    carry = Math.floor(num / 10); // 商\n    val = num % 10; // 相加之后赋给当前位置的值\n    // 新建节点添加到链表末尾\n    lastNode.next = new ListNode(val);\n    // 最后节点位置更新\n    lastNode = lastNode.next;\n    // 进行下一位置的加法\n    if (l1 !== null) l1 = l1.next;\n    if (l2 !== null) l2 = l2.next;\n  }\n  // 当两个加数位数都加完了\n  // 但是仍然可能会有进位的可能\n  if (carry != 0) {\n    lastNode.next = new ListNode(carry);\n  }\n  return result.next;\n};\n\n/*\n示例结果\n====result.next\nListNode {\n  val: 7,\n  next: ListNode {\n    val: 0,\n    next: ListNode {\n      val: 8,\n      next: null\n    }\n  }\n}\n*/\n```\n\n\n\n#### [21] Merge Two Sorted Lists\n\n> Merge two sorted linked lists and return it as a new **sorted** list. The new list should be made by splicing together the nodes of the first two lists.\n\n解题的重点在于, 一直将l1和l2的链表头作比较, 不断将较小的node加入结果链表, 直至l1或者l2为空, 说明遍历结束. 把不为空的链表剩余的部分直接接入结果列表.\n\n```javascript\nvar mergeTwoLists = function (l1, l2) {\n  // 处理有链表为空的情况\n  if (l1 == null) {\n    return l2;\n  }\n  if (l2 == null) {\n    return l1\n  }\n  let res = new ListNode(null);\n  let curr = res;\n  // 网上的做法好简洁\n  while (l1 && l2) {\n    if (l1.val > l2.val) {\n      curr.next = l2;\n      l2 = l2.next;\n    } else {\n      curr.next = l1;\n      l1 = l1.next;\n    }\n    curr = curr.next;\n  }\n  curr.next = l1 == null ? l2 : l1;\n  return res.next;\n};\n```\n\n\n\n#### [24] Swap Nodes in Pairs\n\n> Given a linked list, swap every two adjacent nodes and return its head.\n>\n> You may **not** modify the values in the list's nodes, only nodes itself may be changed.\n\n在交换链表的时候, 第一次交换需要记住链表头.\n\n确定 `curr` 之后, 只有 `curr.next!=null` 时才有交换的必要, 否则说明交换到头了, 返回 `head` 即可.\n\n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  let curr = head;\n  let left = new ListNode(null);\n  let i = 0; // 第一次交换的时候 需要记住链表头 后面就不需要了\n  // 只有当 curr.next 也有值的时候, 才交换\n  // 否则就直接返回\n  while (curr && curr.next) {\n    let temp = curr.next.next;\n    let nextNode = curr.next;\n    nextNode.next = curr;\n    left.next = nextNode;\n    curr.next = temp;\n    left = curr;\n    curr = curr.next;\n    if (i == 0)\n      head = nextNode;\n    i++;\n  }\n  return head;\n};\n```\n\n\n\n#### [61] Rotate List\n\n> Given a linked list, rotate the list to the right by *k* places, where *k* is non-negative.\n\n```javascript\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n * 大体思路是: \n * 先计算出链表的长度len, 再将k与len进行比较, \n * k>len的话, 将k中len的整数倍减去之后, 就是最后需要移动的元素的个数\n */\n\nvar rotateRight = function (head, k) {\n  if (head == null) {\n    return null;\n  }\n  // 计算链表长度\n  // 此时right指向最后一个元素\n  let left = head, right = head, len = 1;\n  while (right.next) {\n    right = right.next;\n    len++;\n  }\n  if (len == 1 || k == len) {\n    return head;\n  }\n  // 取余之后是实际上需要移动的元素\n  let num = k % len;\n  // 由于在计算链表长度的时候, right已经指向链表尾部\n  // 左右指针间隔k-1个元素\n  // 所以左指针需要向右移动len-num-1个位置\n  // 具体的边界条件可以在测试中验证是否正确\n  for (let i = 0; i < len - num - 1; i++) {\n    left = left.next;\n  }\n  right.next = head;\n  head = left.next;\n  left.next = null;\n  return head;\n};\n```\n\n\n\n#### [23] Merge k Sorted Lists\n\n> You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n>\n> *Merge all the linked-lists into one sorted linked-list and return it.*\n\n**solution1** 的时间复杂度分析:\n\n时间复杂度: 遍历链表+排序+遍历数组\n\t假设总node数为 $N$ , 则总时间复杂度为 $O(N)+O(NlogN)+O(N)=O(N)$\n空间复杂度为: $O(N)$ , 主要是存储节点的数组的消耗\n\n**solution2** 的时间复杂度分析:\n\n设k=lists.length, $N$ 为所有节点数, 则复杂度为=归并次数*每一次归并的时间复杂度\n每一次归并需要遍历所有的节点, 但是不需要排序, 仅仅是大小比较, $O(N)$\n设一共归并的次数为x, 则有 $2^x = k$ , 则 $ x = \\log_2 k$ (以2为底k的对数)\n所以总共的时间复杂度是 $\\sum_0^x * O(N)=O(N\\log k)$\n\n```javascript\n// solution 1\n// 把链表中的节点值都拿出来放在一个数组里\n// 然后对数组进行排序\nvar mergeKLists1 = function (lists) {\n\n  let len = lists.length;\n  if (len == 0) {\n    return null\n  }\n  let arr = [], l;\n  for (let i = 0; i < len; i++) {\n    l = lists[i];\n    while (l) {\n      arr.push(l.val);\n      l = l.next;\n    }\n  }\n  arr.sort((a, b) => a - b); // 正序排列\n  let res = new ListNode(null);\n  let curr = res;\n  for (let i = 0; i < arr.length; i++) {\n    curr.next = new ListNode(arr[i]);\n    curr = curr.next;\n  }\n  return res.next;\n};\n\n// solution 2\n// 分治算法 这是一开始就想到的方法 但是不会实现🤦‍♀️\n// 两两链表合并排序, 再将结果再合并, 直至只有一个结果\n// 数组长度为奇数, 最后一次合并时, 是第一个与最后一个元素合并, interval*2之后会<len, 继续进行最后一次合并\n// 数组长度为奇数, 最后一次合并时, 是第一个与中间元素合并, interval*2之后会=len, 跳出循环\nvar mergeKLists = function (lists) {\n  let len = lists.length;\n  // 没有链表返回空链表\n  if (len == 0) {\n    return null;\n  }\n  let interval = 1;// 标志需要合并的两个链表之间的距离\n  // 归并排序的代码更像模板\n  // 只要两个元素之间的距离没有超过数组长度, 说明没有归并完毕\n  while (interval < len) {\n    for (let i = 0; i < len - interval; i = i + interval * 2) {\n      // i的作用是, 找到所有需要合并的链表中的第一个\n      // 不断地把相隔interval距离的两个链表合并\n      lists[i] = mergeTwoLists(lists[i], lists[i + interval])\n    }\n    interval = interval * 2;\n  }\n  return lists[0];\n}\n\n// 合并两个链表\nvar mergeTwoLists = (l1, l2) => {\n  if (!l1) return l2;\n  if (!l2) return l1;\n  let res = new ListNode(null);\n  let curr = res;\n  while (l1 && l2) {\n    if (l1.val < l2.val) {\n      curr.next = l1;\n      l1 = l1.next;\n    } else {\n      curr.next = l2;\n      l2 = l2.next;\n    }\n    curr = curr.next;\n  }\n  curr.next = l1 == null ? l2 : l1;\n  return res.next;\n}\n```\n\n\n\n#### [25] Reverse Nodes in k-Group\n\n> Given a linked list, reverse the nodes of a linked list *k* at a time and return its modified list.\n>\n> *k* is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of *k* then left-out nodes in the end should remain as it is.\n\n时间复杂度分析:\n\n$O(N)$ , $N$为链表总节点数, 翻转时需要遍历所有的节点. 一共会进行$\\lfloor N/k \\rfloor$ 次翻转, 每一次翻转需要$O(k)$的时间.\n\n空间复杂度: 常量级别.\n\n```javascript\n// 大体思路是 每k个元素进行一次翻转\n// 在翻转之前查看接下来的链表长度是否足够\n// 足够则翻转 不够则停下并返回结果\n// 翻转时注意连接前后链表的部分\nvar reverseKGroup = function (head, k) {\n  // 在链表头节点前加一个节点\n  // 后面翻转后的链表再与原来的链表连接要用到\n  let hair = new ListNode(null, head);\n  let pre = hair;\n  // tail需要以pre为起点, 向后移动k个位置\n  let tail = hair, right;\n  while (tail) {\n    // 将 tail 移动至需要翻转的链表部分的末尾\n    for (let i = 0; i < k; i++) {\n      tail = tail.next;\n      // 如果 tail 在向后移动但是还没有到目标位置时\n      // 出现 tail 为 null 的情况\n      // 说明剩余的元素已经不够翻转的数量\n      // 直接返回现有结果即可\n      if (!tail) return hair.next;\n    }\n    // head-tail的链表部分需要翻转\n    // 且翻转需要head和tail仍指向翻转后链表的头和尾\n    // 保留tail的后面部分\n    right = tail.next;\n    [head, tail] = reverse(head, tail);\n    // 进行与原链表的拼接\n    pre.next = head;\n    tail.next = right;\n    // 改变pre head的位置\n    pre = tail;\n    head = right;\n  }\n  return hair.next;\n};\n\n// 翻转链表\n// 这里不用再初始化res来存储翻转后的结果\n// 因为tail.next是存在的\n// 可以看做已有的res使用\n// 使用常数级的内存空间\nvar reverse = (head, tail) => {\n  let p = head;\n  let remain = tail.next; // 表示剩余不用翻转的部分\n  let nex;\n  while (p !== tail) {\n    nex = p.next;\n    p.next = remain;\n    remain = p;\n    p = nex;\n  }\n  tail.next = remain;\n  return [tail, head];\n}\n```\n\n\n\n#### [83] Remove Duplicates from Sorted List\n\n> Given a sorted linked list, delete all duplicates such that each element appear only *once*.\n\n思路比较简单, 由于最坏情况是遍历链表的所有节点(当所有节点的值均不相同),  时间复杂度为 $O(N)$ .\n\n```javascript\n// 由于是排过序的链表\n// 所以重复元素都会在一块\n// 不断比较curr与curr.next的val是否相等\n// 相等则跳过该重复元素,不等才改变curr的位置\n// 直至curr遍历完链表的所有元素\nvar deleteDuplicates = function (head) {\n  if (!head) return null;\n  let curr = head;\n  while (curr) {\n    // 最后一个元素是不同元素 到达链表末尾\n    if (!curr.next) return head;\n    while (curr.val == curr.next.val) {\n      curr.next = curr.next.next;\n      // 最后一个元素是相同元素 到达链表末尾\n      if (!curr.next) {\n        return head;\n      }\n    }\n    curr = curr.next;\n  }\n};\n```\n\n\n\n#### [82] Remove Duplicates from Sorted List II\n\n> Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only *distinct* numbers from the original list.\n>\n> Return the linked list sorted as well.\n\n遍历链表的所有节点两次,  时间复杂度为 $2*O(N) = O(N)$ .\n\n```javascript\n// 遍历两次链表\n// 第一次按照顺序将所有不同的元素组成链表, 并给有重复元素的节点增加dup属性\n// 第二次将有dup属性的节点删除, 返回结果\nvar deleteDuplicates = function (head) {\n  let curr = head;\n  while (curr) {\n    if (!curr.next) break;\n    while (curr.val == curr.next.val) {\n      curr.dup = true;\n      curr.next = curr.next.next;\n      if (!curr.next) break;\n    }\n    curr = curr.next;\n  }\n  if (!head) return null;\n\n  let hair = new ListNode(null, head);\n  let pre = hair, point = head;\n  while (point) {\n    while (point.dup) {\n      point = point.next;\n      if (!point) {\n        pre.next = null;\n        return hair.next;\n      }\n    }\n    pre.next = point;\n    pre = point;\n    point = point.next;\n  }\n  return hair.next;\n};\n```\n\n\n\n#### [142] Linked List Cycle II\n\n> Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n>\n> There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n>\n> **Notice** that you **should not modify** the linked list.\n\n这里需要证明下有环情况下, 为什么快慢指针第一次相遇之后, 快指针到链表头, 再和慢指针一起以每次一步的速度前进, 当二者相等时, 即是环的起点.\n\n**证明**:\n\n![image.png](Linked-list/image.png)\n\n我们最终需要证明a=b. 假设链表总长度为L, 环的长度为R, 快慢指针第一次相遇的节点为M, 环的开始节点为C, 其中各个点之间的距离分别为 H->C=a, C->M=c, M->C=b, H->M=s. 第一次相遇时, 假设fast已经围绕着环走了n圈, 则有:\n\n由于快慢指针的速度差两倍, 所以相同时间内, 快指针走过的距离是慢指针的两倍.\n\n$2s = s + nR \\\\-> s = nR \\tag{1}$\n\n已知慢指针走的长度为(套用$(1)$):\n\n$a+c = s \\\\-> a+c=nR \\\\-> a + c = (n-1)R + R \\\\-> a = (n-1)R + (R - c) \\\\->  a = (n-1)R +b$\n\n则得出结论 $a=b$, (这个还要再想下).\n\n所以fast移动到head, slow位置不变, 两个同时开始走, 每次走一步, 当走了a步时,两者相遇的点即为环的起点.\n\n\n\n**时间复杂度**:\n\n可知快慢指针走的步数是一样的, 只是一个快一个慢, 慢指针最后遍历了整个链表, 走了N步, 则快指针也走了N步, 则时间复杂度为: $2*O(N)= O(N)$.\n\n```javascript\n// 使用快慢指针\nvar detectCycle = function (head) {\n  if (!head || !head.next) return null;\n  // 快慢指针的起始点应该一样\n  let fast = head;\n  let slow = head;\n  while (slow) {\n    // 快指针的速度是慢指针的2倍\n    slow = slow.next;\n    // 在没有环的情况下\n    // fast指针会最先到达链表尾部, 直接返回null;\n    // fast指针最后的位置,要不倒数第一,要不倒数第二\n    // 与链表长度的奇偶数以及每次走的步数有关\n    // 这里fast指针是每次走两步\n    if (!fast.next) return null\n    fast = fast.next.next;\n    if (!fast) return null\n    // 说明有环 两指针第一次相遇\n    if (fast == slow) {\n      // 快指针移动至链表头\n      // 慢指针停在原地\n      fast = head;\n      // 二者均以每次一步的速度继续向前走, 直至再次相遇\n      // 这里方法需要证明\n      while (fast != slow) {\n        fast = fast.next;\n        slow = slow.next;\n      }\n      // 返回的是环的起始节点的指针\n      return fast;\n    }\n  }\n};\n```\n\n\n\n#### [138] Copy List with Random Pointer\n\n> A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\n>\n> Return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the list.\n>\n> The Linked List is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where:\n>\n> - `val`: an integer representing `Node.val`\n> - `random_index`: the index of the node (range from `0` to `n-1`) where random pointer points to, or `null` if it does not point to any node.\n\n**时间复杂度:** 遍历两遍数组 $O(N)$.\n\n**经验/收获**: \n\n1. 一开始我的问题在于试错, 都没有搞清楚`random_index`属性是否在题目给的链表结构中存在, 我还以为有`random_index`这个属性呢, 实际上没有.  `random`数据类型仍然是指针而非number.\n2. 搞清楚题目是深拷贝, 不能改变原有链表结构. **需要重新生成新链表**.\n3. 收获在于知道如何使用hashMap存储链表间的 links.\n\n```javascript\n// 题目要求是深拷贝\n// 就是不改变原有的链表\n// 第一遍是copy all nodes, 使用map存储\n// 第二遍是copy links\nvar copyRandomList = function (head) {\n  if (!head) return null;\n  // copy nodes\n  let curr = head;\n  let map = new Map(); // map的key可以是任何对象, 不限于字符串\n  while (curr) {\n    map.set(curr, new Node(curr.val));\n    curr = curr.next;\n  }\n  // copy links\n  curr = head;\n  let node = map.get(curr);\n  while (curr) {\n    node.next = curr.next ? map.get(curr.next) : null;\n    node.random = curr.random ? map.get(curr.random) : null;\n    curr = curr.next;\n    node = node.next;\n  }\n  return map.get(head);\n};\n```\n\n\n\n#### [92] Reverse Linked List II\n\n> Reverse a linked list from position *m* to *n*. Do it in one-pass.\n>\n> **Note:** 1 ≤ *m* ≤ *n* ≤ length of list.\n\n**时间复杂度分析**:\n\n假设链表总长度为$N$, 在定位m/n节点的过程中, 一共遍历链表一次, 每次遍历至第n个节点, 最差情况遍历到链表末尾.\n\n翻转时一共需要翻转 $n-m+1$ 个节点, 需要的时间是 $ O(n-m+1)$ .\n\n所以时间复杂度为 $O(N)$ \n\n**注意**:\n\n初始化一个节点时, hair不是空, hair.val是空. 刚开始判断pre==null就写错了, 应该是pre.val是否null.\n\n```javascript\nvar reverseBetween = function (head, m, n) {\n  // 特殊情况\n  if (!head) return null\n  if (!head.next) return head;\n  // 当链表长度足够翻转时, 在head前添加hair节点\n  // 为了使用pre节点, pre是pm的前一个节点\n  let hair = new ListNode(null, head);\n  let pre = hair, curr = head;\n  // 定义变量 注意需要tail指针\n  let pm, pn, tail;\n\n  // 定位m节点\n  if (m == 1) {\n    pm = head; // pm直接是头节点\n  } else {\n    // m-1次循环到达pm节点\n    for (let i = 0; i < m - 1; i++) {\n      // pre节点也需要同时向后移动\n      // 保证在pm前一位\n      curr = curr.next;\n      pre = pre.next;\n    }\n    pm = curr;\n  }\n  // 定位n节点\n  for (let i = 0; i < n - m; i++) {\n    curr = curr.next;\n  }\n  pn = curr;\n  // 翻转前保留尾部数据\n  tail = curr.next;\n  // 翻转\n  while (pm != pn) {\n    let temp = pm.next;\n    pm.next = tail;\n    tail = pm;\n    pm = temp;\n    pre.next = tail;\n  }\n  // pm==pn时还需要连接下tail\n  pm.next = tail;\n  // 连接\n  pre.next = pm;\n  // 这里返回hair.next即可\n  // 不用分析pre是否为空\n  return hair.next;\n};\n```\n\n\n\n#### [147] Insertion Sort List\n\n> Sort a linked list using insertion sort.\n\n时间复杂度分析:\n\n遍历链表一次, $O(N)$\n\n每到链表的一个节点, 就会扫描排好序的链表部分, 时间为 $O(1)+O(2)+O(3)+...+O(N-1)$\n\n则时间复杂度为: $O(1)+O(2)+...+O(N)=O((N^2+N)/2)=O(N^2)$\n\n```javascript\n// 使用插入排序对链表进行排序\n// 插入排序是: 不断将没有排序的元素加入已经排好序的部分\n// 单向链表只能从前往后遍历\n// 这里顺便学习了单向链表\nvar insertionSortList = function (head) {\n  if (!head) return null;\n  if (!head.next) return head;\n  // 第一个元素默认已经排好序\n  // curr 从下一位开始\n  let curr = head.next;\n  // 初始化\n  // 排好序的部分此时只有head一个元素\n  // 末尾指向null\n  // 与需要排序的部分分开\n  head.next = null;\n  let cn, hn;\n  while (curr) {\n    // 保留curr的后一部分\n    cn = curr.next;\n    // curr比有序的第一个元素小\n    // 则直接置于有序部分的头部\n    if (curr.val <= head.val) {\n      curr.next = head;\n      head = curr;\n    } else {\n      // curr 比第一个有序元素大\n      // 则需要遍历后面的有序元素\n      // 直到找到有序排列中比curr大的元素x\n      // 则curr插入到 x的前面\n      // 为了保留 x 的前一个节点\n      // 将curr.val与h.next.val进行比较, 而不是h.val\n      let h = head;\n      while (h.next && curr.val > h.next.val) {\n        h = h.next;\n      }\n      // 将curr插入至 h 与 x 节点之间\n      hn = h.next;\n      h.next = curr;\n      curr.next = hn;\n    }\n    // curr向后移动一位\n    curr = cn;\n  }\n  return head;\n};\n```\n\n\n\n#### [203] Remove Linked List Elements\n\n> Remove all elements from a linked list of integers that have value ***val\\***.\n\n时间复杂度: 遍历链表 $O(N)$\n\n```javascript\nvar removeElements = function (head, val) {\n  if (!head) return null;\n  let hair = new ListNode(null, head);\n  let pre = hair, curr = head;\n  // pre的移动也是在head表示的这条链表上\n  // pre改变的是head本身\n  while (curr) {\n    if (curr.val == val) {\n      pre.next = curr.next;\n    } else {\n      pre = curr;\n    }\n    curr = curr.next;\n  }\n  // 有个特殊情况需要注意\n  // 比如 [1] 1\n  // 此时pre还没后移到head链表上\n  // 所以pre指向null没有改变head链表\n  // head仍然是 [1]\n  return hair.next;\n};\n```\n\n\n\n#### [206] Reverse Linked List\n\n> Reverse a singly linked list.\n>\n> **Follow up:**\n>\n> A linked list can be reversed either iteratively or recursively. Could you implement both?\n\n**递归过程**需要详细的过程分析图(**TO DO**).\n\n两种时间复杂度均为 $O(N)$. \n\n递归方法的时间复杂度分析: 遍历整个链表, 递归调用N次.\n\n```javascript\n// 迭代翻转\n// 空间复杂度 O(1)\nvar reverseList1 = function (head) {\n  let rever = new ListNode(null);\n  let temp;\n  while (head) {\n    temp = head.next;\n    head.next = rever.next;\n    rever.next = head;\n    head = temp;\n  }\n  return rever.next;\n};\n\n// 递归翻转\n// 需要注意的是, p是指向head的一个指针\n// 并不是另外的链表\n// 但是由于每一次都会生成p指针重新指向目前已经倒好序的链表\n// 所以递归过程中的空间复杂度为O(1)+O(2)+...+O(N)=O(N)\nvar reverseList = function (head) {\n  if (!head || !head.next) return head;\n  let p = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n  return p;\n};\n```\n\n\n\n#### [237] Delete Node in a Linked List\n\n> Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.\n>\n> It is **guaranteed** that the node to be deleted is **not a tail node** in the list.\n\n注意看题目条件, 时间/空间复杂度均为 $O(N)$.\n\n```javascript\n// 一时没有想起来用什么解法\n// 因为之前删除节点都是不能改变节点自身的值\n// 现在这个能改变了 害\n// 这个方法令我哭笑不得, 也提醒自己注意看题目条件\nvar deleteNode = function(node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n};\n```\n\n\n\n#### [234] Palindrome Linked List\n\n> Given a singly linked list, determine if it is a palindrome.\n>\n> **Follow up:**\n> Could you do it in O(n) time and O(1) space?\n\n时间复杂度: \n\n遍历链表一次, $O(N)$, 后半部分翻转链表的时候, 时间为$O(N/2)$.\n\n所以时间复杂度为: $O(N)+O(N/2)=O(N)$.\n\n方法:\n\n判断回文链表,要求只能遍历一次链表.\n\n将链表**后半段翻转** 再将前后部分分别比较.\n\n然后还有需要注意的是: **快慢指针法寻找链表中心点**\n\n```javascript\nvar isPalindrome = function (head) {\n  if (!head || !head.next) return true;\n  let fast = head, slow = head;\n  while (fast.next && fast.next.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  // 不管链表长度是奇数还是偶数 需要进行的操作都是一样的\n  // slow 为后半部分链表的起点\n  slow.next = reverse(slow.next);\n  slow = slow.next;\n  // 将前后两部分链表逐个节点对值进行比较\n  // 如果有值不等 说明不是回文\n  // 前半部分的长度是>=后半部分的\n  // 所以当slow=null时, head=null或者head是最后一个节点\n  // 由于回文的两种形式, 此时就可以结束比较了\n  while (slow) {\n    if (head.val != slow.val) {\n      return false;\n    }\n    head = head.next;\n    slow = slow.next;\n  }\n  return true;\n};\n\n// 翻转链表\nvar reverse = (head) => {\n  let res = new ListNode(null);\n  let curr = head, cn, rn;\n  while (curr) {\n    cn = curr.next;\n    rn = res.next;\n    res.next = curr;\n    curr.next = rn;\n    curr = cn;\n  }\n  return res.next;\n}\n```\n\n\n\n#### [160] Intersection of Two Linked Lists\n\n> Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n> **Notes:**\n>\n> - If the two linked lists have no intersection at all, return `null`.\n> - The linked lists must retain their original structure after the function returns.\n> - You may assume there are no cycles anywhere in the entire linked structure.\n> - Each value on each linked list is in the range `[1, 10^9]`.\n> - Your code should preferably run in O(n) time and use only O(1) memory.\n\n![image1.png](Linked-list/image1.png)\n\n由图可知:\n\n$headA = A + C$\n\n$headB = B + C$\n\n所以:\n\n$newA = headA + headB = A + C + B + C$\n\n$newB = headB + headA = B + C + A + C$\n\n已知:\n\n$A + C + B = B + C + A$\n\n所以 `newA`与`newB`同时出发, 每次都走一步. \n\n`newA`走完`headA`再走完`B`,  `newB`走完`headB`再走完`A`, 如果两者有交点, 则此时会相等且不为`null`;\n\n如果不相交, 则走到最后两者也相等, 但是为`null`.\n\n时间复杂度:\n\n假设`headA`和`headB`总共的长度为`N`, 则一共遍历了两次, 时间为$2*O(N)$, 时间复杂度为$O(N)$.\n\n```javascript\n// 思路很巧妙 需要分析下 最后两个节点一定会相等\n// 只是是地址还是null的问题\n// 最差情况是不相交\n// 每个链表均遍历了两遍\n// 但是额外空间只使用了两个指针变量,为常数级\nvar getIntersectionNode = function (headA, headB) {\n  let currA = headA, currB = headB;\n  while (currA != currB) {\n    currA = !currA ? headB : currA.next;\n    currB = !currB ? headA : currB.next;\n  }\n  // 不相交最后也会相等的 均是null\n  // 即： 相交或者是不相交， 二者均会相等\n  // 相等的话，返回的是及交点地址\n  // 不相等的话，返回的是null\n  return currA;\n};\n```\n\n\n\n#### [328] Odd Even Linked List\n\n> Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\n>\n> You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\n\n时间复杂度: 两个指针同时遍历, 一共遍历一遍链表. $O(N)$\n\n空间复杂度: 只是新建了两个指针, 改动原有链表, 没有重新生成head的copy版本. $O(1)$\n\n```javascript\n// 完全自己想的法子 太棒了\n// 大体思路就是,用两个指针, 一个指向奇数节点, 一个指向偶数节点\n// 遍历完head之后, 再将两个链表进行拼接\nvar oddEvenList = function (head) {\n  if (!head || !head.next || !head.next.next) return head;\n  let oddList = new ListNode(null);\n  let evenList = new ListNode(null);\n  let odd = oddList, even = evenList;\n  // 初始化第一个奇数节点\n  odd.next = head;\n  odd = odd.next;\n  // 初始化第一个偶数节点\n  even.next = head.next;\n  even = even.next;\n  while (even && even.next) {\n    odd.next = odd.next.next;\n    odd = odd.next;\n    even.next = even.next.next;\n    even = even.next;\n    // 链表长度为奇数 此时 even==null\n    // 链表长度为偶数 此时 even.next==null\n    // 两种情况的任何一种情况都应该退出循环\n  }\n  // 对奇数链与偶数链进行拼接\n  odd.next = evenList.next;\n  return oddList.next;\n};\n```\n\n\n\n#### [725] Split Linked List in Parts\n\n> Given a (singly) linked list with head node `root`, write a function to split the linked list into `k` consecutive linked list \"parts\".\n>\n> The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.\n>\n> The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n>\n> Return a List of ListNode's representing the linked list parts that are formed.\n>\n> Examples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]\n\n理解题意 一共分为 k 部分 而不是长度是 k !!\n\n*时间复杂度**:\n\n在计算链表长度时, 遍历了一次. 后面将链表片段加入时, 又遍历了一遍.\n\n所以时间复杂度为 $O(N+k)$, 在`k>len`时, 需要继续向结果中加入片段.\n\n**空间复杂度**:\n\n生成`answer`时res数组中包含的节点个数, `k>len`, k个链表节点, 反之, len个链表节点. 所以空间复杂度为$O(max(N, k))$.\n\n```javascript\nvar splitListToParts = function (root, k) {\n  // 先计算root的长度\n  let curr = root, len = 0;\n  while (curr) {\n    len++;\n    curr = curr.next;\n  }\n  curr = root;\n  // 计算宽度\n  let width = Math.floor(len / k);\n  let extra = len % k; // 需要长度被加一的组数\n  let res = []; // 初始化长度为k的结果数组\n  for (let i = 0; i < k; i++) {\n    // 当k<=len的时候,curr指向null时, for循环也就结束了\n    // 因为组数已经达到了k组\n    // 出现curr为null的情况时, 并且走到了这里\n    // 说明k>len\n    // 此时只需要将null不断加入数组直至数组长度达到k\n    if (!curr) {\n      res.push(null);\n      continue;\n    }\n    // 多余没有入组的元素需要加入前面的每一个组\n    // 因此前extra组, 每组的元素长度需要+1\n    let l = i < extra ? width + 1 : width;\n    // l-1是为了控制curr指向part的最后一个元素而不是下一个\n    // 便于将该链表片段加入res\n    for (let j = 0; j < l - 1; j++) {\n      curr = curr.next;\n    }\n    // curr 到达part的最后一个元素      \n    let cn = curr.next;\n    curr.next = null;\n    res.push(root);\n    curr = root = cn;\n  }\n  return res;\n};\n```\n\n\n\n#### [445] Add Two Numbers II\n\n> You are given two **non-empty** linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n>\n> You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n>\n> **Follow up:**\n> What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\n\n题目要求不能翻转链表, 于是遍历链表, 将链表中的数都存进栈中. 再通过将栈弹出, 进行相加操作.\n\n**时间复杂度**:\n\n遍历两个链表, O(N). 两个栈均弹出进行相加操作, O(N). 因此时间为 $2O(N)=O(N)$\n\n**空间复杂度**:\n\n使用两个栈存储数字, O(N), 相加之后得到新的结果列表的长度 O(max(m, n)) ps.是两个链表中较长的那一个Lmax, 结果链表长度可能由于进位问题会是Lmax+1, 因此空间复杂度为 $O(N)+O(max(m, n))$.\n\n```javascript\n// 不能够翻转链表\n// 使用两个栈存储数字\nvar addTwoNumbers = function (l1, l2) {\n  // 将两个链表中的值分别存进两个栈中\n  let stack1 = [], stack2 = [];\n  while (l1) {\n    stack1.push(l1.val);\n    l1 = l1.next;\n  }\n  while (l2) {\n    stack2.push(l2.val);\n    l2 = l2.next;\n  }\n  // 初始化变量\n  let sum = 0, carry = 0, num = 0;\n  let res = new ListNode(null), rn;\n  let add1, add2;\n  // 当两个栈有至少一个不为空时, 都进行相加操作\n  // 为空的那个栈的加数为 0\n  while (stack1.length != 0 || stack2.length != 0) {\n    add1 = stack1.length == 0 ? 0 : stack1.pop();\n    add2 = stack2.length == 0 ? 0 : stack2.pop();\n    sum = add1 + add2 + carry;\n    // 商是进位 大于10为1,小于10为0\n    carry = Math.floor(sum / 10);\n    // 余数是相加之后结果中的数字\n    num = sum % 10;\n    // 将结果添加进结果列表中\n    rn = res.next;\n    res.next = new ListNode(num);\n    res.next.next = rn;\n  }\n  // 当两个链表均为空时, 看是否还有进位\n  // 有进位则添加进结果列表中\n  if (carry != 0) {\n    rn = res.next;\n    res.next = new ListNode(carry);\n    res.next.next = rn;\n  }\n  return res.next;\n};\n```\n\n\n\n\n\n\n\n","slug":"Linked-list","published":1,"updated":"2020-10-29T10:55:09.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafs000emm9h8gd5hs0n","content":"<h4 id=\"2-Add-Two-Numbers\"><a href=\"#2-Add-Two-Numbers\" class=\"headerlink\" title=\"[2] Add Two Numbers\"></a>[2] Add Two Numbers</h4><blockquote>\n<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n</blockquote>\n<p>复杂的数据结构是我的超级短板. 但是也算勉强看懂了js是如何表示链表的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l1</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l2</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 这个链表的存储结构是嵌套的, 即next指向的是嵌套的.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义存储想关节点的变量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> lastNode = result;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> carry = <span class=\"number\">0</span>; <span class=\"comment\">// 进位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>; <span class=\"comment\">// 相加之后赋给当前位置的值</span></span><br><span class=\"line\">  <span class=\"comment\">// 当l1或者l2任何一方有值时, 都需要进行相加</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1 || l2) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取两个链表的初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = l1 == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : l1.val;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> y = l2 == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : l2.val;</span><br><span class=\"line\">    <span class=\"comment\">// 两者相加</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = x + y + carry;</span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(num / <span class=\"number\">10</span>); <span class=\"comment\">// 商</span></span><br><span class=\"line\">    val = num % <span class=\"number\">10</span>; <span class=\"comment\">// 相加之后赋给当前位置的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 新建节点添加到链表末尾</span></span><br><span class=\"line\">    lastNode.next = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">    <span class=\"comment\">// 最后节点位置更新</span></span><br><span class=\"line\">    lastNode = lastNode.next;</span><br><span class=\"line\">    <span class=\"comment\">// 进行下一位置的加法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1 !== <span class=\"literal\">null</span>) l1 = l1.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l2 !== <span class=\"literal\">null</span>) l2 = l2.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当两个加数位数都加完了</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是仍然可能会有进位的可能</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (carry != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    lastNode.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">示例结果</span></span><br><span class=\"line\"><span class=\"comment\">====result.next</span></span><br><span class=\"line\"><span class=\"comment\">ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  val: 7,</span></span><br><span class=\"line\"><span class=\"comment\">  next: ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    val: 0,</span></span><br><span class=\"line\"><span class=\"comment\">    next: ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      val: 8,</span></span><br><span class=\"line\"><span class=\"comment\">      next: null</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"21-Merge-Two-Sorted-Lists\"><a href=\"#21-Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"[21] Merge Two Sorted Lists\"></a>[21] Merge Two Sorted Lists</h4><blockquote>\n<p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p>\n</blockquote>\n<p>解题的重点在于, 一直将l1和l2的链表头作比较, 不断将较小的node加入结果链表, 直至l1或者l2为空, 说明遍历结束. 把不为空的链表剩余的部分直接接入结果列表.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mergeTwoLists = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理有链表为空的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = res;</span><br><span class=\"line\">  <span class=\"comment\">// 网上的做法好简洁</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class=\"line\">      curr.next = l2;</span><br><span class=\"line\">      l2 = l2.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      curr.next = l1;</span><br><span class=\"line\">      l1 = l1.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curr.next = l1 == <span class=\"literal\">null</span> ? l2 : l1;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"24-Swap-Nodes-in-Pairs\"><a href=\"#24-Swap-Nodes-in-Pairs\" class=\"headerlink\" title=\"[24] Swap Nodes in Pairs\"></a>[24] Swap Nodes in Pairs</h4><blockquote>\n<p>Given a linked list, swap every two adjacent nodes and return its head.</p>\n<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>\n</blockquote>\n<p>在交换链表的时候, 第一次交换需要记住链表头.</p>\n<p>确定 <code>curr</code> 之后, 只有 <code>curr.next!=null</code> 时才有交换的必要, 否则说明交换到头了, 返回 <code>head</code> 即可.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">head</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> swapPairs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 第一次交换的时候 需要记住链表头 后面就不需要了</span></span><br><span class=\"line\">  <span class=\"comment\">// 只有当 curr.next 也有值的时候, 才交换</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则就直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr &amp;&amp; curr.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = curr.next.next;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextNode = curr.next;</span><br><span class=\"line\">    nextNode.next = curr;</span><br><span class=\"line\">    left.next = nextNode;</span><br><span class=\"line\">    curr.next = temp;</span><br><span class=\"line\">    left = curr;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">      head = nextNode;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"61-Rotate-List\"><a href=\"#61-Rotate-List\" class=\"headerlink\" title=\"[61] Rotate List\"></a>[61] Rotate List</h4><blockquote>\n<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">head</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">k</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * 大体思路是: </span></span><br><span class=\"line\"><span class=\"comment\"> * 先计算出链表的长度len, 再将k与len进行比较, </span></span><br><span class=\"line\"><span class=\"comment\"> * k&gt;len的话, 将k中len的整数倍减去之后, 就是最后需要移动的元素的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rotateRight = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 计算链表长度</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时right指向最后一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = head, right = head, len = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (right.next) &#123;</span><br><span class=\"line\">    right = right.next;</span><br><span class=\"line\">    len++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span> || k == len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 取余之后是实际上需要移动的元素</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = k % len;</span><br><span class=\"line\">  <span class=\"comment\">// 由于在计算链表长度的时候, right已经指向链表尾部</span></span><br><span class=\"line\">  <span class=\"comment\">// 左右指针间隔k-1个元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以左指针需要向右移动len-num-1个位置</span></span><br><span class=\"line\">  <span class=\"comment\">// 具体的边界条件可以在测试中验证是否正确</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - num - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    left = left.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  right.next = head;</span><br><span class=\"line\">  head = left.next;</span><br><span class=\"line\">  left.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"23-Merge-k-Sorted-Lists\"><a href=\"#23-Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"[23] Merge k Sorted Lists\"></a>[23] Merge k Sorted Lists</h4><blockquote>\n<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n</blockquote>\n<p><strong>solution1</strong> 的时间复杂度分析:</p>\n<p>时间复杂度: 遍历链表+排序+遍历数组<br>    假设总node数为 $N$ , 则总时间复杂度为 $O(N)+O(NlogN)+O(N)=O(N)$<br>空间复杂度为: $O(N)$ , 主要是存储节点的数组的消耗</p>\n<p><strong>solution2</strong> 的时间复杂度分析:</p>\n<p>设k=lists.length, $N$ 为所有节点数, 则复杂度为=归并次数<em>每一次归并的时间复杂度<br>每一次归并需要遍历所有的节点, 但是不需要排序, 仅仅是大小比较, $O(N)$<br>设一共归并的次数为x, 则有 $2^x = k$ , 则 $ x = \\log_2 k$ (以2为底k的对数)<br>所以总共的时间复杂度是 $\\sum_0^x </em> O(N)=O(N\\log k)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1</span></span><br><span class=\"line\"><span class=\"comment\">// 把链表中的节点值都拿出来放在一个数组里</span></span><br><span class=\"line\"><span class=\"comment\">// 然后对数组进行排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeKLists1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">lists</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = lists.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [], l;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    l = lists[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l) &#123;</span><br><span class=\"line\">      arr.push(l.val);</span><br><span class=\"line\">      l = l.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b); <span class=\"comment\">// 正序排列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = res;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    curr.next = <span class=\"keyword\">new</span> ListNode(arr[i]);</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// solution 2</span></span><br><span class=\"line\"><span class=\"comment\">// 分治算法 这是一开始就想到的方法 但是不会实现🤦‍♀️</span></span><br><span class=\"line\"><span class=\"comment\">// 两两链表合并排序, 再将结果再合并, 直至只有一个结果</span></span><br><span class=\"line\"><span class=\"comment\">// 数组长度为奇数, 最后一次合并时, 是第一个与最后一个元素合并, interval*2之后会&lt;len, 继续进行最后一次合并</span></span><br><span class=\"line\"><span class=\"comment\">// 数组长度为奇数, 最后一次合并时, 是第一个与中间元素合并, interval*2之后会=len, 跳出循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeKLists = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">lists</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = lists.length;</span><br><span class=\"line\">  <span class=\"comment\">// 没有链表返回空链表</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> interval = <span class=\"number\">1</span>;<span class=\"comment\">// 标志需要合并的两个链表之间的距离</span></span><br><span class=\"line\">  <span class=\"comment\">// 归并排序的代码更像模板</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要两个元素之间的距离没有超过数组长度, 说明没有归并完毕</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (interval &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - interval; i = i + interval * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// i的作用是, 找到所有需要合并的链表中的第一个</span></span><br><span class=\"line\">      <span class=\"comment\">// 不断地把相隔interval距离的两个链表合并</span></span><br><span class=\"line\">      lists[i] = mergeTwoLists(lists[i], lists[i + interval])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interval = interval * <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> lists[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个链表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeTwoLists = <span class=\"function\">(<span class=\"params\">l1, l2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!l1) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!l2) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = res;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">      curr.next = l1;</span><br><span class=\"line\">      l1 = l1.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      curr.next = l2;</span><br><span class=\"line\">      l2 = l2.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curr.next = l1 == <span class=\"literal\">null</span> ? l2 : l1;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"25-Reverse-Nodes-in-k-Group\"><a href=\"#25-Reverse-Nodes-in-k-Group\" class=\"headerlink\" title=\"[25] Reverse Nodes in k-Group\"></a>[25] Reverse Nodes in k-Group</h4><blockquote>\n<p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>\n<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>\n</blockquote>\n<p>时间复杂度分析:</p>\n<p>$O(N)$ , $N$为链表总节点数, 翻转时需要遍历所有的节点. 一共会进行$\\lfloor N/k \\rfloor$ 次翻转, 每一次翻转需要$O(k)$的时间.</p>\n<p>空间复杂度: 常量级别.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 大体思路是 每k个元素进行一次翻转</span></span><br><span class=\"line\"><span class=\"comment\">// 在翻转之前查看接下来的链表长度是否足够</span></span><br><span class=\"line\"><span class=\"comment\">// 足够则翻转 不够则停下并返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 翻转时注意连接前后链表的部分</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverseKGroup = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在链表头节点前加一个节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 后面翻转后的链表再与原来的链表连接要用到</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair;</span><br><span class=\"line\">  <span class=\"comment\">// tail需要以pre为起点, 向后移动k个位置</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tail = hair, right;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tail) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将 tail 移动至需要翻转的链表部分的末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">      tail = tail.next;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 tail 在向后移动但是还没有到目标位置时</span></span><br><span class=\"line\">      <span class=\"comment\">// 出现 tail 为 null 的情况</span></span><br><span class=\"line\">      <span class=\"comment\">// 说明剩余的元素已经不够翻转的数量</span></span><br><span class=\"line\">      <span class=\"comment\">// 直接返回现有结果即可</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!tail) <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// head-tail的链表部分需要翻转</span></span><br><span class=\"line\">    <span class=\"comment\">// 且翻转需要head和tail仍指向翻转后链表的头和尾</span></span><br><span class=\"line\">    <span class=\"comment\">// 保留tail的后面部分</span></span><br><span class=\"line\">    right = tail.next;</span><br><span class=\"line\">    [head, tail] = reverse(head, tail);</span><br><span class=\"line\">    <span class=\"comment\">// 进行与原链表的拼接</span></span><br><span class=\"line\">    pre.next = head;</span><br><span class=\"line\">    tail.next = right;</span><br><span class=\"line\">    <span class=\"comment\">// 改变pre head的位置</span></span><br><span class=\"line\">    pre = tail;</span><br><span class=\"line\">    head = right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 翻转链表</span></span><br><span class=\"line\"><span class=\"comment\">// 这里不用再初始化res来存储翻转后的结果</span></span><br><span class=\"line\"><span class=\"comment\">// 因为tail.next是存在的</span></span><br><span class=\"line\"><span class=\"comment\">// 可以看做已有的res使用</span></span><br><span class=\"line\"><span class=\"comment\">// 使用常数级的内存空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverse = <span class=\"function\">(<span class=\"params\">head, tail</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> remain = tail.next; <span class=\"comment\">// 表示剩余不用翻转的部分</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nex;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p !== tail) &#123;</span><br><span class=\"line\">    nex = p.next;</span><br><span class=\"line\">    p.next = remain;</span><br><span class=\"line\">    remain = p;</span><br><span class=\"line\">    p = nex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  tail.next = remain;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [tail, head];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"#83-Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"[83] Remove Duplicates from Sorted List\"></a>[83] Remove Duplicates from Sorted List</h4><blockquote>\n<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>\n</blockquote>\n<p>思路比较简单, 由于最坏情况是遍历链表的所有节点(当所有节点的值均不相同),  时间复杂度为 $O(N)$ .</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于是排过序的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 所以重复元素都会在一块</span></span><br><span class=\"line\"><span class=\"comment\">// 不断比较curr与curr.next的val是否相等</span></span><br><span class=\"line\"><span class=\"comment\">// 相等则跳过该重复元素,不等才改变curr的位置</span></span><br><span class=\"line\"><span class=\"comment\">// 直至curr遍历完链表的所有元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleteDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最后一个元素是不同元素 到达链表末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!curr.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr.val == curr.next.val) &#123;</span><br><span class=\"line\">      curr.next = curr.next.next;</span><br><span class=\"line\">      <span class=\"comment\">// 最后一个元素是相同元素 到达链表末尾</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!curr.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"82-Remove-Duplicates-from-Sorted-List-II\"><a href=\"#82-Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"[82] Remove Duplicates from Sorted List II\"></a>[82] Remove Duplicates from Sorted List II</h4><blockquote>\n<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>\n<p>Return the linked list sorted as well.</p>\n</blockquote>\n<p>遍历链表的所有节点两次,  时间复杂度为 $2*O(N) = O(N)$ .</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历两次链表</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次按照顺序将所有不同的元素组成链表, 并给有重复元素的节点增加dup属性</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次将有dup属性的节点删除, 返回结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleteDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!curr.next) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr.val == curr.next.val) &#123;</span><br><span class=\"line\">      curr.dup = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      curr.next = curr.next.next;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!curr.next) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair, point = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (point) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (point.dup) &#123;</span><br><span class=\"line\">      point = point.next;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!point) &#123;</span><br><span class=\"line\">        pre.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre.next = point;</span><br><span class=\"line\">    pre = point;</span><br><span class=\"line\">    point = point.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"142-Linked-List-Cycle-II\"><a href=\"#142-Linked-List-Cycle-II\" class=\"headerlink\" title=\"[142] Linked List Cycle II\"></a>[142] Linked List Cycle II</h4><blockquote>\n<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>\n<p><strong>Notice</strong> that you <strong>should not modify</strong> the linked list.</p>\n</blockquote>\n<p>这里需要证明下有环情况下, 为什么快慢指针第一次相遇之后, 快指针到链表头, 再和慢指针一起以每次一步的速度前进, 当二者相等时, 即是环的起点.</p>\n<p><strong>证明</strong>:</p>\n<img src=\"/2020/09/11/Linked-list/image.png\" class=\"\" title=\"image.png\">\n<p>我们最终需要证明a=b. 假设链表总长度为L, 环的长度为R, 快慢指针第一次相遇的节点为M, 环的开始节点为C, 其中各个点之间的距离分别为 H-&gt;C=a, C-&gt;M=c, M-&gt;C=b, H-&gt;M=s. 第一次相遇时, 假设fast已经围绕着环走了n圈, 则有:</p>\n<p>由于快慢指针的速度差两倍, 所以相同时间内, 快指针走过的距离是慢指针的两倍.</p>\n<p>$2s = s + nR \\-&gt; s = nR \\tag{1}$</p>\n<p>已知慢指针走的长度为(套用$(1)$):</p>\n<p>$a+c = s \\-&gt; a+c=nR \\-&gt; a + c = (n-1)R + R \\-&gt; a = (n-1)R + (R - c) \\-&gt;  a = (n-1)R +b$</p>\n<p>则得出结论 $a=b$, (这个还要再想下).</p>\n<p>所以fast移动到head, slow位置不变, 两个同时开始走, 每次走一步, 当走了a步时,两者相遇的点即为环的起点.</p>\n<p><strong>时间复杂度</strong>:</p>\n<p>可知快慢指针走的步数是一样的, 只是一个快一个慢, 慢指针最后遍历了整个链表, 走了N步, 则快指针也走了N步, 则时间复杂度为: $2*O(N)= O(N)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用快慢指针</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> detectCycle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 快慢指针的起始点应该一样</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> fast = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (slow) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 快指针的速度是慢指针的2倍</span></span><br><span class=\"line\">    slow = slow.next;</span><br><span class=\"line\">    <span class=\"comment\">// 在没有环的情况下</span></span><br><span class=\"line\">    <span class=\"comment\">// fast指针会最先到达链表尾部, 直接返回null;</span></span><br><span class=\"line\">    <span class=\"comment\">// fast指针最后的位置,要不倒数第一,要不倒数第二</span></span><br><span class=\"line\">    <span class=\"comment\">// 与链表长度的奇偶数以及每次走的步数有关</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里fast指针是每次走两步</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fast.next) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    fast = fast.next.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fast) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明有环 两指针第一次相遇</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 快指针移动至链表头</span></span><br><span class=\"line\">      <span class=\"comment\">// 慢指针停在原地</span></span><br><span class=\"line\">      fast = head;</span><br><span class=\"line\">      <span class=\"comment\">// 二者均以每次一步的速度继续向前走, 直至再次相遇</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里方法需要证明</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (fast != slow) &#123;</span><br><span class=\"line\">        fast = fast.next;</span><br><span class=\"line\">        slow = slow.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 返回的是环的起始节点的指针</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"138-Copy-List-with-Random-Pointer\"><a href=\"#138-Copy-List-with-Random-Pointer\" class=\"headerlink\" title=\"[138] Copy List with Random Pointer\"></a>[138] Copy List with Random Pointer</h4><blockquote>\n<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\" rel=\"noopener\"><strong>deep copy</strong></a> of the list.</p>\n<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n<ul>\n<li><code>val</code>: an integer representing <code>Node.val</code></li>\n<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n</blockquote>\n<p><strong>时间复杂度:</strong> 遍历两遍数组 $O(N)$.</p>\n<p><strong>经验/收获</strong>: </p>\n<ol>\n<li>一开始我的问题在于试错, 都没有搞清楚<code>random_index</code>属性是否在题目给的链表结构中存在, 我还以为有<code>random_index</code>这个属性呢, 实际上没有.  <code>random</code>数据类型仍然是指针而非number.</li>\n<li>搞清楚题目是深拷贝, 不能改变原有链表结构. <strong>需要重新生成新链表</strong>.</li>\n<li>收获在于知道如何使用hashMap存储链表间的 links.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 题目要求是深拷贝</span></span><br><span class=\"line\"><span class=\"comment\">// 就是不改变原有的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 第一遍是copy all nodes, 使用map存储</span></span><br><span class=\"line\"><span class=\"comment\">// 第二遍是copy links</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> copyRandomList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// copy nodes</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(); <span class=\"comment\">// map的key可以是任何对象, 不限于字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    map.set(curr, <span class=\"keyword\">new</span> Node(curr.val));</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// copy links</span></span><br><span class=\"line\">  curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = map.get(curr);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    node.next = curr.next ? map.get(curr.next) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    node.random = curr.random ? map.get(curr.random) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">    node = node.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> map.get(head);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"92-Reverse-Linked-List-II\"><a href=\"#92-Reverse-Linked-List-II\" class=\"headerlink\" title=\"[92] Reverse Linked List II\"></a>[92] Reverse Linked List II</h4><blockquote>\n<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>\n<p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>\n</blockquote>\n<p><strong>时间复杂度分析</strong>:</p>\n<p>假设链表总长度为$N$, 在定位m/n节点的过程中, 一共遍历链表一次, 每次遍历至第n个节点, 最差情况遍历到链表末尾.</p>\n<p>翻转时一共需要翻转 $n-m+1$ 个节点, 需要的时间是 $ O(n-m+1)$ .</p>\n<p>所以时间复杂度为 $O(N)$ </p>\n<p><strong>注意</strong>:</p>\n<p>初始化一个节点时, hair不是空, hair.val是空. 刚开始判断pre==null就写错了, 应该是pre.val是否null.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reverseBetween = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"comment\">// 当链表长度足够翻转时, 在head前添加hair节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 为了使用pre节点, pre是pm的前一个节点</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair, curr = head;</span><br><span class=\"line\">  <span class=\"comment\">// 定义变量 注意需要tail指针</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pm, pn, tail;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定位m节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    pm = head; <span class=\"comment\">// pm直接是头节点</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// m-1次循环到达pm节点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; m - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// pre节点也需要同时向后移动</span></span><br><span class=\"line\">      <span class=\"comment\">// 保证在pm前一位</span></span><br><span class=\"line\">      curr = curr.next;</span><br><span class=\"line\">      pre = pre.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pm = curr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 定位n节点</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n - m; i++) &#123;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pn = curr;</span><br><span class=\"line\">  <span class=\"comment\">// 翻转前保留尾部数据</span></span><br><span class=\"line\">  tail = curr.next;</span><br><span class=\"line\">  <span class=\"comment\">// 翻转</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pm != pn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = pm.next;</span><br><span class=\"line\">    pm.next = tail;</span><br><span class=\"line\">    tail = pm;</span><br><span class=\"line\">    pm = temp;</span><br><span class=\"line\">    pre.next = tail;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// pm==pn时还需要连接下tail</span></span><br><span class=\"line\">  pm.next = tail;</span><br><span class=\"line\">  <span class=\"comment\">// 连接</span></span><br><span class=\"line\">  pre.next = pm;</span><br><span class=\"line\">  <span class=\"comment\">// 这里返回hair.next即可</span></span><br><span class=\"line\">  <span class=\"comment\">// 不用分析pre是否为空</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"147-Insertion-Sort-List\"><a href=\"#147-Insertion-Sort-List\" class=\"headerlink\" title=\"[147] Insertion Sort List\"></a>[147] Insertion Sort List</h4><blockquote>\n<p>Sort a linked list using insertion sort.</p>\n</blockquote>\n<p>时间复杂度分析:</p>\n<p>遍历链表一次, $O(N)$</p>\n<p>每到链表的一个节点, 就会扫描排好序的链表部分, 时间为 $O(1)+O(2)+O(3)+…+O(N-1)$</p>\n<p>则时间复杂度为: $O(1)+O(2)+…+O(N)=O((N^2+N)/2)=O(N^2)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用插入排序对链表进行排序</span></span><br><span class=\"line\"><span class=\"comment\">// 插入排序是: 不断将没有排序的元素加入已经排好序的部分</span></span><br><span class=\"line\"><span class=\"comment\">// 单向链表只能从前往后遍历</span></span><br><span class=\"line\"><span class=\"comment\">// 这里顺便学习了单向链表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insertionSortList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个元素默认已经排好序</span></span><br><span class=\"line\">  <span class=\"comment\">// curr 从下一位开始</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head.next;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  <span class=\"comment\">// 排好序的部分此时只有head一个元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 末尾指向null</span></span><br><span class=\"line\">  <span class=\"comment\">// 与需要排序的部分分开</span></span><br><span class=\"line\">  head.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cn, hn;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保留curr的后一部分</span></span><br><span class=\"line\">    cn = curr.next;</span><br><span class=\"line\">    <span class=\"comment\">// curr比有序的第一个元素小</span></span><br><span class=\"line\">    <span class=\"comment\">// 则直接置于有序部分的头部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr.val &lt;= head.val) &#123;</span><br><span class=\"line\">      curr.next = head;</span><br><span class=\"line\">      head = curr;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// curr 比第一个有序元素大</span></span><br><span class=\"line\">      <span class=\"comment\">// 则需要遍历后面的有序元素</span></span><br><span class=\"line\">      <span class=\"comment\">// 直到找到有序排列中比curr大的元素x</span></span><br><span class=\"line\">      <span class=\"comment\">// 则curr插入到 x的前面</span></span><br><span class=\"line\">      <span class=\"comment\">// 为了保留 x 的前一个节点</span></span><br><span class=\"line\">      <span class=\"comment\">// 将curr.val与h.next.val进行比较, 而不是h.val</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> h = head;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (h.next &amp;&amp; curr.val &gt; h.next.val) &#123;</span><br><span class=\"line\">        h = h.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 将curr插入至 h 与 x 节点之间</span></span><br><span class=\"line\">      hn = h.next;</span><br><span class=\"line\">      h.next = curr;</span><br><span class=\"line\">      curr.next = hn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// curr向后移动一位</span></span><br><span class=\"line\">    curr = cn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"203-Remove-Linked-List-Elements\"><a href=\"#203-Remove-Linked-List-Elements\" class=\"headerlink\" title=\"[203] Remove Linked List Elements\"></a>[203] Remove Linked List Elements</h4><blockquote>\n<p>Remove all elements from a linked list of integers that have value <strong><em>val\\</em></strong>.</p>\n</blockquote>\n<p>时间复杂度: 遍历链表 $O(N)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> removeElements = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair, curr = head;</span><br><span class=\"line\">  <span class=\"comment\">// pre的移动也是在head表示的这条链表上</span></span><br><span class=\"line\">  <span class=\"comment\">// pre改变的是head本身</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr.val == val) &#123;</span><br><span class=\"line\">      pre.next = curr.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pre = curr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 有个特殊情况需要注意</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如 [1] 1</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时pre还没后移到head链表上</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以pre指向null没有改变head链表</span></span><br><span class=\"line\">  <span class=\"comment\">// head仍然是 [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"206-Reverse-Linked-List\"><a href=\"#206-Reverse-Linked-List\" class=\"headerlink\" title=\"[206] Reverse Linked List\"></a>[206] Reverse Linked List</h4><blockquote>\n<p>Reverse a singly linked list.</p>\n<p><strong>Follow up:</strong></p>\n<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n</blockquote>\n<p><strong>递归过程</strong>需要详细的过程分析图(<strong>TO DO</strong>).</p>\n<p>两种时间复杂度均为 $O(N)$. </p>\n<p>递归方法的时间复杂度分析: 遍历整个链表, 递归调用N次.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代翻转</span></span><br><span class=\"line\"><span class=\"comment\">// 空间复杂度 O(1)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverseList1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rever = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">    temp = head.next;</span><br><span class=\"line\">    head.next = rever.next;</span><br><span class=\"line\">    rever.next = head;</span><br><span class=\"line\">    head = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rever.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归翻转</span></span><br><span class=\"line\"><span class=\"comment\">// 需要注意的是, p是指向head的一个指针</span></span><br><span class=\"line\"><span class=\"comment\">// 并不是另外的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 但是由于每一次都会生成p指针重新指向目前已经倒好序的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 所以递归过程中的空间复杂度为O(1)+O(2)+...+O(N)=O(N)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverseList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = reverseList(head.next);</span><br><span class=\"line\">  head.next.next = head;</span><br><span class=\"line\">  head.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"237-Delete-Node-in-a-Linked-List\"><a href=\"#237-Delete-Node-in-a-Linked-List\" class=\"headerlink\" title=\"[237] Delete Node in a Linked List\"></a>[237] Delete Node in a Linked List</h4><blockquote>\n<p>Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p>\n<p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p>\n</blockquote>\n<p>注意看题目条件, 时间/空间复杂度均为 $O(N)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一时没有想起来用什么解法</span></span><br><span class=\"line\"><span class=\"comment\">// 因为之前删除节点都是不能改变节点自身的值</span></span><br><span class=\"line\"><span class=\"comment\">// 现在这个能改变了 害</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法令我哭笑不得, 也提醒自己注意看题目条件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleteNode = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    node.val = node.next.val;</span><br><span class=\"line\">    node.next = node.next.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"234-Palindrome-Linked-List\"><a href=\"#234-Palindrome-Linked-List\" class=\"headerlink\" title=\"[234] Palindrome Linked List\"></a>[234] Palindrome Linked List</h4><blockquote>\n<p>Given a singly linked list, determine if it is a palindrome.</p>\n<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>\n</blockquote>\n<p>时间复杂度: </p>\n<p>遍历链表一次, $O(N)$, 后半部分翻转链表的时候, 时间为$O(N/2)$.</p>\n<p>所以时间复杂度为: $O(N)+O(N/2)=O(N)$.</p>\n<p>方法:</p>\n<p>判断回文链表,要求只能遍历一次链表.</p>\n<p>将链表<strong>后半段翻转</strong> 再将前后部分分别比较.</p>\n<p>然后还有需要注意的是: <strong>快慢指针法寻找链表中心点</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isPalindrome = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fast = head, slow = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class=\"line\">    fast = fast.next.next;</span><br><span class=\"line\">    slow = slow.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不管链表长度是奇数还是偶数 需要进行的操作都是一样的</span></span><br><span class=\"line\">  <span class=\"comment\">// slow 为后半部分链表的起点</span></span><br><span class=\"line\">  slow.next = reverse(slow.next);</span><br><span class=\"line\">  slow = slow.next;</span><br><span class=\"line\">  <span class=\"comment\">// 将前后两部分链表逐个节点对值进行比较</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有值不等 说明不是回文</span></span><br><span class=\"line\">  <span class=\"comment\">// 前半部分的长度是&gt;=后半部分的</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以当slow=null时, head=null或者head是最后一个节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于回文的两种形式, 此时就可以结束比较了</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (slow) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head.val != slow.val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head.next;</span><br><span class=\"line\">    slow = slow.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 翻转链表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverse = <span class=\"function\">(<span class=\"params\">head</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head, cn, rn;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    cn = curr.next;</span><br><span class=\"line\">    rn = res.next;</span><br><span class=\"line\">    res.next = curr;</span><br><span class=\"line\">    curr.next = rn;</span><br><span class=\"line\">    curr = cn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"160-Intersection-of-Two-Linked-Lists\"><a href=\"#160-Intersection-of-Two-Linked-Lists\" class=\"headerlink\" title=\"[160] Intersection of Two Linked Lists\"></a>[160] Intersection of Two Linked Lists</h4><blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p><strong>Notes:</strong></p>\n<ul>\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n<li>The linked lists must retain their original structure after the function returns.</li>\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n<li>Each value on each linked list is in the range <code>[1, 10^9]</code>.</li>\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n</blockquote>\n<img src=\"/2020/09/11/Linked-list/image1.png\" class=\"\" title=\"image1.png\">\n<p>由图可知:</p>\n<p>$headA = A + C$</p>\n<p>$headB = B + C$</p>\n<p>所以:</p>\n<p>$newA = headA + headB = A + C + B + C$</p>\n<p>$newB = headB + headA = B + C + A + C$</p>\n<p>已知:</p>\n<p>$A + C + B = B + C + A$</p>\n<p>所以 <code>newA</code>与<code>newB</code>同时出发, 每次都走一步. </p>\n<p><code>newA</code>走完<code>headA</code>再走完<code>B</code>,  <code>newB</code>走完<code>headB</code>再走完<code>A</code>, 如果两者有交点, 则此时会相等且不为<code>null</code>;</p>\n<p>如果不相交, 则走到最后两者也相等, 但是为<code>null</code>.</p>\n<p>时间复杂度:</p>\n<p>假设<code>headA</code>和<code>headB</code>总共的长度为<code>N</code>, 则一共遍历了两次, 时间为$2*O(N)$, 时间复杂度为$O(N)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路很巧妙 需要分析下 最后两个节点一定会相等</span></span><br><span class=\"line\"><span class=\"comment\">// 只是是地址还是null的问题</span></span><br><span class=\"line\"><span class=\"comment\">// 最差情况是不相交</span></span><br><span class=\"line\"><span class=\"comment\">// 每个链表均遍历了两遍</span></span><br><span class=\"line\"><span class=\"comment\">// 但是额外空间只使用了两个指针变量,为常数级</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getIntersectionNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">headA, headB</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currA = headA, currB = headB;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (currA != currB) &#123;</span><br><span class=\"line\">    currA = !currA ? headB : currA.next;</span><br><span class=\"line\">    currB = !currB ? headA : currB.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不相交最后也会相等的 均是null</span></span><br><span class=\"line\">  <span class=\"comment\">// 即： 相交或者是不相交， 二者均会相等</span></span><br><span class=\"line\">  <span class=\"comment\">// 相等的话，返回的是及交点地址</span></span><br><span class=\"line\">  <span class=\"comment\">// 不相等的话，返回的是null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> currA;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"328-Odd-Even-Linked-List\"><a href=\"#328-Odd-Even-Linked-List\" class=\"headerlink\" title=\"[328] Odd Even Linked List\"></a>[328] Odd Even Linked List</h4><blockquote>\n<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>\n<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>\n</blockquote>\n<p>时间复杂度: 两个指针同时遍历, 一共遍历一遍链表. $O(N)$</p>\n<p>空间复杂度: 只是新建了两个指针, 改动原有链表, 没有重新生成head的copy版本. $O(1)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 完全自己想的法子 太棒了</span></span><br><span class=\"line\"><span class=\"comment\">// 大体思路就是,用两个指针, 一个指向奇数节点, 一个指向偶数节点</span></span><br><span class=\"line\"><span class=\"comment\">// 遍历完head之后, 再将两个链表进行拼接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oddEvenList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next || !head.next.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oddList = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> evenList = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> odd = oddList, even = evenList;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化第一个奇数节点</span></span><br><span class=\"line\">  odd.next = head;</span><br><span class=\"line\">  odd = odd.next;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化第一个偶数节点</span></span><br><span class=\"line\">  even.next = head.next;</span><br><span class=\"line\">  even = even.next;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (even &amp;&amp; even.next) &#123;</span><br><span class=\"line\">    odd.next = odd.next.next;</span><br><span class=\"line\">    odd = odd.next;</span><br><span class=\"line\">    even.next = even.next.next;</span><br><span class=\"line\">    even = even.next;</span><br><span class=\"line\">    <span class=\"comment\">// 链表长度为奇数 此时 even==null</span></span><br><span class=\"line\">    <span class=\"comment\">// 链表长度为偶数 此时 even.next==null</span></span><br><span class=\"line\">    <span class=\"comment\">// 两种情况的任何一种情况都应该退出循环</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 对奇数链与偶数链进行拼接</span></span><br><span class=\"line\">  odd.next = evenList.next;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> oddList.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"725-Split-Linked-List-in-Parts\"><a href=\"#725-Split-Linked-List-in-Parts\" class=\"headerlink\" title=\"[725] Split Linked List in Parts\"></a>[725] Split Linked List in Parts</h4><blockquote>\n<p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p>\n<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>\n<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>\n<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>\n<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>\n</blockquote>\n<p>理解题意 一共分为 k 部分 而不是长度是 k !!</p>\n<p><em>时间复杂度*</em>:</p>\n<p>在计算链表长度时, 遍历了一次. 后面将链表片段加入时, 又遍历了一遍.</p>\n<p>所以时间复杂度为 $O(N+k)$, 在<code>k&gt;len</code>时, 需要继续向结果中加入片段.</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>生成<code>answer</code>时res数组中包含的节点个数, <code>k&gt;len</code>, k个链表节点, 反之, len个链表节点. 所以空间复杂度为$O(max(N, k))$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> splitListToParts = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">root, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先计算root的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = root, len = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    len++;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curr = root;</span><br><span class=\"line\">  <span class=\"comment\">// 计算宽度</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> width = <span class=\"built_in\">Math</span>.floor(len / k);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> extra = len % k; <span class=\"comment\">// 需要长度被加一的组数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []; <span class=\"comment\">// 初始化长度为k的结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当k&lt;=len的时候,curr指向null时, for循环也就结束了</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为组数已经达到了k组</span></span><br><span class=\"line\">    <span class=\"comment\">// 出现curr为null的情况时, 并且走到了这里</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明k&gt;len</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时只需要将null不断加入数组直至数组长度达到k</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!curr) &#123;</span><br><span class=\"line\">      res.push(<span class=\"literal\">null</span>);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 多余没有入组的元素需要加入前面的每一个组</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此前extra组, 每组的元素长度需要+1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = i &lt; extra ? width + <span class=\"number\">1</span> : width;</span><br><span class=\"line\">    <span class=\"comment\">// l-1是为了控制curr指向part的最后一个元素而不是下一个</span></span><br><span class=\"line\">    <span class=\"comment\">// 便于将该链表片段加入res</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; l - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      curr = curr.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// curr 到达part的最后一个元素      </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cn = curr.next;</span><br><span class=\"line\">    curr.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    res.push(root);</span><br><span class=\"line\">    curr = root = cn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"445-Add-Two-Numbers-II\"><a href=\"#445-Add-Two-Numbers-II\" class=\"headerlink\" title=\"[445] Add Two Numbers II\"></a>[445] Add Two Numbers II</h4><blockquote>\n<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p><strong>Follow up:</strong><br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>\n</blockquote>\n<p>题目要求不能翻转链表, 于是遍历链表, 将链表中的数都存进栈中. 再通过将栈弹出, 进行相加操作.</p>\n<p><strong>时间复杂度</strong>:</p>\n<p>遍历两个链表, O(N). 两个栈均弹出进行相加操作, O(N). 因此时间为 $2O(N)=O(N)$</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>使用两个栈存储数字, O(N), 相加之后得到新的结果列表的长度 O(max(m, n)) ps.是两个链表中较长的那一个Lmax, 结果链表长度可能由于进位问题会是Lmax+1, 因此空间复杂度为 $O(N)+O(max(m, n))$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不能够翻转链表</span></span><br><span class=\"line\"><span class=\"comment\">// 使用两个栈存储数字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将两个链表中的值分别存进两个栈中</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> stack1 = [], stack2 = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1) &#123;</span><br><span class=\"line\">    stack1.push(l1.val);</span><br><span class=\"line\">    l1 = l1.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l2) &#123;</span><br><span class=\"line\">    stack2.push(l2.val);</span><br><span class=\"line\">    l2 = l2.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化变量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, carry = <span class=\"number\">0</span>, num = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>), rn;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> add1, add2;</span><br><span class=\"line\">  <span class=\"comment\">// 当两个栈有至少一个不为空时, 都进行相加操作</span></span><br><span class=\"line\">  <span class=\"comment\">// 为空的那个栈的加数为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (stack1.length != <span class=\"number\">0</span> || stack2.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    add1 = stack1.length == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : stack1.pop();</span><br><span class=\"line\">    add2 = stack2.length == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : stack2.pop();</span><br><span class=\"line\">    sum = add1 + add2 + carry;</span><br><span class=\"line\">    <span class=\"comment\">// 商是进位 大于10为1,小于10为0</span></span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(sum / <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 余数是相加之后结果中的数字</span></span><br><span class=\"line\">    num = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将结果添加进结果列表中</span></span><br><span class=\"line\">    rn = res.next;</span><br><span class=\"line\">    res.next = <span class=\"keyword\">new</span> ListNode(num);</span><br><span class=\"line\">    res.next.next = rn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当两个链表均为空时, 看是否还有进位</span></span><br><span class=\"line\">  <span class=\"comment\">// 有进位则添加进结果列表中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (carry != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rn = res.next;</span><br><span class=\"line\">    res.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">    res.next.next = rn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"2-Add-Two-Numbers\"><a href=\"#2-Add-Two-Numbers\" class=\"headerlink\" title=\"[2] Add Two Numbers\"></a>[2] Add Two Numbers</h4><blockquote>\n<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n</blockquote>\n<p>复杂的数据结构是我的超级短板. 但是也算勉强看懂了js是如何表示链表的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l1</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l2</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 这个链表的存储结构是嵌套的, 即next指向的是嵌套的.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义存储想关节点的变量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> lastNode = result;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> carry = <span class=\"number\">0</span>; <span class=\"comment\">// 进位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>; <span class=\"comment\">// 相加之后赋给当前位置的值</span></span><br><span class=\"line\">  <span class=\"comment\">// 当l1或者l2任何一方有值时, 都需要进行相加</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1 || l2) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取两个链表的初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = l1 == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : l1.val;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> y = l2 == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : l2.val;</span><br><span class=\"line\">    <span class=\"comment\">// 两者相加</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = x + y + carry;</span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(num / <span class=\"number\">10</span>); <span class=\"comment\">// 商</span></span><br><span class=\"line\">    val = num % <span class=\"number\">10</span>; <span class=\"comment\">// 相加之后赋给当前位置的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 新建节点添加到链表末尾</span></span><br><span class=\"line\">    lastNode.next = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">    <span class=\"comment\">// 最后节点位置更新</span></span><br><span class=\"line\">    lastNode = lastNode.next;</span><br><span class=\"line\">    <span class=\"comment\">// 进行下一位置的加法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1 !== <span class=\"literal\">null</span>) l1 = l1.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l2 !== <span class=\"literal\">null</span>) l2 = l2.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当两个加数位数都加完了</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是仍然可能会有进位的可能</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (carry != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    lastNode.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">示例结果</span></span><br><span class=\"line\"><span class=\"comment\">====result.next</span></span><br><span class=\"line\"><span class=\"comment\">ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  val: 7,</span></span><br><span class=\"line\"><span class=\"comment\">  next: ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    val: 0,</span></span><br><span class=\"line\"><span class=\"comment\">    next: ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      val: 8,</span></span><br><span class=\"line\"><span class=\"comment\">      next: null</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"21-Merge-Two-Sorted-Lists\"><a href=\"#21-Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"[21] Merge Two Sorted Lists\"></a>[21] Merge Two Sorted Lists</h4><blockquote>\n<p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p>\n</blockquote>\n<p>解题的重点在于, 一直将l1和l2的链表头作比较, 不断将较小的node加入结果链表, 直至l1或者l2为空, 说明遍历结束. 把不为空的链表剩余的部分直接接入结果列表.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mergeTwoLists = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理有链表为空的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = res;</span><br><span class=\"line\">  <span class=\"comment\">// 网上的做法好简洁</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class=\"line\">      curr.next = l2;</span><br><span class=\"line\">      l2 = l2.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      curr.next = l1;</span><br><span class=\"line\">      l1 = l1.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curr.next = l1 == <span class=\"literal\">null</span> ? l2 : l1;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"24-Swap-Nodes-in-Pairs\"><a href=\"#24-Swap-Nodes-in-Pairs\" class=\"headerlink\" title=\"[24] Swap Nodes in Pairs\"></a>[24] Swap Nodes in Pairs</h4><blockquote>\n<p>Given a linked list, swap every two adjacent nodes and return its head.</p>\n<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>\n</blockquote>\n<p>在交换链表的时候, 第一次交换需要记住链表头.</p>\n<p>确定 <code>curr</code> 之后, 只有 <code>curr.next!=null</code> 时才有交换的必要, 否则说明交换到头了, 返回 <code>head</code> 即可.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">head</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> swapPairs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 第一次交换的时候 需要记住链表头 后面就不需要了</span></span><br><span class=\"line\">  <span class=\"comment\">// 只有当 curr.next 也有值的时候, 才交换</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则就直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr &amp;&amp; curr.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = curr.next.next;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextNode = curr.next;</span><br><span class=\"line\">    nextNode.next = curr;</span><br><span class=\"line\">    left.next = nextNode;</span><br><span class=\"line\">    curr.next = temp;</span><br><span class=\"line\">    left = curr;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">      head = nextNode;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"61-Rotate-List\"><a href=\"#61-Rotate-List\" class=\"headerlink\" title=\"[61] Rotate List\"></a>[61] Rotate List</h4><blockquote>\n<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">head</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">k</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * 大体思路是: </span></span><br><span class=\"line\"><span class=\"comment\"> * 先计算出链表的长度len, 再将k与len进行比较, </span></span><br><span class=\"line\"><span class=\"comment\"> * k&gt;len的话, 将k中len的整数倍减去之后, 就是最后需要移动的元素的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rotateRight = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 计算链表长度</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时right指向最后一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = head, right = head, len = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (right.next) &#123;</span><br><span class=\"line\">    right = right.next;</span><br><span class=\"line\">    len++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span> || k == len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 取余之后是实际上需要移动的元素</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = k % len;</span><br><span class=\"line\">  <span class=\"comment\">// 由于在计算链表长度的时候, right已经指向链表尾部</span></span><br><span class=\"line\">  <span class=\"comment\">// 左右指针间隔k-1个元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以左指针需要向右移动len-num-1个位置</span></span><br><span class=\"line\">  <span class=\"comment\">// 具体的边界条件可以在测试中验证是否正确</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - num - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    left = left.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  right.next = head;</span><br><span class=\"line\">  head = left.next;</span><br><span class=\"line\">  left.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"23-Merge-k-Sorted-Lists\"><a href=\"#23-Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"[23] Merge k Sorted Lists\"></a>[23] Merge k Sorted Lists</h4><blockquote>\n<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n</blockquote>\n<p><strong>solution1</strong> 的时间复杂度分析:</p>\n<p>时间复杂度: 遍历链表+排序+遍历数组<br>    假设总node数为 $N$ , 则总时间复杂度为 $O(N)+O(NlogN)+O(N)=O(N)$<br>空间复杂度为: $O(N)$ , 主要是存储节点的数组的消耗</p>\n<p><strong>solution2</strong> 的时间复杂度分析:</p>\n<p>设k=lists.length, $N$ 为所有节点数, 则复杂度为=归并次数<em>每一次归并的时间复杂度<br>每一次归并需要遍历所有的节点, 但是不需要排序, 仅仅是大小比较, $O(N)$<br>设一共归并的次数为x, 则有 $2^x = k$ , 则 $ x = \\log_2 k$ (以2为底k的对数)<br>所以总共的时间复杂度是 $\\sum_0^x </em> O(N)=O(N\\log k)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1</span></span><br><span class=\"line\"><span class=\"comment\">// 把链表中的节点值都拿出来放在一个数组里</span></span><br><span class=\"line\"><span class=\"comment\">// 然后对数组进行排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeKLists1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">lists</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = lists.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [], l;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    l = lists[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l) &#123;</span><br><span class=\"line\">      arr.push(l.val);</span><br><span class=\"line\">      l = l.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b); <span class=\"comment\">// 正序排列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = res;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    curr.next = <span class=\"keyword\">new</span> ListNode(arr[i]);</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// solution 2</span></span><br><span class=\"line\"><span class=\"comment\">// 分治算法 这是一开始就想到的方法 但是不会实现🤦‍♀️</span></span><br><span class=\"line\"><span class=\"comment\">// 两两链表合并排序, 再将结果再合并, 直至只有一个结果</span></span><br><span class=\"line\"><span class=\"comment\">// 数组长度为奇数, 最后一次合并时, 是第一个与最后一个元素合并, interval*2之后会&lt;len, 继续进行最后一次合并</span></span><br><span class=\"line\"><span class=\"comment\">// 数组长度为奇数, 最后一次合并时, 是第一个与中间元素合并, interval*2之后会=len, 跳出循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeKLists = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">lists</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = lists.length;</span><br><span class=\"line\">  <span class=\"comment\">// 没有链表返回空链表</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> interval = <span class=\"number\">1</span>;<span class=\"comment\">// 标志需要合并的两个链表之间的距离</span></span><br><span class=\"line\">  <span class=\"comment\">// 归并排序的代码更像模板</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要两个元素之间的距离没有超过数组长度, 说明没有归并完毕</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (interval &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - interval; i = i + interval * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// i的作用是, 找到所有需要合并的链表中的第一个</span></span><br><span class=\"line\">      <span class=\"comment\">// 不断地把相隔interval距离的两个链表合并</span></span><br><span class=\"line\">      lists[i] = mergeTwoLists(lists[i], lists[i + interval])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interval = interval * <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> lists[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个链表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeTwoLists = <span class=\"function\">(<span class=\"params\">l1, l2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!l1) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!l2) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = res;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">      curr.next = l1;</span><br><span class=\"line\">      l1 = l1.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      curr.next = l2;</span><br><span class=\"line\">      l2 = l2.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curr.next = l1 == <span class=\"literal\">null</span> ? l2 : l1;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"25-Reverse-Nodes-in-k-Group\"><a href=\"#25-Reverse-Nodes-in-k-Group\" class=\"headerlink\" title=\"[25] Reverse Nodes in k-Group\"></a>[25] Reverse Nodes in k-Group</h4><blockquote>\n<p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>\n<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>\n</blockquote>\n<p>时间复杂度分析:</p>\n<p>$O(N)$ , $N$为链表总节点数, 翻转时需要遍历所有的节点. 一共会进行$\\lfloor N/k \\rfloor$ 次翻转, 每一次翻转需要$O(k)$的时间.</p>\n<p>空间复杂度: 常量级别.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 大体思路是 每k个元素进行一次翻转</span></span><br><span class=\"line\"><span class=\"comment\">// 在翻转之前查看接下来的链表长度是否足够</span></span><br><span class=\"line\"><span class=\"comment\">// 足够则翻转 不够则停下并返回结果</span></span><br><span class=\"line\"><span class=\"comment\">// 翻转时注意连接前后链表的部分</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverseKGroup = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在链表头节点前加一个节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 后面翻转后的链表再与原来的链表连接要用到</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair;</span><br><span class=\"line\">  <span class=\"comment\">// tail需要以pre为起点, 向后移动k个位置</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tail = hair, right;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tail) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将 tail 移动至需要翻转的链表部分的末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">      tail = tail.next;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 tail 在向后移动但是还没有到目标位置时</span></span><br><span class=\"line\">      <span class=\"comment\">// 出现 tail 为 null 的情况</span></span><br><span class=\"line\">      <span class=\"comment\">// 说明剩余的元素已经不够翻转的数量</span></span><br><span class=\"line\">      <span class=\"comment\">// 直接返回现有结果即可</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!tail) <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// head-tail的链表部分需要翻转</span></span><br><span class=\"line\">    <span class=\"comment\">// 且翻转需要head和tail仍指向翻转后链表的头和尾</span></span><br><span class=\"line\">    <span class=\"comment\">// 保留tail的后面部分</span></span><br><span class=\"line\">    right = tail.next;</span><br><span class=\"line\">    [head, tail] = reverse(head, tail);</span><br><span class=\"line\">    <span class=\"comment\">// 进行与原链表的拼接</span></span><br><span class=\"line\">    pre.next = head;</span><br><span class=\"line\">    tail.next = right;</span><br><span class=\"line\">    <span class=\"comment\">// 改变pre head的位置</span></span><br><span class=\"line\">    pre = tail;</span><br><span class=\"line\">    head = right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 翻转链表</span></span><br><span class=\"line\"><span class=\"comment\">// 这里不用再初始化res来存储翻转后的结果</span></span><br><span class=\"line\"><span class=\"comment\">// 因为tail.next是存在的</span></span><br><span class=\"line\"><span class=\"comment\">// 可以看做已有的res使用</span></span><br><span class=\"line\"><span class=\"comment\">// 使用常数级的内存空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverse = <span class=\"function\">(<span class=\"params\">head, tail</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> remain = tail.next; <span class=\"comment\">// 表示剩余不用翻转的部分</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nex;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p !== tail) &#123;</span><br><span class=\"line\">    nex = p.next;</span><br><span class=\"line\">    p.next = remain;</span><br><span class=\"line\">    remain = p;</span><br><span class=\"line\">    p = nex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  tail.next = remain;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [tail, head];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"#83-Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"[83] Remove Duplicates from Sorted List\"></a>[83] Remove Duplicates from Sorted List</h4><blockquote>\n<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>\n</blockquote>\n<p>思路比较简单, 由于最坏情况是遍历链表的所有节点(当所有节点的值均不相同),  时间复杂度为 $O(N)$ .</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于是排过序的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 所以重复元素都会在一块</span></span><br><span class=\"line\"><span class=\"comment\">// 不断比较curr与curr.next的val是否相等</span></span><br><span class=\"line\"><span class=\"comment\">// 相等则跳过该重复元素,不等才改变curr的位置</span></span><br><span class=\"line\"><span class=\"comment\">// 直至curr遍历完链表的所有元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleteDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最后一个元素是不同元素 到达链表末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!curr.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr.val == curr.next.val) &#123;</span><br><span class=\"line\">      curr.next = curr.next.next;</span><br><span class=\"line\">      <span class=\"comment\">// 最后一个元素是相同元素 到达链表末尾</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!curr.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"82-Remove-Duplicates-from-Sorted-List-II\"><a href=\"#82-Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"[82] Remove Duplicates from Sorted List II\"></a>[82] Remove Duplicates from Sorted List II</h4><blockquote>\n<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>\n<p>Return the linked list sorted as well.</p>\n</blockquote>\n<p>遍历链表的所有节点两次,  时间复杂度为 $2*O(N) = O(N)$ .</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历两次链表</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次按照顺序将所有不同的元素组成链表, 并给有重复元素的节点增加dup属性</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次将有dup属性的节点删除, 返回结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleteDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!curr.next) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr.val == curr.next.val) &#123;</span><br><span class=\"line\">      curr.dup = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      curr.next = curr.next.next;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!curr.next) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair, point = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (point) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (point.dup) &#123;</span><br><span class=\"line\">      point = point.next;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!point) &#123;</span><br><span class=\"line\">        pre.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre.next = point;</span><br><span class=\"line\">    pre = point;</span><br><span class=\"line\">    point = point.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"142-Linked-List-Cycle-II\"><a href=\"#142-Linked-List-Cycle-II\" class=\"headerlink\" title=\"[142] Linked List Cycle II\"></a>[142] Linked List Cycle II</h4><blockquote>\n<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>\n<p><strong>Notice</strong> that you <strong>should not modify</strong> the linked list.</p>\n</blockquote>\n<p>这里需要证明下有环情况下, 为什么快慢指针第一次相遇之后, 快指针到链表头, 再和慢指针一起以每次一步的速度前进, 当二者相等时, 即是环的起点.</p>\n<p><strong>证明</strong>:</p>\n<img src=\"/2020/09/11/Linked-list/image.png\" class=\"\" title=\"image.png\">\n<p>我们最终需要证明a=b. 假设链表总长度为L, 环的长度为R, 快慢指针第一次相遇的节点为M, 环的开始节点为C, 其中各个点之间的距离分别为 H-&gt;C=a, C-&gt;M=c, M-&gt;C=b, H-&gt;M=s. 第一次相遇时, 假设fast已经围绕着环走了n圈, 则有:</p>\n<p>由于快慢指针的速度差两倍, 所以相同时间内, 快指针走过的距离是慢指针的两倍.</p>\n<p>$2s = s + nR \\-&gt; s = nR \\tag{1}$</p>\n<p>已知慢指针走的长度为(套用$(1)$):</p>\n<p>$a+c = s \\-&gt; a+c=nR \\-&gt; a + c = (n-1)R + R \\-&gt; a = (n-1)R + (R - c) \\-&gt;  a = (n-1)R +b$</p>\n<p>则得出结论 $a=b$, (这个还要再想下).</p>\n<p>所以fast移动到head, slow位置不变, 两个同时开始走, 每次走一步, 当走了a步时,两者相遇的点即为环的起点.</p>\n<p><strong>时间复杂度</strong>:</p>\n<p>可知快慢指针走的步数是一样的, 只是一个快一个慢, 慢指针最后遍历了整个链表, 走了N步, 则快指针也走了N步, 则时间复杂度为: $2*O(N)= O(N)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用快慢指针</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> detectCycle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 快慢指针的起始点应该一样</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> fast = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (slow) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 快指针的速度是慢指针的2倍</span></span><br><span class=\"line\">    slow = slow.next;</span><br><span class=\"line\">    <span class=\"comment\">// 在没有环的情况下</span></span><br><span class=\"line\">    <span class=\"comment\">// fast指针会最先到达链表尾部, 直接返回null;</span></span><br><span class=\"line\">    <span class=\"comment\">// fast指针最后的位置,要不倒数第一,要不倒数第二</span></span><br><span class=\"line\">    <span class=\"comment\">// 与链表长度的奇偶数以及每次走的步数有关</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里fast指针是每次走两步</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fast.next) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    fast = fast.next.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fast) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明有环 两指针第一次相遇</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 快指针移动至链表头</span></span><br><span class=\"line\">      <span class=\"comment\">// 慢指针停在原地</span></span><br><span class=\"line\">      fast = head;</span><br><span class=\"line\">      <span class=\"comment\">// 二者均以每次一步的速度继续向前走, 直至再次相遇</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里方法需要证明</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (fast != slow) &#123;</span><br><span class=\"line\">        fast = fast.next;</span><br><span class=\"line\">        slow = slow.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 返回的是环的起始节点的指针</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"138-Copy-List-with-Random-Pointer\"><a href=\"#138-Copy-List-with-Random-Pointer\" class=\"headerlink\" title=\"[138] Copy List with Random Pointer\"></a>[138] Copy List with Random Pointer</h4><blockquote>\n<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\" rel=\"noopener\"><strong>deep copy</strong></a> of the list.</p>\n<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n<ul>\n<li><code>val</code>: an integer representing <code>Node.val</code></li>\n<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n</blockquote>\n<p><strong>时间复杂度:</strong> 遍历两遍数组 $O(N)$.</p>\n<p><strong>经验/收获</strong>: </p>\n<ol>\n<li>一开始我的问题在于试错, 都没有搞清楚<code>random_index</code>属性是否在题目给的链表结构中存在, 我还以为有<code>random_index</code>这个属性呢, 实际上没有.  <code>random</code>数据类型仍然是指针而非number.</li>\n<li>搞清楚题目是深拷贝, 不能改变原有链表结构. <strong>需要重新生成新链表</strong>.</li>\n<li>收获在于知道如何使用hashMap存储链表间的 links.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 题目要求是深拷贝</span></span><br><span class=\"line\"><span class=\"comment\">// 就是不改变原有的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 第一遍是copy all nodes, 使用map存储</span></span><br><span class=\"line\"><span class=\"comment\">// 第二遍是copy links</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> copyRandomList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// copy nodes</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(); <span class=\"comment\">// map的key可以是任何对象, 不限于字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    map.set(curr, <span class=\"keyword\">new</span> Node(curr.val));</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// copy links</span></span><br><span class=\"line\">  curr = head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = map.get(curr);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    node.next = curr.next ? map.get(curr.next) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    node.random = curr.random ? map.get(curr.random) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">    node = node.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> map.get(head);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"92-Reverse-Linked-List-II\"><a href=\"#92-Reverse-Linked-List-II\" class=\"headerlink\" title=\"[92] Reverse Linked List II\"></a>[92] Reverse Linked List II</h4><blockquote>\n<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>\n<p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>\n</blockquote>\n<p><strong>时间复杂度分析</strong>:</p>\n<p>假设链表总长度为$N$, 在定位m/n节点的过程中, 一共遍历链表一次, 每次遍历至第n个节点, 最差情况遍历到链表末尾.</p>\n<p>翻转时一共需要翻转 $n-m+1$ 个节点, 需要的时间是 $ O(n-m+1)$ .</p>\n<p>所以时间复杂度为 $O(N)$ </p>\n<p><strong>注意</strong>:</p>\n<p>初始化一个节点时, hair不是空, hair.val是空. 刚开始判断pre==null就写错了, 应该是pre.val是否null.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reverseBetween = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"comment\">// 当链表长度足够翻转时, 在head前添加hair节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 为了使用pre节点, pre是pm的前一个节点</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair, curr = head;</span><br><span class=\"line\">  <span class=\"comment\">// 定义变量 注意需要tail指针</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pm, pn, tail;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定位m节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    pm = head; <span class=\"comment\">// pm直接是头节点</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// m-1次循环到达pm节点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; m - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// pre节点也需要同时向后移动</span></span><br><span class=\"line\">      <span class=\"comment\">// 保证在pm前一位</span></span><br><span class=\"line\">      curr = curr.next;</span><br><span class=\"line\">      pre = pre.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pm = curr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 定位n节点</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n - m; i++) &#123;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pn = curr;</span><br><span class=\"line\">  <span class=\"comment\">// 翻转前保留尾部数据</span></span><br><span class=\"line\">  tail = curr.next;</span><br><span class=\"line\">  <span class=\"comment\">// 翻转</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pm != pn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = pm.next;</span><br><span class=\"line\">    pm.next = tail;</span><br><span class=\"line\">    tail = pm;</span><br><span class=\"line\">    pm = temp;</span><br><span class=\"line\">    pre.next = tail;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// pm==pn时还需要连接下tail</span></span><br><span class=\"line\">  pm.next = tail;</span><br><span class=\"line\">  <span class=\"comment\">// 连接</span></span><br><span class=\"line\">  pre.next = pm;</span><br><span class=\"line\">  <span class=\"comment\">// 这里返回hair.next即可</span></span><br><span class=\"line\">  <span class=\"comment\">// 不用分析pre是否为空</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"147-Insertion-Sort-List\"><a href=\"#147-Insertion-Sort-List\" class=\"headerlink\" title=\"[147] Insertion Sort List\"></a>[147] Insertion Sort List</h4><blockquote>\n<p>Sort a linked list using insertion sort.</p>\n</blockquote>\n<p>时间复杂度分析:</p>\n<p>遍历链表一次, $O(N)$</p>\n<p>每到链表的一个节点, 就会扫描排好序的链表部分, 时间为 $O(1)+O(2)+O(3)+…+O(N-1)$</p>\n<p>则时间复杂度为: $O(1)+O(2)+…+O(N)=O((N^2+N)/2)=O(N^2)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用插入排序对链表进行排序</span></span><br><span class=\"line\"><span class=\"comment\">// 插入排序是: 不断将没有排序的元素加入已经排好序的部分</span></span><br><span class=\"line\"><span class=\"comment\">// 单向链表只能从前往后遍历</span></span><br><span class=\"line\"><span class=\"comment\">// 这里顺便学习了单向链表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insertionSortList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个元素默认已经排好序</span></span><br><span class=\"line\">  <span class=\"comment\">// curr 从下一位开始</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head.next;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  <span class=\"comment\">// 排好序的部分此时只有head一个元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 末尾指向null</span></span><br><span class=\"line\">  <span class=\"comment\">// 与需要排序的部分分开</span></span><br><span class=\"line\">  head.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cn, hn;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保留curr的后一部分</span></span><br><span class=\"line\">    cn = curr.next;</span><br><span class=\"line\">    <span class=\"comment\">// curr比有序的第一个元素小</span></span><br><span class=\"line\">    <span class=\"comment\">// 则直接置于有序部分的头部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr.val &lt;= head.val) &#123;</span><br><span class=\"line\">      curr.next = head;</span><br><span class=\"line\">      head = curr;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// curr 比第一个有序元素大</span></span><br><span class=\"line\">      <span class=\"comment\">// 则需要遍历后面的有序元素</span></span><br><span class=\"line\">      <span class=\"comment\">// 直到找到有序排列中比curr大的元素x</span></span><br><span class=\"line\">      <span class=\"comment\">// 则curr插入到 x的前面</span></span><br><span class=\"line\">      <span class=\"comment\">// 为了保留 x 的前一个节点</span></span><br><span class=\"line\">      <span class=\"comment\">// 将curr.val与h.next.val进行比较, 而不是h.val</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> h = head;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (h.next &amp;&amp; curr.val &gt; h.next.val) &#123;</span><br><span class=\"line\">        h = h.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 将curr插入至 h 与 x 节点之间</span></span><br><span class=\"line\">      hn = h.next;</span><br><span class=\"line\">      h.next = curr;</span><br><span class=\"line\">      curr.next = hn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// curr向后移动一位</span></span><br><span class=\"line\">    curr = cn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"203-Remove-Linked-List-Elements\"><a href=\"#203-Remove-Linked-List-Elements\" class=\"headerlink\" title=\"[203] Remove Linked List Elements\"></a>[203] Remove Linked List Elements</h4><blockquote>\n<p>Remove all elements from a linked list of integers that have value <strong><em>val\\</em></strong>.</p>\n</blockquote>\n<p>时间复杂度: 遍历链表 $O(N)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> removeElements = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> hair = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>, head);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = hair, curr = head;</span><br><span class=\"line\">  <span class=\"comment\">// pre的移动也是在head表示的这条链表上</span></span><br><span class=\"line\">  <span class=\"comment\">// pre改变的是head本身</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr.val == val) &#123;</span><br><span class=\"line\">      pre.next = curr.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pre = curr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 有个特殊情况需要注意</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如 [1] 1</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时pre还没后移到head链表上</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以pre指向null没有改变head链表</span></span><br><span class=\"line\">  <span class=\"comment\">// head仍然是 [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hair.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"206-Reverse-Linked-List\"><a href=\"#206-Reverse-Linked-List\" class=\"headerlink\" title=\"[206] Reverse Linked List\"></a>[206] Reverse Linked List</h4><blockquote>\n<p>Reverse a singly linked list.</p>\n<p><strong>Follow up:</strong></p>\n<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n</blockquote>\n<p><strong>递归过程</strong>需要详细的过程分析图(<strong>TO DO</strong>).</p>\n<p>两种时间复杂度均为 $O(N)$. </p>\n<p>递归方法的时间复杂度分析: 遍历整个链表, 递归调用N次.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代翻转</span></span><br><span class=\"line\"><span class=\"comment\">// 空间复杂度 O(1)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverseList1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rever = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">    temp = head.next;</span><br><span class=\"line\">    head.next = rever.next;</span><br><span class=\"line\">    rever.next = head;</span><br><span class=\"line\">    head = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rever.next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归翻转</span></span><br><span class=\"line\"><span class=\"comment\">// 需要注意的是, p是指向head的一个指针</span></span><br><span class=\"line\"><span class=\"comment\">// 并不是另外的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 但是由于每一次都会生成p指针重新指向目前已经倒好序的链表</span></span><br><span class=\"line\"><span class=\"comment\">// 所以递归过程中的空间复杂度为O(1)+O(2)+...+O(N)=O(N)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverseList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = reverseList(head.next);</span><br><span class=\"line\">  head.next.next = head;</span><br><span class=\"line\">  head.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"237-Delete-Node-in-a-Linked-List\"><a href=\"#237-Delete-Node-in-a-Linked-List\" class=\"headerlink\" title=\"[237] Delete Node in a Linked List\"></a>[237] Delete Node in a Linked List</h4><blockquote>\n<p>Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p>\n<p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p>\n</blockquote>\n<p>注意看题目条件, 时间/空间复杂度均为 $O(N)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一时没有想起来用什么解法</span></span><br><span class=\"line\"><span class=\"comment\">// 因为之前删除节点都是不能改变节点自身的值</span></span><br><span class=\"line\"><span class=\"comment\">// 现在这个能改变了 害</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法令我哭笑不得, 也提醒自己注意看题目条件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleteNode = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    node.val = node.next.val;</span><br><span class=\"line\">    node.next = node.next.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"234-Palindrome-Linked-List\"><a href=\"#234-Palindrome-Linked-List\" class=\"headerlink\" title=\"[234] Palindrome Linked List\"></a>[234] Palindrome Linked List</h4><blockquote>\n<p>Given a singly linked list, determine if it is a palindrome.</p>\n<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>\n</blockquote>\n<p>时间复杂度: </p>\n<p>遍历链表一次, $O(N)$, 后半部分翻转链表的时候, 时间为$O(N/2)$.</p>\n<p>所以时间复杂度为: $O(N)+O(N/2)=O(N)$.</p>\n<p>方法:</p>\n<p>判断回文链表,要求只能遍历一次链表.</p>\n<p>将链表<strong>后半段翻转</strong> 再将前后部分分别比较.</p>\n<p>然后还有需要注意的是: <strong>快慢指针法寻找链表中心点</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isPalindrome = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fast = head, slow = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class=\"line\">    fast = fast.next.next;</span><br><span class=\"line\">    slow = slow.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不管链表长度是奇数还是偶数 需要进行的操作都是一样的</span></span><br><span class=\"line\">  <span class=\"comment\">// slow 为后半部分链表的起点</span></span><br><span class=\"line\">  slow.next = reverse(slow.next);</span><br><span class=\"line\">  slow = slow.next;</span><br><span class=\"line\">  <span class=\"comment\">// 将前后两部分链表逐个节点对值进行比较</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有值不等 说明不是回文</span></span><br><span class=\"line\">  <span class=\"comment\">// 前半部分的长度是&gt;=后半部分的</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以当slow=null时, head=null或者head是最后一个节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于回文的两种形式, 此时就可以结束比较了</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (slow) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head.val != slow.val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head.next;</span><br><span class=\"line\">    slow = slow.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 翻转链表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reverse = <span class=\"function\">(<span class=\"params\">head</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = head, cn, rn;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    cn = curr.next;</span><br><span class=\"line\">    rn = res.next;</span><br><span class=\"line\">    res.next = curr;</span><br><span class=\"line\">    curr.next = rn;</span><br><span class=\"line\">    curr = cn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"160-Intersection-of-Two-Linked-Lists\"><a href=\"#160-Intersection-of-Two-Linked-Lists\" class=\"headerlink\" title=\"[160] Intersection of Two Linked Lists\"></a>[160] Intersection of Two Linked Lists</h4><blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p><strong>Notes:</strong></p>\n<ul>\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n<li>The linked lists must retain their original structure after the function returns.</li>\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n<li>Each value on each linked list is in the range <code>[1, 10^9]</code>.</li>\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n</blockquote>\n<img src=\"/2020/09/11/Linked-list/image1.png\" class=\"\" title=\"image1.png\">\n<p>由图可知:</p>\n<p>$headA = A + C$</p>\n<p>$headB = B + C$</p>\n<p>所以:</p>\n<p>$newA = headA + headB = A + C + B + C$</p>\n<p>$newB = headB + headA = B + C + A + C$</p>\n<p>已知:</p>\n<p>$A + C + B = B + C + A$</p>\n<p>所以 <code>newA</code>与<code>newB</code>同时出发, 每次都走一步. </p>\n<p><code>newA</code>走完<code>headA</code>再走完<code>B</code>,  <code>newB</code>走完<code>headB</code>再走完<code>A</code>, 如果两者有交点, 则此时会相等且不为<code>null</code>;</p>\n<p>如果不相交, 则走到最后两者也相等, 但是为<code>null</code>.</p>\n<p>时间复杂度:</p>\n<p>假设<code>headA</code>和<code>headB</code>总共的长度为<code>N</code>, 则一共遍历了两次, 时间为$2*O(N)$, 时间复杂度为$O(N)$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路很巧妙 需要分析下 最后两个节点一定会相等</span></span><br><span class=\"line\"><span class=\"comment\">// 只是是地址还是null的问题</span></span><br><span class=\"line\"><span class=\"comment\">// 最差情况是不相交</span></span><br><span class=\"line\"><span class=\"comment\">// 每个链表均遍历了两遍</span></span><br><span class=\"line\"><span class=\"comment\">// 但是额外空间只使用了两个指针变量,为常数级</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getIntersectionNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">headA, headB</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currA = headA, currB = headB;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (currA != currB) &#123;</span><br><span class=\"line\">    currA = !currA ? headB : currA.next;</span><br><span class=\"line\">    currB = !currB ? headA : currB.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不相交最后也会相等的 均是null</span></span><br><span class=\"line\">  <span class=\"comment\">// 即： 相交或者是不相交， 二者均会相等</span></span><br><span class=\"line\">  <span class=\"comment\">// 相等的话，返回的是及交点地址</span></span><br><span class=\"line\">  <span class=\"comment\">// 不相等的话，返回的是null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> currA;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"328-Odd-Even-Linked-List\"><a href=\"#328-Odd-Even-Linked-List\" class=\"headerlink\" title=\"[328] Odd Even Linked List\"></a>[328] Odd Even Linked List</h4><blockquote>\n<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>\n<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>\n</blockquote>\n<p>时间复杂度: 两个指针同时遍历, 一共遍历一遍链表. $O(N)$</p>\n<p>空间复杂度: 只是新建了两个指针, 改动原有链表, 没有重新生成head的copy版本. $O(1)$</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 完全自己想的法子 太棒了</span></span><br><span class=\"line\"><span class=\"comment\">// 大体思路就是,用两个指针, 一个指向奇数节点, 一个指向偶数节点</span></span><br><span class=\"line\"><span class=\"comment\">// 遍历完head之后, 再将两个链表进行拼接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oddEvenList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!head || !head.next || !head.next.next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oddList = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> evenList = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> odd = oddList, even = evenList;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化第一个奇数节点</span></span><br><span class=\"line\">  odd.next = head;</span><br><span class=\"line\">  odd = odd.next;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化第一个偶数节点</span></span><br><span class=\"line\">  even.next = head.next;</span><br><span class=\"line\">  even = even.next;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (even &amp;&amp; even.next) &#123;</span><br><span class=\"line\">    odd.next = odd.next.next;</span><br><span class=\"line\">    odd = odd.next;</span><br><span class=\"line\">    even.next = even.next.next;</span><br><span class=\"line\">    even = even.next;</span><br><span class=\"line\">    <span class=\"comment\">// 链表长度为奇数 此时 even==null</span></span><br><span class=\"line\">    <span class=\"comment\">// 链表长度为偶数 此时 even.next==null</span></span><br><span class=\"line\">    <span class=\"comment\">// 两种情况的任何一种情况都应该退出循环</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 对奇数链与偶数链进行拼接</span></span><br><span class=\"line\">  odd.next = evenList.next;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> oddList.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"725-Split-Linked-List-in-Parts\"><a href=\"#725-Split-Linked-List-in-Parts\" class=\"headerlink\" title=\"[725] Split Linked List in Parts\"></a>[725] Split Linked List in Parts</h4><blockquote>\n<p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p>\n<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>\n<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>\n<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>\n<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>\n</blockquote>\n<p>理解题意 一共分为 k 部分 而不是长度是 k !!</p>\n<p><em>时间复杂度*</em>:</p>\n<p>在计算链表长度时, 遍历了一次. 后面将链表片段加入时, 又遍历了一遍.</p>\n<p>所以时间复杂度为 $O(N+k)$, 在<code>k&gt;len</code>时, 需要继续向结果中加入片段.</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>生成<code>answer</code>时res数组中包含的节点个数, <code>k&gt;len</code>, k个链表节点, 反之, len个链表节点. 所以空间复杂度为$O(max(N, k))$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> splitListToParts = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">root, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先计算root的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curr = root, len = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">    len++;</span><br><span class=\"line\">    curr = curr.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curr = root;</span><br><span class=\"line\">  <span class=\"comment\">// 计算宽度</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> width = <span class=\"built_in\">Math</span>.floor(len / k);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> extra = len % k; <span class=\"comment\">// 需要长度被加一的组数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []; <span class=\"comment\">// 初始化长度为k的结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当k&lt;=len的时候,curr指向null时, for循环也就结束了</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为组数已经达到了k组</span></span><br><span class=\"line\">    <span class=\"comment\">// 出现curr为null的情况时, 并且走到了这里</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明k&gt;len</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时只需要将null不断加入数组直至数组长度达到k</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!curr) &#123;</span><br><span class=\"line\">      res.push(<span class=\"literal\">null</span>);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 多余没有入组的元素需要加入前面的每一个组</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此前extra组, 每组的元素长度需要+1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = i &lt; extra ? width + <span class=\"number\">1</span> : width;</span><br><span class=\"line\">    <span class=\"comment\">// l-1是为了控制curr指向part的最后一个元素而不是下一个</span></span><br><span class=\"line\">    <span class=\"comment\">// 便于将该链表片段加入res</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; l - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      curr = curr.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// curr 到达part的最后一个元素      </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cn = curr.next;</span><br><span class=\"line\">    curr.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    res.push(root);</span><br><span class=\"line\">    curr = root = cn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"445-Add-Two-Numbers-II\"><a href=\"#445-Add-Two-Numbers-II\" class=\"headerlink\" title=\"[445] Add Two Numbers II\"></a>[445] Add Two Numbers II</h4><blockquote>\n<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p><strong>Follow up:</strong><br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>\n</blockquote>\n<p>题目要求不能翻转链表, 于是遍历链表, 将链表中的数都存进栈中. 再通过将栈弹出, 进行相加操作.</p>\n<p><strong>时间复杂度</strong>:</p>\n<p>遍历两个链表, O(N). 两个栈均弹出进行相加操作, O(N). 因此时间为 $2O(N)=O(N)$</p>\n<p><strong>空间复杂度</strong>:</p>\n<p>使用两个栈存储数字, O(N), 相加之后得到新的结果列表的长度 O(max(m, n)) ps.是两个链表中较长的那一个Lmax, 结果链表长度可能由于进位问题会是Lmax+1, 因此空间复杂度为 $O(N)+O(max(m, n))$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不能够翻转链表</span></span><br><span class=\"line\"><span class=\"comment\">// 使用两个栈存储数字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将两个链表中的值分别存进两个栈中</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> stack1 = [], stack2 = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l1) &#123;</span><br><span class=\"line\">    stack1.push(l1.val);</span><br><span class=\"line\">    l1 = l1.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l2) &#123;</span><br><span class=\"line\">    stack2.push(l2.val);</span><br><span class=\"line\">    l2 = l2.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化变量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, carry = <span class=\"number\">0</span>, num = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"keyword\">new</span> ListNode(<span class=\"literal\">null</span>), rn;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> add1, add2;</span><br><span class=\"line\">  <span class=\"comment\">// 当两个栈有至少一个不为空时, 都进行相加操作</span></span><br><span class=\"line\">  <span class=\"comment\">// 为空的那个栈的加数为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (stack1.length != <span class=\"number\">0</span> || stack2.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    add1 = stack1.length == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : stack1.pop();</span><br><span class=\"line\">    add2 = stack2.length == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : stack2.pop();</span><br><span class=\"line\">    sum = add1 + add2 + carry;</span><br><span class=\"line\">    <span class=\"comment\">// 商是进位 大于10为1,小于10为0</span></span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(sum / <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 余数是相加之后结果中的数字</span></span><br><span class=\"line\">    num = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将结果添加进结果列表中</span></span><br><span class=\"line\">    rn = res.next;</span><br><span class=\"line\">    res.next = <span class=\"keyword\">new</span> ListNode(num);</span><br><span class=\"line\">    res.next.next = rn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当两个链表均为空时, 看是否还有进位</span></span><br><span class=\"line\">  <span class=\"comment\">// 有进位则添加进结果列表中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (carry != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rn = res.next;</span><br><span class=\"line\">    res.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">    res.next.next = rn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Sort","abbrlink":56837,"date":"2020-09-17T01:36:33.000Z","description":"排序算法总结","_content":"\n\n\n### 冒泡排序\n\n时间复杂度: n^2\n\n平均空间复杂度: 常数\n\n最快: 正序\n\n最慢: 倒序\n\n```javascript\n// 冒泡排序\n// 不断比较移动给定范围的最大值 直至最大值在数组的末尾\nvar bubble = (arr) => {\n  let n = arr.length;\n  let bigger;\n  for (let i = 0; i < n - 1; i++) { // 为了限制内部循环的长度\n    for (let j = 0; j < n - 1 - i; j++) {\n      // 不断将更大的值 放在后面\n      if (arr[j + 1] < arr[j]) {\n        bigger = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = bigger;\n      }\n    }\n  }\n}\n```\n\n\n\n### 选择排序\n\n不断找到最小的元素与对应的位置进行交换.\n\n平均时间复杂度: n^2\n\n空间复杂度: 常数\n\n最快: 正序\n\n最慢: 倒序\n\n```javascript\n// 选择排序\nvar selection = (arr) => {\n  let n = arr.length, minIndex;\n  for (let i = 0; i < n; i++) {\n    minIndex = i;\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    // exchange minIndex and i\n    // 最小值有更新\n    if (minIndex != i) {\n      let temp = arr[i];\n      arr[i] = arr[minIndex];\n      arr[minIndex] = temp;\n    }\n  }\n}\n```\n\n\n\n### 插入排序\n\n类似于插扑克牌, 假设前n-1个是排好序的, 将第n个元素插入前面的有序数列中, 使得这n个数也是排好顺序的.\n\n平均时间复杂度: n^2\n\n空间复杂度: 常数\n\n最快: 正序 O(n)\n\n最慢: 倒序\n\n```javascript\n// 插入排序\nvar insertion = (arr) => {\n  let n = arr.length, temp;\n  // 标记前多少元素是有序的\n  for (let i = 0; i < n - 1; i++) {\n    // 将有序数列的后一个元素加入进来\n    for (let j = i + 1; j >= 0; j--) {\n      if (arr[j] < arr[j - 1]) {\n        temp = arr[j];\n        arr[j] = arr[j - 1];\n        arr[j - 1] = temp;\n      } else {\n        break;\n      }\n    }\n  }\n}\n```\n\n\n\n### 希尔排序\n\n对于基本有序的数据序列, 使用插入排序会更高效.\n\n\n\n### 归并排序\n\n分治思想, 将多个已有序的子序列合并, 得到完全有序的序列(多路归并).\n\n自上而下的递归/自下而上的迭代.(递归均可用迭代重写)\n\n平均时间复杂度: Ο(nlogn) \n\n```javascript\n// 归并排序\n// 直接对原数组进行修改排序\nvar mergeSort = (arr) => {\n  let n = arr.length;\n  // 递归结束条件\n  // 数组只有一个元素 直接返回\n  if (n <= 1) {\n    return arr;\n  }\n  let mid = Math.floor(n / 2),\n    leftArr = arr.slice(0, mid),\n    rightArr = arr.slice(mid);\n  return merge(mergeSort(leftArr), mergeSort(rightArr));\n}\n\n// 合并两个有序数组\nvar merge = (leftArr, rightArr) => {\n  let result = [];\n  while (leftArr.length && rightArr.length) {\n    if (leftArr[0] <= rightArr[0]) {\n      result.push(leftArr.shift());\n    } else {\n      result.push(rightArr.shift());\n    }\n  }\n  while (leftArr.length) {\n    result.push(leftArr.shift());\n  }\n  while (rightArr.length) {\n    result.push(rightArr.shift());\n  }\n  return result;\n}\n```\n\n\n\n\n\n### 快速排序\n\n分治思想, 是处理大数据最快的排序算法之一.\n\n步骤:\n\n1. 从数组中选中一个基准\n2. 比基准小的放在基准左边, 比基准大的放在基准右边. 所有元素结束之后, 该基准处于数列中间位置, called partition (分区操作).\n3. 递归地将基准左边与基准右边的子数列再进行排序.\n\n平均时间复杂度:  Ο(nlogn) \n\n空间复杂度: Ο(logn) \n\n最慢: O(N^2)\n\n```javascript\n// 快速排序\nvar quickSort = (arr, left, right) => {\n  if (left < right) {\n    let partitionIndex = partition(arr, left, right);\n    quickSort(arr, left, partitionIndex - 1);\n    quickSort(arr, partitionIndex + 1, right);\n  }\n  // left==right 则数组不需要做排序操作 直接返回即可\n}\n// 分区\nvar partition = (arr, left, right) => {\n  let pivot = left, // 随机选择基准值\n    index = pivot + 1; // 标记第一个可以交换的位置\n  for (let i = index; i <= right; i++) {\n    // 比基准值小的元素 与index位置的元素进行交换\n    if (arr[i] < arr[pivot]) {\n      if (i != index) swap(arr, i, index);\n      index++; // 下一个可以交换的位置往后移\n    }\n  }\n  // 所有小于基准值的在左边 大于基准值的在右边\n  // index 指向第一个大于基准值的元素\n  // 将基准值交换到中间\n  swap(arr, pivot, index - 1);\n  // 返回基准值的最新位置\n  // 为下一轮划分分区做准备\n  return index - 1;\n}\n// 交换元素\nvar swap = (arr, i, j) => {\n  let temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n```\n\n\n\n\n\n### 堆排序\n\n","source":"_posts/Sort.md","raw":"---\ntitle: Sort\nabbrlink: 56837\ndate: 2020-09-17 09:36:33\ntags:\ndescription: 排序算法总结\n---\n\n\n\n### 冒泡排序\n\n时间复杂度: n^2\n\n平均空间复杂度: 常数\n\n最快: 正序\n\n最慢: 倒序\n\n```javascript\n// 冒泡排序\n// 不断比较移动给定范围的最大值 直至最大值在数组的末尾\nvar bubble = (arr) => {\n  let n = arr.length;\n  let bigger;\n  for (let i = 0; i < n - 1; i++) { // 为了限制内部循环的长度\n    for (let j = 0; j < n - 1 - i; j++) {\n      // 不断将更大的值 放在后面\n      if (arr[j + 1] < arr[j]) {\n        bigger = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = bigger;\n      }\n    }\n  }\n}\n```\n\n\n\n### 选择排序\n\n不断找到最小的元素与对应的位置进行交换.\n\n平均时间复杂度: n^2\n\n空间复杂度: 常数\n\n最快: 正序\n\n最慢: 倒序\n\n```javascript\n// 选择排序\nvar selection = (arr) => {\n  let n = arr.length, minIndex;\n  for (let i = 0; i < n; i++) {\n    minIndex = i;\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    // exchange minIndex and i\n    // 最小值有更新\n    if (minIndex != i) {\n      let temp = arr[i];\n      arr[i] = arr[minIndex];\n      arr[minIndex] = temp;\n    }\n  }\n}\n```\n\n\n\n### 插入排序\n\n类似于插扑克牌, 假设前n-1个是排好序的, 将第n个元素插入前面的有序数列中, 使得这n个数也是排好顺序的.\n\n平均时间复杂度: n^2\n\n空间复杂度: 常数\n\n最快: 正序 O(n)\n\n最慢: 倒序\n\n```javascript\n// 插入排序\nvar insertion = (arr) => {\n  let n = arr.length, temp;\n  // 标记前多少元素是有序的\n  for (let i = 0; i < n - 1; i++) {\n    // 将有序数列的后一个元素加入进来\n    for (let j = i + 1; j >= 0; j--) {\n      if (arr[j] < arr[j - 1]) {\n        temp = arr[j];\n        arr[j] = arr[j - 1];\n        arr[j - 1] = temp;\n      } else {\n        break;\n      }\n    }\n  }\n}\n```\n\n\n\n### 希尔排序\n\n对于基本有序的数据序列, 使用插入排序会更高效.\n\n\n\n### 归并排序\n\n分治思想, 将多个已有序的子序列合并, 得到完全有序的序列(多路归并).\n\n自上而下的递归/自下而上的迭代.(递归均可用迭代重写)\n\n平均时间复杂度: Ο(nlogn) \n\n```javascript\n// 归并排序\n// 直接对原数组进行修改排序\nvar mergeSort = (arr) => {\n  let n = arr.length;\n  // 递归结束条件\n  // 数组只有一个元素 直接返回\n  if (n <= 1) {\n    return arr;\n  }\n  let mid = Math.floor(n / 2),\n    leftArr = arr.slice(0, mid),\n    rightArr = arr.slice(mid);\n  return merge(mergeSort(leftArr), mergeSort(rightArr));\n}\n\n// 合并两个有序数组\nvar merge = (leftArr, rightArr) => {\n  let result = [];\n  while (leftArr.length && rightArr.length) {\n    if (leftArr[0] <= rightArr[0]) {\n      result.push(leftArr.shift());\n    } else {\n      result.push(rightArr.shift());\n    }\n  }\n  while (leftArr.length) {\n    result.push(leftArr.shift());\n  }\n  while (rightArr.length) {\n    result.push(rightArr.shift());\n  }\n  return result;\n}\n```\n\n\n\n\n\n### 快速排序\n\n分治思想, 是处理大数据最快的排序算法之一.\n\n步骤:\n\n1. 从数组中选中一个基准\n2. 比基准小的放在基准左边, 比基准大的放在基准右边. 所有元素结束之后, 该基准处于数列中间位置, called partition (分区操作).\n3. 递归地将基准左边与基准右边的子数列再进行排序.\n\n平均时间复杂度:  Ο(nlogn) \n\n空间复杂度: Ο(logn) \n\n最慢: O(N^2)\n\n```javascript\n// 快速排序\nvar quickSort = (arr, left, right) => {\n  if (left < right) {\n    let partitionIndex = partition(arr, left, right);\n    quickSort(arr, left, partitionIndex - 1);\n    quickSort(arr, partitionIndex + 1, right);\n  }\n  // left==right 则数组不需要做排序操作 直接返回即可\n}\n// 分区\nvar partition = (arr, left, right) => {\n  let pivot = left, // 随机选择基准值\n    index = pivot + 1; // 标记第一个可以交换的位置\n  for (let i = index; i <= right; i++) {\n    // 比基准值小的元素 与index位置的元素进行交换\n    if (arr[i] < arr[pivot]) {\n      if (i != index) swap(arr, i, index);\n      index++; // 下一个可以交换的位置往后移\n    }\n  }\n  // 所有小于基准值的在左边 大于基准值的在右边\n  // index 指向第一个大于基准值的元素\n  // 将基准值交换到中间\n  swap(arr, pivot, index - 1);\n  // 返回基准值的最新位置\n  // 为下一轮划分分区做准备\n  return index - 1;\n}\n// 交换元素\nvar swap = (arr, i, j) => {\n  let temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n```\n\n\n\n\n\n### 堆排序\n\n","slug":"Sort","published":1,"updated":"2020-10-29T10:56:42.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5faft000gmm9h0gjyer81","content":"<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>时间复杂度: n^2</p>\n<p>平均空间复杂度: 常数</p>\n<p>最快: 正序</p>\n<p>最慢: 倒序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">// 不断比较移动给定范围的最大值 直至最大值在数组的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bubble = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bigger;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123; <span class=\"comment\">// 为了限制内部循环的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; n - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不断将更大的值 放在后面</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j + <span class=\"number\">1</span>] &lt; arr[j]) &#123;</span><br><span class=\"line\">        bigger = arr[j];</span><br><span class=\"line\">        arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = bigger;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>不断找到最小的元素与对应的位置进行交换.</p>\n<p>平均时间复杂度: n^2</p>\n<p>空间复杂度: 常数</p>\n<p>最快: 正序</p>\n<p>最慢: 倒序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selection = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length, minIndex;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// exchange minIndex and i</span></span><br><span class=\"line\">    <span class=\"comment\">// 最小值有更新</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[i];</span><br><span class=\"line\">      arr[i] = arr[minIndex];</span><br><span class=\"line\">      arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>类似于插扑克牌, 假设前n-1个是排好序的, 将第n个元素插入前面的有序数列中, 使得这n个数也是排好顺序的.</p>\n<p>平均时间复杂度: n^2</p>\n<p>空间复杂度: 常数</p>\n<p>最快: 正序 O(n)</p>\n<p>最慢: 倒序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insertion = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length, temp;</span><br><span class=\"line\">  <span class=\"comment\">// 标记前多少元素是有序的</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将有序数列的后一个元素加入进来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        temp = arr[j];</span><br><span class=\"line\">        arr[j] = arr[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>对于基本有序的数据序列, 使用插入排序会更高效.</p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>分治思想, 将多个已有序的子序列合并, 得到完全有序的序列(多路归并).</p>\n<p>自上而下的递归/自下而上的迭代.(递归均可用迭代重写)</p>\n<p>平均时间复杂度: Ο(nlogn) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">// 直接对原数组进行修改排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeSort = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length;</span><br><span class=\"line\">  <span class=\"comment\">// 递归结束条件</span></span><br><span class=\"line\">  <span class=\"comment\">// 数组只有一个元素 直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">2</span>),</span><br><span class=\"line\">    leftArr = arr.slice(<span class=\"number\">0</span>, mid),</span><br><span class=\"line\">    rightArr = arr.slice(mid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSort(leftArr), mergeSort(rightArr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个有序数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\">(<span class=\"params\">leftArr, rightArr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (leftArr.length &amp;&amp; rightArr.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftArr[<span class=\"number\">0</span>] &lt;= rightArr[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      result.push(leftArr.shift());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(rightArr.shift());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (leftArr.length) &#123;</span><br><span class=\"line\">    result.push(leftArr.shift());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (rightArr.length) &#123;</span><br><span class=\"line\">    result.push(rightArr.shift());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>分治思想, 是处理大数据最快的排序算法之一.</p>\n<p>步骤:</p>\n<ol>\n<li>从数组中选中一个基准</li>\n<li>比基准小的放在基准左边, 比基准大的放在基准右边. 所有元素结束之后, 该基准处于数列中间位置, called partition (分区操作).</li>\n<li>递归地将基准左边与基准右边的子数列再进行排序.</li>\n</ol>\n<p>平均时间复杂度:  Ο(nlogn) </p>\n<p>空间复杂度: Ο(logn) </p>\n<p>最慢: O(N^2)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快速排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> quickSort = <span class=\"function\">(<span class=\"params\">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> partitionIndex = partition(arr, left, right);</span><br><span class=\"line\">    quickSort(arr, left, partitionIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">    quickSort(arr, partitionIndex + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// left==right 则数组不需要做排序操作 直接返回即可</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 分区</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> partition = <span class=\"function\">(<span class=\"params\">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pivot = left, <span class=\"comment\">// 随机选择基准值</span></span><br><span class=\"line\">    index = pivot + <span class=\"number\">1</span>; <span class=\"comment\">// 标记第一个可以交换的位置</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 比基准值小的元素 与index位置的元素进行交换</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i != index) swap(arr, i, index);</span><br><span class=\"line\">      index++; <span class=\"comment\">// 下一个可以交换的位置往后移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 所有小于基准值的在左边 大于基准值的在右边</span></span><br><span class=\"line\">  <span class=\"comment\">// index 指向第一个大于基准值的元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 将基准值交换到中间</span></span><br><span class=\"line\">  swap(arr, pivot, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 返回基准值的最新位置</span></span><br><span class=\"line\">  <span class=\"comment\">// 为下一轮划分分区做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> index - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 交换元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> swap = <span class=\"function\">(<span class=\"params\">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp = arr[i];</span><br><span class=\"line\">  arr[i] = arr[j];</span><br><span class=\"line\">  arr[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>时间复杂度: n^2</p>\n<p>平均空间复杂度: 常数</p>\n<p>最快: 正序</p>\n<p>最慢: 倒序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">// 不断比较移动给定范围的最大值 直至最大值在数组的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bubble = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bigger;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123; <span class=\"comment\">// 为了限制内部循环的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; n - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不断将更大的值 放在后面</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j + <span class=\"number\">1</span>] &lt; arr[j]) &#123;</span><br><span class=\"line\">        bigger = arr[j];</span><br><span class=\"line\">        arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = bigger;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>不断找到最小的元素与对应的位置进行交换.</p>\n<p>平均时间复杂度: n^2</p>\n<p>空间复杂度: 常数</p>\n<p>最快: 正序</p>\n<p>最慢: 倒序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selection = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length, minIndex;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// exchange minIndex and i</span></span><br><span class=\"line\">    <span class=\"comment\">// 最小值有更新</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[i];</span><br><span class=\"line\">      arr[i] = arr[minIndex];</span><br><span class=\"line\">      arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>类似于插扑克牌, 假设前n-1个是排好序的, 将第n个元素插入前面的有序数列中, 使得这n个数也是排好顺序的.</p>\n<p>平均时间复杂度: n^2</p>\n<p>空间复杂度: 常数</p>\n<p>最快: 正序 O(n)</p>\n<p>最慢: 倒序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insertion = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length, temp;</span><br><span class=\"line\">  <span class=\"comment\">// 标记前多少元素是有序的</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将有序数列的后一个元素加入进来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        temp = arr[j];</span><br><span class=\"line\">        arr[j] = arr[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>对于基本有序的数据序列, 使用插入排序会更高效.</p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>分治思想, 将多个已有序的子序列合并, 得到完全有序的序列(多路归并).</p>\n<p>自上而下的递归/自下而上的迭代.(递归均可用迭代重写)</p>\n<p>平均时间复杂度: Ο(nlogn) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">// 直接对原数组进行修改排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergeSort = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length;</span><br><span class=\"line\">  <span class=\"comment\">// 递归结束条件</span></span><br><span class=\"line\">  <span class=\"comment\">// 数组只有一个元素 直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">2</span>),</span><br><span class=\"line\">    leftArr = arr.slice(<span class=\"number\">0</span>, mid),</span><br><span class=\"line\">    rightArr = arr.slice(mid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSort(leftArr), mergeSort(rightArr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个有序数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\">(<span class=\"params\">leftArr, rightArr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (leftArr.length &amp;&amp; rightArr.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftArr[<span class=\"number\">0</span>] &lt;= rightArr[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      result.push(leftArr.shift());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(rightArr.shift());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (leftArr.length) &#123;</span><br><span class=\"line\">    result.push(leftArr.shift());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (rightArr.length) &#123;</span><br><span class=\"line\">    result.push(rightArr.shift());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>分治思想, 是处理大数据最快的排序算法之一.</p>\n<p>步骤:</p>\n<ol>\n<li>从数组中选中一个基准</li>\n<li>比基准小的放在基准左边, 比基准大的放在基准右边. 所有元素结束之后, 该基准处于数列中间位置, called partition (分区操作).</li>\n<li>递归地将基准左边与基准右边的子数列再进行排序.</li>\n</ol>\n<p>平均时间复杂度:  Ο(nlogn) </p>\n<p>空间复杂度: Ο(logn) </p>\n<p>最慢: O(N^2)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快速排序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> quickSort = <span class=\"function\">(<span class=\"params\">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> partitionIndex = partition(arr, left, right);</span><br><span class=\"line\">    quickSort(arr, left, partitionIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">    quickSort(arr, partitionIndex + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// left==right 则数组不需要做排序操作 直接返回即可</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 分区</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> partition = <span class=\"function\">(<span class=\"params\">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pivot = left, <span class=\"comment\">// 随机选择基准值</span></span><br><span class=\"line\">    index = pivot + <span class=\"number\">1</span>; <span class=\"comment\">// 标记第一个可以交换的位置</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 比基准值小的元素 与index位置的元素进行交换</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i != index) swap(arr, i, index);</span><br><span class=\"line\">      index++; <span class=\"comment\">// 下一个可以交换的位置往后移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 所有小于基准值的在左边 大于基准值的在右边</span></span><br><span class=\"line\">  <span class=\"comment\">// index 指向第一个大于基准值的元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 将基准值交换到中间</span></span><br><span class=\"line\">  swap(arr, pivot, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 返回基准值的最新位置</span></span><br><span class=\"line\">  <span class=\"comment\">// 为下一轮划分分区做准备</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> index - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 交换元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> swap = <span class=\"function\">(<span class=\"params\">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp = arr[i];</span><br><span class=\"line\">  arr[i] = arr[j];</span><br><span class=\"line\">  arr[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3>"},{"title":"String","abbrlink":"9912b79f","description":"字符串相关题解","_content":"\n#### [43] Multiply Strings\n\n> Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\n算法答题思路就是模拟乘法累加的过程. \n\n需要注意的是, js大数相加会丢失精度, 所以谨慎使用.\n\n```javascript\n/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\n// js大数相加容易丢失精度, 有安全范围, 不行\n/**\n * \n * 整个算法的过程模拟乘法的计算过程\n * 用一个数组来存储每一步计算的结果\n * 时间复杂度: n^2\n */\nvar multiply = function (num1, num2) {\n  // 有一个参数为0,则结果为0\n  if (num1 == '0' || num2 == '0')\n    return '0';\n  let len1 = num1.length,\n    len2 = num2.length,\n    len = len1 + len2;\n  // 数组存储计算结果 长度暂时为两个字符串长度之和\n  let resArr = new Array(len);\n  // 初始化结果数组\n  for (let i = 0; i < len; i++) {\n    resArr[i] = 0;\n  }\n  // 循环反过来的原因是: 每次都是先拿因数1的每一位与因数2的同一位相乘\n  for (let j = len2 - 1; j >= 0; j--) {\n    let n2 = parseInt(num2[j]);\n    // 计算结果放置的位置\n    let pos = len - len2 + j;\n    for (let i = len1 - 1; i >= 0; i--) {\n      let n1 = parseInt(num1[i]);\n      let res = n1 * n2;\n      addNext(res, resArr, pos, 1);\n      // 数位升高一位, 结果放置也要对应往左一位\n      pos--;\n    }\n  }\n  // 去除结果数组最左边的 0\n  while (resArr[0] == '0') {\n    resArr.shift()\n  }\n  return resArr.join('');\n};\n\n// flag 为 1 表示要与当前位置数值相加\n// 为 0 则表示不用相加\nvar addNext = (num, resArr, pos, flag) => {\n  let posNum = num % 10, // 取余数 置于当前位置\n    addNum = Math.floor(num / 10); // floor 向下取整\n\n  resArr[pos] = (flag == 1) ? resArr[pos] + posNum : posNum;\n  resArr[pos - 1] += addNum;\n\n  if (resArr[pos] >= 10) {\n    // 与当前数值相加之后, 数值大于10, 则当前仍然需要进位\n    // 但是不需要再与当前位置数值相加了\n    addNext(resArr[pos], resArr, pos, 0);\n  }\n  // 进位最多只会等于 10\n  if (resArr[pos - 1] == 10) {\n    addNext(resArr[pos - 1], resArr, pos - 1, 0);\n  }\n}\n```\n\n\n\n#### [13] Roman to Integer\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n>\n> Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n\n时间复杂度: 遍历整个字符串, $O(N)$\n\n空间复杂度: 常数级别.\n\n```javascript\n// 罗马数字一共三种情况\n// 百位数字>十位数字>个位数字\n// 出现左侧数字比右侧数字小, 只会在某一个数位内部\nvar romanToInt = function (s) {\n  // 从左往右遍历\n  let pre = getVal(s[0]), sum = 0, num;\n  let len = s.length;\n  for (let i = 1; i < len; i++) {\n    num = getVal(s[i]);\n    // 前一个数字不小于后一个数字, 加上pre\n    // 反之, 说明pre是某一数位内部的需要减去的数字, 则减去pre\n    // 左侧的被减去的数字只出现一次或者不出现, 不会出现两次\n    if (pre >= num) {\n      sum += pre;\n    } else {\n      sum -= pre;\n    }\n    // 更新pre的值\n    pre = num;\n  }\n  // 最后一位不会再比右边哪个元素小了\n  // 所以需要将最后一位加上\n  sum += getVal(s[len - 1]);\n  return sum;\n};\n\nvar getVal = (ch) => {\n  switch (ch) {\n    case 'I':\n      return 1;\n    case 'V':\n      return 5;\n    case 'X':\n      return 10;\n    case 'L':\n      return 50;\n    case 'V':\n      return 5;\n    case 'C':\n      return 100;\n    case 'D':\n      return 500;\n    case 'M':\n      return 1000;\n    default:\n      return 0;\n  }\n}\n```\n\n\n\n#### [12] Integer to Roman\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n\n主要是不同数位的数字转换, 需要对数位进行分情况讨论. 不同数位的相同数字, 对应使用的罗马字符也不同.\n\n```javascript\n// 主要思路就是, 逐步整除, 然后对商进行对应数位的转换\nvar intToRoman = function (num) {\n  let items = [1000, 100, 10, 1];\n  let n, res = ''; // res需要初始化 否则res+=操作时, 由于res的值为udefined, 会在结果头部留一个udefined\n  // 从千位除到个位\n  // 注意 用let i in items时, typeof i = string\n  for (let i = 0; i < items.length; i++) {\n    // 得到商\n    n = Math.floor(num / items[i]);\n    // 根据数位以及商的大小确定对应的罗马数字\n    // 并对每一步得到的罗马数字进行拼接\n    // 使用索引顺便标记数位\n    res += toRoman(i, n);\n    // 后一轮需要被整除的数是当前一轮整除后得到的余数\n    num = num % items[i];\n  }\n  return res;\n};\n\nvar toRoman = (type, n) => {\n  let sma = '', mid = '', top = '';\n  // 数位不同 相同数字的表达方法不同\n  switch (type) {\n    case 0: // 千位\n      sma = 'M';\n      break;\n    case 1: // 百位\n      sma = 'C'; mid = 'D'; top = 'M';\n      break;\n    case 2: // 十位\n      sma = 'X'; mid = 'L'; top = 'C';\n      break;\n    case 3: // 个位\n      sma = 'I'; mid = 'V'; top = 'X';\n      break;\n    default:\n      break;\n  }\n  let roman = '';\n  // 根据 n 的大小, 转换成对应的罗马数字\n  // 千位不会超过3\n  if (n >= 0 && n <= 3) { // [0,3]\n    let i = 0;\n    while (i < n) {\n      roman += sma;\n      i++;\n    }\n  } else if (n == 4 || n == 9) { // 4/9\n    roman = n == 4 ? sma + mid : sma + top;\n  } else { // [5, 8]\n    let k = 0;\n    roman = mid;\n    while (k < n - 5) {\n      roman += sma;\n      k++;\n    }\n  }\n  return roman;\n}\n```\n\n\n\n#### [49] Group Anagrams\n\n> Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.\n>\n> An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n\n\n```javascript\n// 将字符串按照构成分组\n// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为字典的key\n// 相同key的就将元素index加入key对应的数组[]\n// 将字符串按照构成分组\n// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为map的key\n// 相同key的就将元素index加入key对应的数组[]\nvar groupAnagrams = function (strs) {\n  let len = strs.length;\n  if (len == 1) return [strs];\n  let map = {}, key;\n  for (let i = 0; i < len; i++) {\n    // 对每个字符串的字符拆分-排序-重组为string\n    // 以至于相同字母组成的str的key会一致\n    key = strs[i].split('').sort().toString();\n    // 看map是否存在\n    // 不存在生成[]\n    // 存在往[]里push元素\n    if (map[key] == undefined) {\n      map[key] = [i];\n    } else {\n      map[key].push(i);\n    }\n  }\n  // map中value是数组, 包含字母组成相同的一组字符串的index\n  // 遍历每一个数组, 将index替换为strs里对应的str\n  for (let k in map) {\n    for (let i = 0; i < map[k].length; i++) {\n      map[k][i] = strs[map[k][i]];\n    }\n  }\n  // 直接返回对象的values, 所有value被添加进[]并返回\n  // 本来是又新创建了个数组来存储结果, 这样直接返回values更节省空间\n  return Object.values(map);\n};\n```\n\n\n\n#### [67] Add Binary\n\n> Given two binary strings, return their sum (also a binary string).\n>\n> The input strings are both **non-empty** and contains only characters `1` or `0`.\n\n时间复杂度:\n\n假设两个串的长度分别为M/N, 则时间复杂度为 $O(max(M, N))$.\n\n```javascript\nvar addBinary = function (a, b) {\n  let i = a.length - 1, j = b.length - 1;\n  let num, carry = false, sum = '', charA, charB;\n  while (a[i] || b[j]) {\n    // 考虑到两个串长度不一致时的处理\n    charA = (a[i] == undefined) ? '0' : a[i];\n    charB = (b[j] == undefined) ? '0' : b[j];\n    // 由于二进制不是十进制加法, 所以需要对相加结果进行分类讨论\n    if (charA == charB) {\n      num = carry ? '1' : '0';\n      carry = charA == '1';\n    } else {\n      num = carry ? '0' : '1';\n    }\n    sum = num + sum;\n    i--;\n    j--;\n  }\n  // 如果两数的每一位均已对应相加完成, 但是还有进位, 需要把进位也加入结果中\n  sum = carry ? '1' + sum : sum;\n  return sum;\n};\n```\n\n\n\n#### [28] Implement strStr()\n\n> Implement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).\n>\n> Return the index of the first occurrence of needle in haystack, or **-1** if needle is not part of haystack.\n\n时间复杂度: \n\n设source长度为N, target长度为M, 最差的情况是: 一直遍历到最后的部分才知道是否有和target匹配的部分. O((N-M)*M). 不用遍历到source的最后一个元素, 只要剩余部分的长度不足M, 即可退出遍历.\n\n```javascript\n// 直观想法 使用双重循环 \n// 最外层循环是对源字符串的遍历\n// 需要考虑源字符串剩余长度不够匹配目标字符串的情况\n// 建议使用source target这类有意义的变量命名\nvar strStr = function (haystack, needle) {\n  // 目标串为'' 默认出现位置是0\n  if (needle == '') return 0;\n  // 源串为''(这里needle不为'') 则找不到\n  if (haystack == '') return -1;\n  for (let i = 0; i < haystack.length; i++) {\n    if (haystack[i] == needle[0]) {\n      if (isEqual(haystack, needle, i))\n        return i;\n      else\n        continue;\n    }\n  }\n  return -1\n};\n\nvar isEqual = (haystack, needle, i) => {\n  // 处理源字符串需要比较的串长度小于needle的长度的情况\n  if (haystack.length - i < needle.length) return false;\n  for (let j = 0; j < needle.length; j++) {\n    if (needle[j] != haystack[i])\n      return false\n    else {\n      i++;\n    }\n  }\n  return true;\n}\n```\n\n","source":"_posts/String.md","raw":"---\ntitle: String\ntags:\n  - LeetCode\ncategories: Algorithm\nabbrlink: 9912b79f\ndescription: 字符串相关题解\n---\n\n#### [43] Multiply Strings\n\n> Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\n算法答题思路就是模拟乘法累加的过程. \n\n需要注意的是, js大数相加会丢失精度, 所以谨慎使用.\n\n```javascript\n/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\n// js大数相加容易丢失精度, 有安全范围, 不行\n/**\n * \n * 整个算法的过程模拟乘法的计算过程\n * 用一个数组来存储每一步计算的结果\n * 时间复杂度: n^2\n */\nvar multiply = function (num1, num2) {\n  // 有一个参数为0,则结果为0\n  if (num1 == '0' || num2 == '0')\n    return '0';\n  let len1 = num1.length,\n    len2 = num2.length,\n    len = len1 + len2;\n  // 数组存储计算结果 长度暂时为两个字符串长度之和\n  let resArr = new Array(len);\n  // 初始化结果数组\n  for (let i = 0; i < len; i++) {\n    resArr[i] = 0;\n  }\n  // 循环反过来的原因是: 每次都是先拿因数1的每一位与因数2的同一位相乘\n  for (let j = len2 - 1; j >= 0; j--) {\n    let n2 = parseInt(num2[j]);\n    // 计算结果放置的位置\n    let pos = len - len2 + j;\n    for (let i = len1 - 1; i >= 0; i--) {\n      let n1 = parseInt(num1[i]);\n      let res = n1 * n2;\n      addNext(res, resArr, pos, 1);\n      // 数位升高一位, 结果放置也要对应往左一位\n      pos--;\n    }\n  }\n  // 去除结果数组最左边的 0\n  while (resArr[0] == '0') {\n    resArr.shift()\n  }\n  return resArr.join('');\n};\n\n// flag 为 1 表示要与当前位置数值相加\n// 为 0 则表示不用相加\nvar addNext = (num, resArr, pos, flag) => {\n  let posNum = num % 10, // 取余数 置于当前位置\n    addNum = Math.floor(num / 10); // floor 向下取整\n\n  resArr[pos] = (flag == 1) ? resArr[pos] + posNum : posNum;\n  resArr[pos - 1] += addNum;\n\n  if (resArr[pos] >= 10) {\n    // 与当前数值相加之后, 数值大于10, 则当前仍然需要进位\n    // 但是不需要再与当前位置数值相加了\n    addNext(resArr[pos], resArr, pos, 0);\n  }\n  // 进位最多只会等于 10\n  if (resArr[pos - 1] == 10) {\n    addNext(resArr[pos - 1], resArr, pos - 1, 0);\n  }\n}\n```\n\n\n\n#### [13] Roman to Integer\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n>\n> Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n\n时间复杂度: 遍历整个字符串, $O(N)$\n\n空间复杂度: 常数级别.\n\n```javascript\n// 罗马数字一共三种情况\n// 百位数字>十位数字>个位数字\n// 出现左侧数字比右侧数字小, 只会在某一个数位内部\nvar romanToInt = function (s) {\n  // 从左往右遍历\n  let pre = getVal(s[0]), sum = 0, num;\n  let len = s.length;\n  for (let i = 1; i < len; i++) {\n    num = getVal(s[i]);\n    // 前一个数字不小于后一个数字, 加上pre\n    // 反之, 说明pre是某一数位内部的需要减去的数字, 则减去pre\n    // 左侧的被减去的数字只出现一次或者不出现, 不会出现两次\n    if (pre >= num) {\n      sum += pre;\n    } else {\n      sum -= pre;\n    }\n    // 更新pre的值\n    pre = num;\n  }\n  // 最后一位不会再比右边哪个元素小了\n  // 所以需要将最后一位加上\n  sum += getVal(s[len - 1]);\n  return sum;\n};\n\nvar getVal = (ch) => {\n  switch (ch) {\n    case 'I':\n      return 1;\n    case 'V':\n      return 5;\n    case 'X':\n      return 10;\n    case 'L':\n      return 50;\n    case 'V':\n      return 5;\n    case 'C':\n      return 100;\n    case 'D':\n      return 500;\n    case 'M':\n      return 1000;\n    default:\n      return 0;\n  }\n}\n```\n\n\n\n#### [12] Integer to Roman\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n\n主要是不同数位的数字转换, 需要对数位进行分情况讨论. 不同数位的相同数字, 对应使用的罗马字符也不同.\n\n```javascript\n// 主要思路就是, 逐步整除, 然后对商进行对应数位的转换\nvar intToRoman = function (num) {\n  let items = [1000, 100, 10, 1];\n  let n, res = ''; // res需要初始化 否则res+=操作时, 由于res的值为udefined, 会在结果头部留一个udefined\n  // 从千位除到个位\n  // 注意 用let i in items时, typeof i = string\n  for (let i = 0; i < items.length; i++) {\n    // 得到商\n    n = Math.floor(num / items[i]);\n    // 根据数位以及商的大小确定对应的罗马数字\n    // 并对每一步得到的罗马数字进行拼接\n    // 使用索引顺便标记数位\n    res += toRoman(i, n);\n    // 后一轮需要被整除的数是当前一轮整除后得到的余数\n    num = num % items[i];\n  }\n  return res;\n};\n\nvar toRoman = (type, n) => {\n  let sma = '', mid = '', top = '';\n  // 数位不同 相同数字的表达方法不同\n  switch (type) {\n    case 0: // 千位\n      sma = 'M';\n      break;\n    case 1: // 百位\n      sma = 'C'; mid = 'D'; top = 'M';\n      break;\n    case 2: // 十位\n      sma = 'X'; mid = 'L'; top = 'C';\n      break;\n    case 3: // 个位\n      sma = 'I'; mid = 'V'; top = 'X';\n      break;\n    default:\n      break;\n  }\n  let roman = '';\n  // 根据 n 的大小, 转换成对应的罗马数字\n  // 千位不会超过3\n  if (n >= 0 && n <= 3) { // [0,3]\n    let i = 0;\n    while (i < n) {\n      roman += sma;\n      i++;\n    }\n  } else if (n == 4 || n == 9) { // 4/9\n    roman = n == 4 ? sma + mid : sma + top;\n  } else { // [5, 8]\n    let k = 0;\n    roman = mid;\n    while (k < n - 5) {\n      roman += sma;\n      k++;\n    }\n  }\n  return roman;\n}\n```\n\n\n\n#### [49] Group Anagrams\n\n> Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.\n>\n> An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n\n\n```javascript\n// 将字符串按照构成分组\n// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为字典的key\n// 相同key的就将元素index加入key对应的数组[]\n// 将字符串按照构成分组\n// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为map的key\n// 相同key的就将元素index加入key对应的数组[]\nvar groupAnagrams = function (strs) {\n  let len = strs.length;\n  if (len == 1) return [strs];\n  let map = {}, key;\n  for (let i = 0; i < len; i++) {\n    // 对每个字符串的字符拆分-排序-重组为string\n    // 以至于相同字母组成的str的key会一致\n    key = strs[i].split('').sort().toString();\n    // 看map是否存在\n    // 不存在生成[]\n    // 存在往[]里push元素\n    if (map[key] == undefined) {\n      map[key] = [i];\n    } else {\n      map[key].push(i);\n    }\n  }\n  // map中value是数组, 包含字母组成相同的一组字符串的index\n  // 遍历每一个数组, 将index替换为strs里对应的str\n  for (let k in map) {\n    for (let i = 0; i < map[k].length; i++) {\n      map[k][i] = strs[map[k][i]];\n    }\n  }\n  // 直接返回对象的values, 所有value被添加进[]并返回\n  // 本来是又新创建了个数组来存储结果, 这样直接返回values更节省空间\n  return Object.values(map);\n};\n```\n\n\n\n#### [67] Add Binary\n\n> Given two binary strings, return their sum (also a binary string).\n>\n> The input strings are both **non-empty** and contains only characters `1` or `0`.\n\n时间复杂度:\n\n假设两个串的长度分别为M/N, 则时间复杂度为 $O(max(M, N))$.\n\n```javascript\nvar addBinary = function (a, b) {\n  let i = a.length - 1, j = b.length - 1;\n  let num, carry = false, sum = '', charA, charB;\n  while (a[i] || b[j]) {\n    // 考虑到两个串长度不一致时的处理\n    charA = (a[i] == undefined) ? '0' : a[i];\n    charB = (b[j] == undefined) ? '0' : b[j];\n    // 由于二进制不是十进制加法, 所以需要对相加结果进行分类讨论\n    if (charA == charB) {\n      num = carry ? '1' : '0';\n      carry = charA == '1';\n    } else {\n      num = carry ? '0' : '1';\n    }\n    sum = num + sum;\n    i--;\n    j--;\n  }\n  // 如果两数的每一位均已对应相加完成, 但是还有进位, 需要把进位也加入结果中\n  sum = carry ? '1' + sum : sum;\n  return sum;\n};\n```\n\n\n\n#### [28] Implement strStr()\n\n> Implement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).\n>\n> Return the index of the first occurrence of needle in haystack, or **-1** if needle is not part of haystack.\n\n时间复杂度: \n\n设source长度为N, target长度为M, 最差的情况是: 一直遍历到最后的部分才知道是否有和target匹配的部分. O((N-M)*M). 不用遍历到source的最后一个元素, 只要剩余部分的长度不足M, 即可退出遍历.\n\n```javascript\n// 直观想法 使用双重循环 \n// 最外层循环是对源字符串的遍历\n// 需要考虑源字符串剩余长度不够匹配目标字符串的情况\n// 建议使用source target这类有意义的变量命名\nvar strStr = function (haystack, needle) {\n  // 目标串为'' 默认出现位置是0\n  if (needle == '') return 0;\n  // 源串为''(这里needle不为'') 则找不到\n  if (haystack == '') return -1;\n  for (let i = 0; i < haystack.length; i++) {\n    if (haystack[i] == needle[0]) {\n      if (isEqual(haystack, needle, i))\n        return i;\n      else\n        continue;\n    }\n  }\n  return -1\n};\n\nvar isEqual = (haystack, needle, i) => {\n  // 处理源字符串需要比较的串长度小于needle的长度的情况\n  if (haystack.length - i < needle.length) return false;\n  for (let j = 0; j < needle.length; j++) {\n    if (needle[j] != haystack[i])\n      return false\n    else {\n      i++;\n    }\n  }\n  return true;\n}\n```\n\n","slug":"String","published":1,"date":"2020-08-17T09:16:00.722Z","updated":"2020-10-29T10:56:49.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafv000jmm9h761pgo71","content":"<h4 id=\"43-Multiply-Strings\"><a href=\"#43-Multiply-Strings\" class=\"headerlink\" title=\"[43] Multiply Strings\"></a>[43] Multiply Strings</h4><blockquote>\n<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>\n</blockquote>\n<p>算法答题思路就是模拟乘法累加的过程. </p>\n<p>需要注意的是, js大数相加会丢失精度, 所以谨慎使用.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">num1</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">num2</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// js大数相加容易丢失精度, 有安全范围, 不行</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 整个算法的过程模拟乘法的计算过程</span></span><br><span class=\"line\"><span class=\"comment\"> * 用一个数组来存储每一步计算的结果</span></span><br><span class=\"line\"><span class=\"comment\"> * 时间复杂度: n^2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> multiply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 有一个参数为0,则结果为0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 == <span class=\"string\">'0'</span> || num2 == <span class=\"string\">'0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'0'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len1 = num1.length,</span><br><span class=\"line\">    len2 = num2.length,</span><br><span class=\"line\">    len = len1 + len2;</span><br><span class=\"line\">  <span class=\"comment\">// 数组存储计算结果 长度暂时为两个字符串长度之和</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> resArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len);</span><br><span class=\"line\">  <span class=\"comment\">// 初始化结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    resArr[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环反过来的原因是: 每次都是先拿因数1的每一位与因数2的同一位相乘</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = len2 - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n2 = <span class=\"built_in\">parseInt</span>(num2[j]);</span><br><span class=\"line\">    <span class=\"comment\">// 计算结果放置的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> pos = len - len2 + j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = len1 - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> n1 = <span class=\"built_in\">parseInt</span>(num1[i]);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = n1 * n2;</span><br><span class=\"line\">      addNext(res, resArr, pos, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 数位升高一位, 结果放置也要对应往左一位</span></span><br><span class=\"line\">      pos--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 去除结果数组最左边的 0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (resArr[<span class=\"number\">0</span>] == <span class=\"string\">'0'</span>) &#123;</span><br><span class=\"line\">    resArr.shift()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resArr.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// flag 为 1 表示要与当前位置数值相加</span></span><br><span class=\"line\"><span class=\"comment\">// 为 0 则表示不用相加</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addNext = <span class=\"function\">(<span class=\"params\">num, resArr, pos, flag</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> posNum = num % <span class=\"number\">10</span>, <span class=\"comment\">// 取余数 置于当前位置</span></span><br><span class=\"line\">    addNum = <span class=\"built_in\">Math</span>.floor(num / <span class=\"number\">10</span>); <span class=\"comment\">// floor 向下取整</span></span><br><span class=\"line\"></span><br><span class=\"line\">  resArr[pos] = (flag == <span class=\"number\">1</span>) ? resArr[pos] + posNum : posNum;</span><br><span class=\"line\">  resArr[pos - <span class=\"number\">1</span>] += addNum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (resArr[pos] &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 与当前数值相加之后, 数值大于10, 则当前仍然需要进位</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是不需要再与当前位置数值相加了</span></span><br><span class=\"line\">    addNext(resArr[pos], resArr, pos, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 进位最多只会等于 10</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (resArr[pos - <span class=\"number\">1</span>] == <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    addNext(resArr[pos - <span class=\"number\">1</span>], resArr, pos - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-Roman-to-Integer\"><a href=\"#13-Roman-to-Integer\" class=\"headerlink\" title=\"[13] Roman to Integer\"></a>[13] Roman to Integer</h4><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>\n</blockquote>\n<p>时间复杂度: 遍历整个字符串, $O(N)$</p>\n<p>空间复杂度: 常数级别.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 罗马数字一共三种情况</span></span><br><span class=\"line\"><span class=\"comment\">// 百位数字&gt;十位数字&gt;个位数字</span></span><br><span class=\"line\"><span class=\"comment\">// 出现左侧数字比右侧数字小, 只会在某一个数位内部</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> romanToInt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从左往右遍历</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = getVal(s[<span class=\"number\">0</span>]), sum = <span class=\"number\">0</span>, num;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = s.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    num = getVal(s[i]);</span><br><span class=\"line\">    <span class=\"comment\">// 前一个数字不小于后一个数字, 加上pre</span></span><br><span class=\"line\">    <span class=\"comment\">// 反之, 说明pre是某一数位内部的需要减去的数字, 则减去pre</span></span><br><span class=\"line\">    <span class=\"comment\">// 左侧的被减去的数字只出现一次或者不出现, 不会出现两次</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &gt;= num) &#123;</span><br><span class=\"line\">      sum += pre;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      sum -= pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新pre的值</span></span><br><span class=\"line\">    pre = num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 最后一位不会再比右边哪个元素小了</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以需要将最后一位加上</span></span><br><span class=\"line\">  sum += getVal(s[len - <span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getVal = <span class=\"function\">(<span class=\"params\">ch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (ch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'I'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'X'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'L'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">500</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'M'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"12-Integer-to-Roman\"><a href=\"#12-Integer-to-Roman\" class=\"headerlink\" title=\"[12] Integer to Roman\"></a>[12] Integer to Roman</h4><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n</blockquote>\n<p>主要是不同数位的数字转换, 需要对数位进行分情况讨论. 不同数位的相同数字, 对应使用的罗马字符也不同.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要思路就是, 逐步整除, 然后对商进行对应数位的转换</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> intToRoman = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> items = [<span class=\"number\">1000</span>, <span class=\"number\">100</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n, res = <span class=\"string\">''</span>; <span class=\"comment\">// res需要初始化 否则res+=操作时, 由于res的值为udefined, 会在结果头部留一个udefined</span></span><br><span class=\"line\">  <span class=\"comment\">// 从千位除到个位</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意 用let i in items时, typeof i = string</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 得到商</span></span><br><span class=\"line\">    n = <span class=\"built_in\">Math</span>.floor(num / items[i]);</span><br><span class=\"line\">    <span class=\"comment\">// 根据数位以及商的大小确定对应的罗马数字</span></span><br><span class=\"line\">    <span class=\"comment\">// 并对每一步得到的罗马数字进行拼接</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用索引顺便标记数位</span></span><br><span class=\"line\">    res += toRoman(i, n);</span><br><span class=\"line\">    <span class=\"comment\">// 后一轮需要被整除的数是当前一轮整除后得到的余数</span></span><br><span class=\"line\">    num = num % items[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> toRoman = <span class=\"function\">(<span class=\"params\">type, n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sma = <span class=\"string\">''</span>, mid = <span class=\"string\">''</span>, top = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 数位不同 相同数字的表达方法不同</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"comment\">// 千位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'M'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"comment\">// 百位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'C'</span>; mid = <span class=\"string\">'D'</span>; top = <span class=\"string\">'M'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"comment\">// 十位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'X'</span>; mid = <span class=\"string\">'L'</span>; top = <span class=\"string\">'C'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"comment\">// 个位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'I'</span>; mid = <span class=\"string\">'V'</span>; top = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> roman = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 根据 n 的大小, 转换成对应的罗马数字</span></span><br><span class=\"line\">  <span class=\"comment\">// 千位不会超过3</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt;= <span class=\"number\">0</span> &amp;&amp; n &lt;= <span class=\"number\">3</span>) &#123; <span class=\"comment\">// [0,3]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; n) &#123;</span><br><span class=\"line\">      roman += sma;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">4</span> || n == <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 4/9</span></span><br><span class=\"line\">    roman = n == <span class=\"number\">4</span> ? sma + mid : sma + top;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [5, 8]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    roman = mid;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; n - <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      roman += sma;</span><br><span class=\"line\">      k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> roman;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"49-Group-Anagrams\"><a href=\"#49-Group-Anagrams\" class=\"headerlink\" title=\"[49] Group Anagrams\"></a>[49] Group Anagrams</h4><blockquote>\n<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将字符串按照构成分组</span></span><br><span class=\"line\"><span class=\"comment\">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为字典的key</span></span><br><span class=\"line\"><span class=\"comment\">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class=\"line\"><span class=\"comment\">// 将字符串按照构成分组</span></span><br><span class=\"line\"><span class=\"comment\">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为map的key</span></span><br><span class=\"line\"><span class=\"comment\">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> groupAnagrams = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">strs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = strs.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> [strs];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;, key;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对每个字符串的字符拆分-排序-重组为string</span></span><br><span class=\"line\">    <span class=\"comment\">// 以至于相同字母组成的str的key会一致</span></span><br><span class=\"line\">    key = strs[i].split(<span class=\"string\">''</span>).sort().toString();</span><br><span class=\"line\">    <span class=\"comment\">// 看map是否存在</span></span><br><span class=\"line\">    <span class=\"comment\">// 不存在生成[]</span></span><br><span class=\"line\">    <span class=\"comment\">// 存在往[]里push元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[key] == <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      map[key] = [i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      map[key].push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// map中value是数组, 包含字母组成相同的一组字符串的index</span></span><br><span class=\"line\">  <span class=\"comment\">// 遍历每一个数组, 将index替换为strs里对应的str</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; map[k].length; i++) &#123;</span><br><span class=\"line\">      map[k][i] = strs[map[k][i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 直接返回对象的values, 所有value被添加进[]并返回</span></span><br><span class=\"line\">  <span class=\"comment\">// 本来是又新创建了个数组来存储结果, 这样直接返回values更节省空间</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(map);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"67-Add-Binary\"><a href=\"#67-Add-Binary\" class=\"headerlink\" title=\"[67] Add Binary\"></a>[67] Add Binary</h4><blockquote>\n<p>Given two binary strings, return their sum (also a binary string).</p>\n<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>\n</blockquote>\n<p>时间复杂度:</p>\n<p>假设两个串的长度分别为M/N, 则时间复杂度为 $O(max(M, N))$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addBinary = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = a.length - <span class=\"number\">1</span>, j = b.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num, carry = <span class=\"literal\">false</span>, sum = <span class=\"string\">''</span>, charA, charB;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (a[i] || b[j]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 考虑到两个串长度不一致时的处理</span></span><br><span class=\"line\">    charA = (a[i] == <span class=\"literal\">undefined</span>) ? <span class=\"string\">'0'</span> : a[i];</span><br><span class=\"line\">    charB = (b[j] == <span class=\"literal\">undefined</span>) ? <span class=\"string\">'0'</span> : b[j];</span><br><span class=\"line\">    <span class=\"comment\">// 由于二进制不是十进制加法, 所以需要对相加结果进行分类讨论</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (charA == charB) &#123;</span><br><span class=\"line\">      num = carry ? <span class=\"string\">'1'</span> : <span class=\"string\">'0'</span>;</span><br><span class=\"line\">      carry = charA == <span class=\"string\">'1'</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      num = carry ? <span class=\"string\">'0'</span> : <span class=\"string\">'1'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum = num + sum;</span><br><span class=\"line\">    i--;</span><br><span class=\"line\">    j--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果两数的每一位均已对应相加完成, 但是还有进位, 需要把进位也加入结果中</span></span><br><span class=\"line\">  sum = carry ? <span class=\"string\">'1'</span> + sum : sum;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"28-Implement-strStr\"><a href=\"#28-Implement-strStr\" class=\"headerlink\" title=\"[28] Implement strStr()\"></a>[28] Implement strStr()</h4><blockquote>\n<p>Implement <a href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\" rel=\"noopener\">strStr()</a>.</p>\n<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>\n</blockquote>\n<p>时间复杂度: </p>\n<p>设source长度为N, target长度为M, 最差的情况是: 一直遍历到最后的部分才知道是否有和target匹配的部分. O((N-M)*M). 不用遍历到source的最后一个元素, 只要剩余部分的长度不足M, 即可退出遍历.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直观想法 使用双重循环 </span></span><br><span class=\"line\"><span class=\"comment\">// 最外层循环是对源字符串的遍历</span></span><br><span class=\"line\"><span class=\"comment\">// 需要考虑源字符串剩余长度不够匹配目标字符串的情况</span></span><br><span class=\"line\"><span class=\"comment\">// 建议使用source target这类有意义的变量命名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strStr = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">haystack, needle</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 目标串为'' 默认出现位置是0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (needle == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 源串为''(这里needle不为'') 则找不到</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (haystack == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; haystack.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (haystack[i] == needle[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isEqual(haystack, needle, i))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> isEqual = <span class=\"function\">(<span class=\"params\">haystack, needle, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理源字符串需要比较的串长度小于needle的长度的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (haystack.length - i &lt; needle.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; needle.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (needle[j] != haystack[i])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"43-Multiply-Strings\"><a href=\"#43-Multiply-Strings\" class=\"headerlink\" title=\"[43] Multiply Strings\"></a>[43] Multiply Strings</h4><blockquote>\n<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>\n</blockquote>\n<p>算法答题思路就是模拟乘法累加的过程. </p>\n<p>需要注意的是, js大数相加会丢失精度, 所以谨慎使用.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">num1</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">num2</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// js大数相加容易丢失精度, 有安全范围, 不行</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 整个算法的过程模拟乘法的计算过程</span></span><br><span class=\"line\"><span class=\"comment\"> * 用一个数组来存储每一步计算的结果</span></span><br><span class=\"line\"><span class=\"comment\"> * 时间复杂度: n^2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> multiply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 有一个参数为0,则结果为0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 == <span class=\"string\">'0'</span> || num2 == <span class=\"string\">'0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'0'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len1 = num1.length,</span><br><span class=\"line\">    len2 = num2.length,</span><br><span class=\"line\">    len = len1 + len2;</span><br><span class=\"line\">  <span class=\"comment\">// 数组存储计算结果 长度暂时为两个字符串长度之和</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> resArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len);</span><br><span class=\"line\">  <span class=\"comment\">// 初始化结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    resArr[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环反过来的原因是: 每次都是先拿因数1的每一位与因数2的同一位相乘</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = len2 - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n2 = <span class=\"built_in\">parseInt</span>(num2[j]);</span><br><span class=\"line\">    <span class=\"comment\">// 计算结果放置的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> pos = len - len2 + j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = len1 - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> n1 = <span class=\"built_in\">parseInt</span>(num1[i]);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = n1 * n2;</span><br><span class=\"line\">      addNext(res, resArr, pos, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 数位升高一位, 结果放置也要对应往左一位</span></span><br><span class=\"line\">      pos--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 去除结果数组最左边的 0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (resArr[<span class=\"number\">0</span>] == <span class=\"string\">'0'</span>) &#123;</span><br><span class=\"line\">    resArr.shift()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resArr.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// flag 为 1 表示要与当前位置数值相加</span></span><br><span class=\"line\"><span class=\"comment\">// 为 0 则表示不用相加</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addNext = <span class=\"function\">(<span class=\"params\">num, resArr, pos, flag</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> posNum = num % <span class=\"number\">10</span>, <span class=\"comment\">// 取余数 置于当前位置</span></span><br><span class=\"line\">    addNum = <span class=\"built_in\">Math</span>.floor(num / <span class=\"number\">10</span>); <span class=\"comment\">// floor 向下取整</span></span><br><span class=\"line\"></span><br><span class=\"line\">  resArr[pos] = (flag == <span class=\"number\">1</span>) ? resArr[pos] + posNum : posNum;</span><br><span class=\"line\">  resArr[pos - <span class=\"number\">1</span>] += addNum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (resArr[pos] &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 与当前数值相加之后, 数值大于10, 则当前仍然需要进位</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是不需要再与当前位置数值相加了</span></span><br><span class=\"line\">    addNext(resArr[pos], resArr, pos, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 进位最多只会等于 10</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (resArr[pos - <span class=\"number\">1</span>] == <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    addNext(resArr[pos - <span class=\"number\">1</span>], resArr, pos - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-Roman-to-Integer\"><a href=\"#13-Roman-to-Integer\" class=\"headerlink\" title=\"[13] Roman to Integer\"></a>[13] Roman to Integer</h4><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>\n</blockquote>\n<p>时间复杂度: 遍历整个字符串, $O(N)$</p>\n<p>空间复杂度: 常数级别.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 罗马数字一共三种情况</span></span><br><span class=\"line\"><span class=\"comment\">// 百位数字&gt;十位数字&gt;个位数字</span></span><br><span class=\"line\"><span class=\"comment\">// 出现左侧数字比右侧数字小, 只会在某一个数位内部</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> romanToInt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从左往右遍历</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = getVal(s[<span class=\"number\">0</span>]), sum = <span class=\"number\">0</span>, num;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = s.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    num = getVal(s[i]);</span><br><span class=\"line\">    <span class=\"comment\">// 前一个数字不小于后一个数字, 加上pre</span></span><br><span class=\"line\">    <span class=\"comment\">// 反之, 说明pre是某一数位内部的需要减去的数字, 则减去pre</span></span><br><span class=\"line\">    <span class=\"comment\">// 左侧的被减去的数字只出现一次或者不出现, 不会出现两次</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &gt;= num) &#123;</span><br><span class=\"line\">      sum += pre;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      sum -= pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新pre的值</span></span><br><span class=\"line\">    pre = num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 最后一位不会再比右边哪个元素小了</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以需要将最后一位加上</span></span><br><span class=\"line\">  sum += getVal(s[len - <span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getVal = <span class=\"function\">(<span class=\"params\">ch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (ch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'I'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'X'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'L'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">500</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'M'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"12-Integer-to-Roman\"><a href=\"#12-Integer-to-Roman\" class=\"headerlink\" title=\"[12] Integer to Roman\"></a>[12] Integer to Roman</h4><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n</blockquote>\n<p>主要是不同数位的数字转换, 需要对数位进行分情况讨论. 不同数位的相同数字, 对应使用的罗马字符也不同.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要思路就是, 逐步整除, 然后对商进行对应数位的转换</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> intToRoman = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> items = [<span class=\"number\">1000</span>, <span class=\"number\">100</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n, res = <span class=\"string\">''</span>; <span class=\"comment\">// res需要初始化 否则res+=操作时, 由于res的值为udefined, 会在结果头部留一个udefined</span></span><br><span class=\"line\">  <span class=\"comment\">// 从千位除到个位</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意 用let i in items时, typeof i = string</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 得到商</span></span><br><span class=\"line\">    n = <span class=\"built_in\">Math</span>.floor(num / items[i]);</span><br><span class=\"line\">    <span class=\"comment\">// 根据数位以及商的大小确定对应的罗马数字</span></span><br><span class=\"line\">    <span class=\"comment\">// 并对每一步得到的罗马数字进行拼接</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用索引顺便标记数位</span></span><br><span class=\"line\">    res += toRoman(i, n);</span><br><span class=\"line\">    <span class=\"comment\">// 后一轮需要被整除的数是当前一轮整除后得到的余数</span></span><br><span class=\"line\">    num = num % items[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> toRoman = <span class=\"function\">(<span class=\"params\">type, n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sma = <span class=\"string\">''</span>, mid = <span class=\"string\">''</span>, top = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 数位不同 相同数字的表达方法不同</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"comment\">// 千位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'M'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"comment\">// 百位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'C'</span>; mid = <span class=\"string\">'D'</span>; top = <span class=\"string\">'M'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"comment\">// 十位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'X'</span>; mid = <span class=\"string\">'L'</span>; top = <span class=\"string\">'C'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"comment\">// 个位</span></span><br><span class=\"line\">      sma = <span class=\"string\">'I'</span>; mid = <span class=\"string\">'V'</span>; top = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> roman = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 根据 n 的大小, 转换成对应的罗马数字</span></span><br><span class=\"line\">  <span class=\"comment\">// 千位不会超过3</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt;= <span class=\"number\">0</span> &amp;&amp; n &lt;= <span class=\"number\">3</span>) &#123; <span class=\"comment\">// [0,3]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; n) &#123;</span><br><span class=\"line\">      roman += sma;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">4</span> || n == <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 4/9</span></span><br><span class=\"line\">    roman = n == <span class=\"number\">4</span> ? sma + mid : sma + top;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [5, 8]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    roman = mid;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; n - <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      roman += sma;</span><br><span class=\"line\">      k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> roman;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"49-Group-Anagrams\"><a href=\"#49-Group-Anagrams\" class=\"headerlink\" title=\"[49] Group Anagrams\"></a>[49] Group Anagrams</h4><blockquote>\n<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将字符串按照构成分组</span></span><br><span class=\"line\"><span class=\"comment\">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为字典的key</span></span><br><span class=\"line\"><span class=\"comment\">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class=\"line\"><span class=\"comment\">// 将字符串按照构成分组</span></span><br><span class=\"line\"><span class=\"comment\">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为map的key</span></span><br><span class=\"line\"><span class=\"comment\">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> groupAnagrams = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">strs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = strs.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> [strs];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;, key;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对每个字符串的字符拆分-排序-重组为string</span></span><br><span class=\"line\">    <span class=\"comment\">// 以至于相同字母组成的str的key会一致</span></span><br><span class=\"line\">    key = strs[i].split(<span class=\"string\">''</span>).sort().toString();</span><br><span class=\"line\">    <span class=\"comment\">// 看map是否存在</span></span><br><span class=\"line\">    <span class=\"comment\">// 不存在生成[]</span></span><br><span class=\"line\">    <span class=\"comment\">// 存在往[]里push元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[key] == <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      map[key] = [i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      map[key].push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// map中value是数组, 包含字母组成相同的一组字符串的index</span></span><br><span class=\"line\">  <span class=\"comment\">// 遍历每一个数组, 将index替换为strs里对应的str</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; map[k].length; i++) &#123;</span><br><span class=\"line\">      map[k][i] = strs[map[k][i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 直接返回对象的values, 所有value被添加进[]并返回</span></span><br><span class=\"line\">  <span class=\"comment\">// 本来是又新创建了个数组来存储结果, 这样直接返回values更节省空间</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(map);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"67-Add-Binary\"><a href=\"#67-Add-Binary\" class=\"headerlink\" title=\"[67] Add Binary\"></a>[67] Add Binary</h4><blockquote>\n<p>Given two binary strings, return their sum (also a binary string).</p>\n<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>\n</blockquote>\n<p>时间复杂度:</p>\n<p>假设两个串的长度分别为M/N, 则时间复杂度为 $O(max(M, N))$.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addBinary = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = a.length - <span class=\"number\">1</span>, j = b.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num, carry = <span class=\"literal\">false</span>, sum = <span class=\"string\">''</span>, charA, charB;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (a[i] || b[j]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 考虑到两个串长度不一致时的处理</span></span><br><span class=\"line\">    charA = (a[i] == <span class=\"literal\">undefined</span>) ? <span class=\"string\">'0'</span> : a[i];</span><br><span class=\"line\">    charB = (b[j] == <span class=\"literal\">undefined</span>) ? <span class=\"string\">'0'</span> : b[j];</span><br><span class=\"line\">    <span class=\"comment\">// 由于二进制不是十进制加法, 所以需要对相加结果进行分类讨论</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (charA == charB) &#123;</span><br><span class=\"line\">      num = carry ? <span class=\"string\">'1'</span> : <span class=\"string\">'0'</span>;</span><br><span class=\"line\">      carry = charA == <span class=\"string\">'1'</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      num = carry ? <span class=\"string\">'0'</span> : <span class=\"string\">'1'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum = num + sum;</span><br><span class=\"line\">    i--;</span><br><span class=\"line\">    j--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果两数的每一位均已对应相加完成, 但是还有进位, 需要把进位也加入结果中</span></span><br><span class=\"line\">  sum = carry ? <span class=\"string\">'1'</span> + sum : sum;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"28-Implement-strStr\"><a href=\"#28-Implement-strStr\" class=\"headerlink\" title=\"[28] Implement strStr()\"></a>[28] Implement strStr()</h4><blockquote>\n<p>Implement <a href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\" rel=\"noopener\">strStr()</a>.</p>\n<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>\n</blockquote>\n<p>时间复杂度: </p>\n<p>设source长度为N, target长度为M, 最差的情况是: 一直遍历到最后的部分才知道是否有和target匹配的部分. O((N-M)*M). 不用遍历到source的最后一个元素, 只要剩余部分的长度不足M, 即可退出遍历.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直观想法 使用双重循环 </span></span><br><span class=\"line\"><span class=\"comment\">// 最外层循环是对源字符串的遍历</span></span><br><span class=\"line\"><span class=\"comment\">// 需要考虑源字符串剩余长度不够匹配目标字符串的情况</span></span><br><span class=\"line\"><span class=\"comment\">// 建议使用source target这类有意义的变量命名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strStr = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">haystack, needle</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 目标串为'' 默认出现位置是0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (needle == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 源串为''(这里needle不为'') 则找不到</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (haystack == <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; haystack.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (haystack[i] == needle[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isEqual(haystack, needle, i))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> isEqual = <span class=\"function\">(<span class=\"params\">haystack, needle, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理源字符串需要比较的串长度小于needle的长度的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (haystack.length - i &lt; needle.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; needle.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (needle[j] != haystack[i])</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Two Pointers","abbrlink":"b6a54014","date":"2020-07-30T02:03:54.000Z","description":"双指针相关题解","_content":"\n\n\n#### [11] Container With Most Water\n\n> Given *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n>\n> **Note:** You may not slant the container and *n* is at least 2.\n\n\n\n###### my solution : Brute Force\n\n穷举所有面积的可能性,最后对面积进行排序,找到最大值.\n\n中间一度尝试过将 `partArea` 组成数组先排序,也还是超时.\n\n```javascript\nvar maxArea = function (height) {\n  let partMaxSet = new Set();\n  for (let i = 0; i < height.length - 1; i++) {\n    for (let j = i + 1; j < height.length; j++) {\n      let yVal = height[j] < height[i] ? height[j] : height[i];\n      let partArea = (j - i) * yVal;\n      partMaxSet.add(partArea);\n    }\n  }\n  let partMaxList = Array.from(partMaxSet);\n  // 数字降序排列\n  partMaxList.sort(function (a, b) { return b - a });\n  return partMaxList[0];\n  // return Math.max.apply(null, partMaxList);\n};\n```\n\n\n\n###### Two pointers\n\n采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.\n\n移动短板, 短板有可能变长, 面积有可能变大.\n\n但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.\n\n```js\n// 此算法需要证明\nvar maxArea = function (height) {\n  let i = 0, j = height.length - 1;\n  let areaList = new Array();\n  while (j - i > 0) {\n    if (height[i] < height[j]) {\n      // 计算面积以短边为准\n      areaList.push((j - i) * height[i]);\n      // 移动短边有可能获得更大面积\n      i++;\n    } else {\n      areaList.push((j - i) * height[j]);\n      j--;\n    }\n  }\n  // 将可能的面积列表倒序排列,返回第一个\n  return areaList.sort((a, b) => b - a)[0]\n}\n```\n\n**Complexity Analysis**\n\n- Time complexity : O(n)*O*(*n*). Single pass.\n- Space complexity : O(1)*O*(1). Constant space is used.\n\n\n\n#### [26] Remove Duplicates from Sorted Array\n\n> Given a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only *once* and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n\n\n###### my solution\n\n借用 js 数组splice方法\n\n```javascript\nvar removeDuplicates = function (nums) {\n  for (let i = 0; i < nums.length; i++) {\n    let j = i+1;\n    while (nums[j] == nums[i]) {\n      nums.splice(j, 1);\n    }\n  }\n};\n```\n\n\n\n###### Two pointers\n\n```javascript\n// 参考双指针的方法, 优化了解法\n// js的数组越界不会报错,只会得到 undefined 值\nvar removeDuplicates = function (nums) {\n  let i = 0;\n  for (let j = 0; j < nums.length; j++) {\n    if (nums[j] != nums[j + 1]) {\n      nums[i] = nums[j];\n      i++;\n    }\n  }\n  return i;\n};\n```\n\n\n\n#### [27] Remove Element\n\n> Given an array *nums* and a value *val*, remove all instances of that value [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n>\n> The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\n\n\n###### my solution\n\n我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.\n\n```javascript\n// solution 1\nvar removeElement = function (nums, val) {\n  for (let i = 0; i < nums.length; i++) {\n    // 使用 while 保证对于同一个i, 去除该位置所有与val相等的值\n    // 不会遗漏由于删除数组元素而位置前移的新元素\n    while (nums[i] == val) {\n      nums.splice(i, 1)\n    }\n  }\n};\n```\n\n\n\n###### Two pointers\n\n下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.\n\n主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.\n\n```javascript\n// solution two pointers\n// 只保留与val不同的元素\n// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了\nvar removeElement = function (nums, val) {\n  let i = 0;\n  for (let j = 0; j < nums.length; j++) {\n    if (nums[j] != val) {\n      nums[i] = nums[j];\n      // console.log(\"i=\", i, \" \", nums[i]);\n      i++;\n    }\n  }\n  return i;\n};\n```\n\n最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).\n\n**Complexity analysis**\n\n- Time complexity : O(n). Assume the array has a total of n*n* elements, both *i* and *j* traverse at most 2*n* steps.\n- Space complexity : O(1).\n\n\n\n#### [15] 3Sum\n\n> Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n>\n> **Note:**\n>\n> The solution set must not contain duplicate triplets.\n\n数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.\n\n```javascript\n// solution 2 ：将数组排序后的双指针解法\nvar threeSum = function (nums) {\n  nums = nums.sort((a, b) => a - b); // 将数组正序排列\n  let len = nums.length;\n  let res = [];\n  for (let i = 0; i < len - 2; i++) {\n    // 第一个数大于 0，肯定加起来和不为0了\n    if (nums[i] > 0) {\n      break;\n    }\n    // 去掉重复元素\n    if (i > 0 && nums[i] == nums[i - 1])\n      continue;\n    let target = -nums[i];\n    let left = i + 1, right = len - 1;\n    while (left < right) {\n      if (nums[left] + nums[right] == target) {\n        res.push([nums[i], nums[left], nums[right]]);\n        left++;\n        right--;\n        // 这里是否判断 left < right 都没有那么重要, 因为最外面还会再判断一次\n        // 但是加上判断可能会少做一次计算\n        // 去掉重复元素\n        while (left < right && nums[left] == nums[left - 1]) {\n          left++;\n        }\n        while (left < right && nums[right] == nums[right + 1]) {\n          right--;\n        }\n      } else if (nums[left] + nums[right] < target) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return res;\n};\n```\n\n\n\n#### [16] 3Sum Closest\n\n> Given an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.\n\n与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right--, 总之就是不断靠近target.\n\n```javascript\nvar threeSumClosest = function (nums, target) {\n  nums = nums.sort((a, b) => a - b);\n  let closest = nums[0] + nums[1] + nums[2];\n  let diff = Math.abs(closest - target);\n  let len = nums.length;\n  for (let i = 0; i < len - 2; i++) {\n    // 由于数组是排好序的\n    // 如果nums[i] * 3 > target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值\n    // 后面差距只会越来越大\n    // 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值\n    // 优化部分\n    if (nums[i] * 3 > target) {\n      let cDiff = Math.abs(closest - target);\n      let tempMin = nums[i] + nums[i + 1] + nums[i + 2];\n      let tDiff = Math.abs(tempMin - target);\n      return cDiff < tDiff ? closest : tempMin;\n    }\n    // 双指针 遍历数组剩余元素\n    let left = i + 1, right = len - 1;\n    while (left < right) {\n      let sum = nums[i] + nums[left] + nums[right];\n      let newDiff = Math.abs(sum - target);\n      if (newDiff == 0) {\n        return target\n      }\n      if (newDiff < diff) {\n        diff = newDiff;\n        closest = sum;\n      }\n      if (sum < target)\n        left++;\n      else\n        right--;\n    }\n  }\n  // console.log('closest:', closest);\n  return closest;\n};\n```\n\n\n\n#### [18] 4Sum\n\n> Given an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d*in `nums` such that *a* + *b* + *c* + *d* = `target`? Find all unique quadruplets in the array which gives the sum of `target`.\n>\n> **Note:**\n>\n> The solution set must not contain duplicate quadruplets.\n\n有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.\n\n```javascript\nvar fourSum = function (nums, target) {\n  nums = nums.sort((a, b) => a - b);\n  let len = nums.length, res = [];\n  for (let i = 0; i < len - 3; i++) {\n    // 去重\n    if (nums[i] == nums[i - 1] && i > 0)\n      continue;\n\n    for (let j = i + 1; j < len - 2; j++) {\n\n      if (nums[j] == nums[j - 1] && j > i + 1)\n        continue;\n        \n      let t = target - nums[i] - nums[j];\n      let left = j + 1, right = len - 1;\n\n      while (left < right) {\n        let twoSum = nums[left] + nums[right];\n        if (twoSum == t) {\n          res.push([nums[i], nums[j], nums[left], nums[right]]);\n          left++;\n          right--;\n          // 去重\n          while (left < right && nums[left] == nums[left - 1])\n            left++;\n          while (left < right && nums[right] == nums[right + 1])\n            right--;\n        } else if (twoSum > t) {\n          right--;\n        } else {\n          left++;\n        }\n      }\n    }\n  }\n  // console.log(res);\n  return res;\n};\n```\n\n\n\n#### [283] Move Zeroes\n\n> Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n>\n> **Note**:\n>\n> 1. You must do this **in-place** without making a copy of the array.\n> 2. Minimize the total number of operations.\n\n\n\n双指针解法, 一次成功.\n\n```javascript\n// solution: two pointers\n// 借鉴之前的做题经验, 这题算是完成的比较快\nvar moveZeroes = function (nums) {\n  let len = nums.length, i = 0;\n  for (let j = 0; j < len; j++) {\n    if (nums[j] != 0) {\n      nums[i] = nums[j];\n      i++;\n    }\n  }\n  for (let t = i; t < len; t++) {\n    nums[t] = 0;\n  }\n  // console.log(nums);\n  return nums;\n};\n```\n\n\n\n#### [66] Plus One\n\n> Given a **non-empty** array of digits representing a non-negative integer, increment one to the integer.\n>\n> The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.\n>\n> You may assume the integer does not contain any leading zero, except the number 0 itself.\n\n\n\n主要是运用数组特性.不是很难, 理解题意即可.\n\n还挺多人不喜欢这道题的, 可能觉得太弱智了?...\n\n```javascript\nvar plusOne = function (digits) {\n  let len = digits.length;\n  // c 表示进位\n  let i = len - 1, c = 1;\n  while (i >= 0) {\n    // 没有向前进位, 就 +1 结束\n    if (digits[i] + c < 10) {\n      digits[i]++;\n      break;\n    } else if (i == 0) { \n      // 首位元素 +1 后有进位, 向数组头部插入 1 结束\n      digits[i] = 0;\n      digits.unshift(1);\n      break;\n    } else {\n      // 不是首位元素 +1 后有进位\n      // 当前元素设为 0 , 继续看更高位元素\n      digits[i] = 0;\n      i--;\n    }\n  }\n  // console.log(digits);\n  return digits;\n};\n```\n\n\n\n#### [88] Merge Sorted Array\n\n> Given two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n>\n> **Note:**\n>\n> - The number of elements initialized in *nums1* and *nums2* are *m*and *n* respectively.\n> - You may assume that *nums1* has enough space (size that is **equal** to *m* + *n*) to hold additional elements from *nums2*.\n\n我用的方法比较死板, 感觉没有什么难度. 就是分情况讨论. \n\n不过用到了 js 里 Array 的特性.\n\n```javascript\nvar merge = function (nums1, m, nums2, n) {\n    // 说明没有自己的元素\n    if (m == 0) {\n        for (let i = 0; i < n; i++) {\n            nums1[i] = nums2[i];\n        }\n    } else {\n        let len = nums1.length;\n        let i = 0;\n        let j = m;\n        let k = 0;\n        while (i < len && k < n) {\n\n            if (nums2[k] >= nums1[i] && nums2[k] < nums1[i + 1]) {\n                nums1.splice(i + 1, 0, nums2[k]);\n                nums1.pop();\n                j++;\n                k++;\n            } else if (nums2[k] >= nums1[j - 1]) {\n                nums1[j] = nums2[k];\n                j++;\n                k++;\n            } else if (nums2[k] <= nums1[0]) {\n                nums1.unshift(nums2[k]);\n                nums1.pop();\n                j++;\n                k++;\n                i = 0;\n                continue;\n            }\n            i++;\n        }\n    }\n};\n```\n\n\n\n#### [80] Remove Duplicates from Sorted Array II\n\n> Given a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that duplicates appeared at most *twice* and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n**时间复杂度**: 遍历整个数组 $O(N)$\n\n**空间复杂度**: 仅使用两个index: left和right标记数组元素位置, $O(1)$ \n\n使用splice方法直接修改数组. (这个方法的实现原理需要了解一下 TODO)\n\n```javascript\n// 数组是排好序的\n// 不能使用额外空间,直接修改数组\n// 使所有元素出现次数最多不超过2次\nvar removeDuplicates = function (nums) {\n  let len = nums.length;\n  let left = 0, right = 1;\n  while (right < len) {\n    if (nums[right] == nums[left] && right - left == 1) {\n      right++;\n      continue;\n    }\n    // 说明至少是第三个相同的元素\n    // 需要将该元素删除\n    if (nums[right] == nums[left] && right - left > 1) {\n      nums.splice(right, 1);\n      // 删除元素时会影响原数组的长度\n      // 但是right仍然需要控制不能超过数组的边界\n      len = nums.length;\n      continue;\n    }\n    // right和left指向的元素不同\n    left = right;\n    right = right + 1;\n  }\n  // 当right==len的时候,说明数组遍历结束\n  // 返回当前删除重复元素后的数组长度\n  return len;\n};\n```\n\n\n\n#### [202] Happy Number\n\n> Write an algorithm to determine if a number `n` is \"happy\".\n>\n> A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1. Those numbers for which this process **ends in 1** are happy numbers.\n>\n> Return True if `n` is a happy number, and False if not.\n\n复杂度分析有点困难, 以及为什么只有循环或者归1两种结果, 而不是无穷大.\n\n```javascript\n// solution 1: 快慢指针法\n// 快慢指针找循环\n// 在平方累加的过程中, 要不最后等于1, 要不最后陷入循环, 至于为什么不是无穷大\n// 需要再琢磨一下\nvar isHappy1 = function (n) {\n  // 慢指针一次计算一步, 快指针一次计算两步\n  // 如果两个指针的值一样, 说明进入循环\n  // 否则, 快指针一定比慢指针率先到达1\n  // 初始化快慢指针\n  let slow = getPow(n), fast = getPow(getPow(n));\n  while (fast != 1 && fast != slow) {\n    slow = getPow(slow);\n    fast = getPow(fast);\n    fast = getPow(fast);\n  }\n  return fast == 1 ? true : false;\n};\n\n// 计算某个数的各个数位上的平方\nvar getPow = (n) => {\n  let sum = 0;\n  while (n > 0) {\n    let num = n % 10;\n    sum += num * num;\n    n = Math.floor(n / 10);\n  }\n  return sum;\n}\n\n// solution 2: 使用hashmap来判断值有无重复 聪儿判断有无循环\nvar isHappy = function (n) {\n  let map = {};\n  let res = getPow(n);\n  // map中没有该计算结果\n  // 则添加进map中\n  // 不是undefined 说明该计算结果之前已经被塞进map中\n  // 得到循环\n  while (map[res] == undefined && res != 1) {\n    map[res] = '1';\n    res = getPow(res);\n  }\n  return res == 1 ? true : false;\n}\n```\n\n","source":"_posts/Two-Pointers.md","raw":"---\ntitle: Two Pointers\nabbrlink: b6a54014\ndate: 2020-07-30 10:03:54\ntags: [LeetCode, array, two-pointers]\ncategories: Algorithm\ndescription: 双指针相关题解\n---\n\n\n\n#### [11] Container With Most Water\n\n> Given *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n>\n> **Note:** You may not slant the container and *n* is at least 2.\n\n\n\n###### my solution : Brute Force\n\n穷举所有面积的可能性,最后对面积进行排序,找到最大值.\n\n中间一度尝试过将 `partArea` 组成数组先排序,也还是超时.\n\n```javascript\nvar maxArea = function (height) {\n  let partMaxSet = new Set();\n  for (let i = 0; i < height.length - 1; i++) {\n    for (let j = i + 1; j < height.length; j++) {\n      let yVal = height[j] < height[i] ? height[j] : height[i];\n      let partArea = (j - i) * yVal;\n      partMaxSet.add(partArea);\n    }\n  }\n  let partMaxList = Array.from(partMaxSet);\n  // 数字降序排列\n  partMaxList.sort(function (a, b) { return b - a });\n  return partMaxList[0];\n  // return Math.max.apply(null, partMaxList);\n};\n```\n\n\n\n###### Two pointers\n\n采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.\n\n移动短板, 短板有可能变长, 面积有可能变大.\n\n但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.\n\n```js\n// 此算法需要证明\nvar maxArea = function (height) {\n  let i = 0, j = height.length - 1;\n  let areaList = new Array();\n  while (j - i > 0) {\n    if (height[i] < height[j]) {\n      // 计算面积以短边为准\n      areaList.push((j - i) * height[i]);\n      // 移动短边有可能获得更大面积\n      i++;\n    } else {\n      areaList.push((j - i) * height[j]);\n      j--;\n    }\n  }\n  // 将可能的面积列表倒序排列,返回第一个\n  return areaList.sort((a, b) => b - a)[0]\n}\n```\n\n**Complexity Analysis**\n\n- Time complexity : O(n)*O*(*n*). Single pass.\n- Space complexity : O(1)*O*(1). Constant space is used.\n\n\n\n#### [26] Remove Duplicates from Sorted Array\n\n> Given a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only *once* and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n\n\n###### my solution\n\n借用 js 数组splice方法\n\n```javascript\nvar removeDuplicates = function (nums) {\n  for (let i = 0; i < nums.length; i++) {\n    let j = i+1;\n    while (nums[j] == nums[i]) {\n      nums.splice(j, 1);\n    }\n  }\n};\n```\n\n\n\n###### Two pointers\n\n```javascript\n// 参考双指针的方法, 优化了解法\n// js的数组越界不会报错,只会得到 undefined 值\nvar removeDuplicates = function (nums) {\n  let i = 0;\n  for (let j = 0; j < nums.length; j++) {\n    if (nums[j] != nums[j + 1]) {\n      nums[i] = nums[j];\n      i++;\n    }\n  }\n  return i;\n};\n```\n\n\n\n#### [27] Remove Element\n\n> Given an array *nums* and a value *val*, remove all instances of that value [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n>\n> The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\n\n\n###### my solution\n\n我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.\n\n```javascript\n// solution 1\nvar removeElement = function (nums, val) {\n  for (let i = 0; i < nums.length; i++) {\n    // 使用 while 保证对于同一个i, 去除该位置所有与val相等的值\n    // 不会遗漏由于删除数组元素而位置前移的新元素\n    while (nums[i] == val) {\n      nums.splice(i, 1)\n    }\n  }\n};\n```\n\n\n\n###### Two pointers\n\n下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.\n\n主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.\n\n```javascript\n// solution two pointers\n// 只保留与val不同的元素\n// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了\nvar removeElement = function (nums, val) {\n  let i = 0;\n  for (let j = 0; j < nums.length; j++) {\n    if (nums[j] != val) {\n      nums[i] = nums[j];\n      // console.log(\"i=\", i, \" \", nums[i]);\n      i++;\n    }\n  }\n  return i;\n};\n```\n\n最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).\n\n**Complexity analysis**\n\n- Time complexity : O(n). Assume the array has a total of n*n* elements, both *i* and *j* traverse at most 2*n* steps.\n- Space complexity : O(1).\n\n\n\n#### [15] 3Sum\n\n> Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n>\n> **Note:**\n>\n> The solution set must not contain duplicate triplets.\n\n数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.\n\n```javascript\n// solution 2 ：将数组排序后的双指针解法\nvar threeSum = function (nums) {\n  nums = nums.sort((a, b) => a - b); // 将数组正序排列\n  let len = nums.length;\n  let res = [];\n  for (let i = 0; i < len - 2; i++) {\n    // 第一个数大于 0，肯定加起来和不为0了\n    if (nums[i] > 0) {\n      break;\n    }\n    // 去掉重复元素\n    if (i > 0 && nums[i] == nums[i - 1])\n      continue;\n    let target = -nums[i];\n    let left = i + 1, right = len - 1;\n    while (left < right) {\n      if (nums[left] + nums[right] == target) {\n        res.push([nums[i], nums[left], nums[right]]);\n        left++;\n        right--;\n        // 这里是否判断 left < right 都没有那么重要, 因为最外面还会再判断一次\n        // 但是加上判断可能会少做一次计算\n        // 去掉重复元素\n        while (left < right && nums[left] == nums[left - 1]) {\n          left++;\n        }\n        while (left < right && nums[right] == nums[right + 1]) {\n          right--;\n        }\n      } else if (nums[left] + nums[right] < target) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return res;\n};\n```\n\n\n\n#### [16] 3Sum Closest\n\n> Given an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.\n\n与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right--, 总之就是不断靠近target.\n\n```javascript\nvar threeSumClosest = function (nums, target) {\n  nums = nums.sort((a, b) => a - b);\n  let closest = nums[0] + nums[1] + nums[2];\n  let diff = Math.abs(closest - target);\n  let len = nums.length;\n  for (let i = 0; i < len - 2; i++) {\n    // 由于数组是排好序的\n    // 如果nums[i] * 3 > target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值\n    // 后面差距只会越来越大\n    // 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值\n    // 优化部分\n    if (nums[i] * 3 > target) {\n      let cDiff = Math.abs(closest - target);\n      let tempMin = nums[i] + nums[i + 1] + nums[i + 2];\n      let tDiff = Math.abs(tempMin - target);\n      return cDiff < tDiff ? closest : tempMin;\n    }\n    // 双指针 遍历数组剩余元素\n    let left = i + 1, right = len - 1;\n    while (left < right) {\n      let sum = nums[i] + nums[left] + nums[right];\n      let newDiff = Math.abs(sum - target);\n      if (newDiff == 0) {\n        return target\n      }\n      if (newDiff < diff) {\n        diff = newDiff;\n        closest = sum;\n      }\n      if (sum < target)\n        left++;\n      else\n        right--;\n    }\n  }\n  // console.log('closest:', closest);\n  return closest;\n};\n```\n\n\n\n#### [18] 4Sum\n\n> Given an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d*in `nums` such that *a* + *b* + *c* + *d* = `target`? Find all unique quadruplets in the array which gives the sum of `target`.\n>\n> **Note:**\n>\n> The solution set must not contain duplicate quadruplets.\n\n有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.\n\n```javascript\nvar fourSum = function (nums, target) {\n  nums = nums.sort((a, b) => a - b);\n  let len = nums.length, res = [];\n  for (let i = 0; i < len - 3; i++) {\n    // 去重\n    if (nums[i] == nums[i - 1] && i > 0)\n      continue;\n\n    for (let j = i + 1; j < len - 2; j++) {\n\n      if (nums[j] == nums[j - 1] && j > i + 1)\n        continue;\n        \n      let t = target - nums[i] - nums[j];\n      let left = j + 1, right = len - 1;\n\n      while (left < right) {\n        let twoSum = nums[left] + nums[right];\n        if (twoSum == t) {\n          res.push([nums[i], nums[j], nums[left], nums[right]]);\n          left++;\n          right--;\n          // 去重\n          while (left < right && nums[left] == nums[left - 1])\n            left++;\n          while (left < right && nums[right] == nums[right + 1])\n            right--;\n        } else if (twoSum > t) {\n          right--;\n        } else {\n          left++;\n        }\n      }\n    }\n  }\n  // console.log(res);\n  return res;\n};\n```\n\n\n\n#### [283] Move Zeroes\n\n> Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n>\n> **Note**:\n>\n> 1. You must do this **in-place** without making a copy of the array.\n> 2. Minimize the total number of operations.\n\n\n\n双指针解法, 一次成功.\n\n```javascript\n// solution: two pointers\n// 借鉴之前的做题经验, 这题算是完成的比较快\nvar moveZeroes = function (nums) {\n  let len = nums.length, i = 0;\n  for (let j = 0; j < len; j++) {\n    if (nums[j] != 0) {\n      nums[i] = nums[j];\n      i++;\n    }\n  }\n  for (let t = i; t < len; t++) {\n    nums[t] = 0;\n  }\n  // console.log(nums);\n  return nums;\n};\n```\n\n\n\n#### [66] Plus One\n\n> Given a **non-empty** array of digits representing a non-negative integer, increment one to the integer.\n>\n> The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.\n>\n> You may assume the integer does not contain any leading zero, except the number 0 itself.\n\n\n\n主要是运用数组特性.不是很难, 理解题意即可.\n\n还挺多人不喜欢这道题的, 可能觉得太弱智了?...\n\n```javascript\nvar plusOne = function (digits) {\n  let len = digits.length;\n  // c 表示进位\n  let i = len - 1, c = 1;\n  while (i >= 0) {\n    // 没有向前进位, 就 +1 结束\n    if (digits[i] + c < 10) {\n      digits[i]++;\n      break;\n    } else if (i == 0) { \n      // 首位元素 +1 后有进位, 向数组头部插入 1 结束\n      digits[i] = 0;\n      digits.unshift(1);\n      break;\n    } else {\n      // 不是首位元素 +1 后有进位\n      // 当前元素设为 0 , 继续看更高位元素\n      digits[i] = 0;\n      i--;\n    }\n  }\n  // console.log(digits);\n  return digits;\n};\n```\n\n\n\n#### [88] Merge Sorted Array\n\n> Given two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n>\n> **Note:**\n>\n> - The number of elements initialized in *nums1* and *nums2* are *m*and *n* respectively.\n> - You may assume that *nums1* has enough space (size that is **equal** to *m* + *n*) to hold additional elements from *nums2*.\n\n我用的方法比较死板, 感觉没有什么难度. 就是分情况讨论. \n\n不过用到了 js 里 Array 的特性.\n\n```javascript\nvar merge = function (nums1, m, nums2, n) {\n    // 说明没有自己的元素\n    if (m == 0) {\n        for (let i = 0; i < n; i++) {\n            nums1[i] = nums2[i];\n        }\n    } else {\n        let len = nums1.length;\n        let i = 0;\n        let j = m;\n        let k = 0;\n        while (i < len && k < n) {\n\n            if (nums2[k] >= nums1[i] && nums2[k] < nums1[i + 1]) {\n                nums1.splice(i + 1, 0, nums2[k]);\n                nums1.pop();\n                j++;\n                k++;\n            } else if (nums2[k] >= nums1[j - 1]) {\n                nums1[j] = nums2[k];\n                j++;\n                k++;\n            } else if (nums2[k] <= nums1[0]) {\n                nums1.unshift(nums2[k]);\n                nums1.pop();\n                j++;\n                k++;\n                i = 0;\n                continue;\n            }\n            i++;\n        }\n    }\n};\n```\n\n\n\n#### [80] Remove Duplicates from Sorted Array II\n\n> Given a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that duplicates appeared at most *twice* and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n**时间复杂度**: 遍历整个数组 $O(N)$\n\n**空间复杂度**: 仅使用两个index: left和right标记数组元素位置, $O(1)$ \n\n使用splice方法直接修改数组. (这个方法的实现原理需要了解一下 TODO)\n\n```javascript\n// 数组是排好序的\n// 不能使用额外空间,直接修改数组\n// 使所有元素出现次数最多不超过2次\nvar removeDuplicates = function (nums) {\n  let len = nums.length;\n  let left = 0, right = 1;\n  while (right < len) {\n    if (nums[right] == nums[left] && right - left == 1) {\n      right++;\n      continue;\n    }\n    // 说明至少是第三个相同的元素\n    // 需要将该元素删除\n    if (nums[right] == nums[left] && right - left > 1) {\n      nums.splice(right, 1);\n      // 删除元素时会影响原数组的长度\n      // 但是right仍然需要控制不能超过数组的边界\n      len = nums.length;\n      continue;\n    }\n    // right和left指向的元素不同\n    left = right;\n    right = right + 1;\n  }\n  // 当right==len的时候,说明数组遍历结束\n  // 返回当前删除重复元素后的数组长度\n  return len;\n};\n```\n\n\n\n#### [202] Happy Number\n\n> Write an algorithm to determine if a number `n` is \"happy\".\n>\n> A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1. Those numbers for which this process **ends in 1** are happy numbers.\n>\n> Return True if `n` is a happy number, and False if not.\n\n复杂度分析有点困难, 以及为什么只有循环或者归1两种结果, 而不是无穷大.\n\n```javascript\n// solution 1: 快慢指针法\n// 快慢指针找循环\n// 在平方累加的过程中, 要不最后等于1, 要不最后陷入循环, 至于为什么不是无穷大\n// 需要再琢磨一下\nvar isHappy1 = function (n) {\n  // 慢指针一次计算一步, 快指针一次计算两步\n  // 如果两个指针的值一样, 说明进入循环\n  // 否则, 快指针一定比慢指针率先到达1\n  // 初始化快慢指针\n  let slow = getPow(n), fast = getPow(getPow(n));\n  while (fast != 1 && fast != slow) {\n    slow = getPow(slow);\n    fast = getPow(fast);\n    fast = getPow(fast);\n  }\n  return fast == 1 ? true : false;\n};\n\n// 计算某个数的各个数位上的平方\nvar getPow = (n) => {\n  let sum = 0;\n  while (n > 0) {\n    let num = n % 10;\n    sum += num * num;\n    n = Math.floor(n / 10);\n  }\n  return sum;\n}\n\n// solution 2: 使用hashmap来判断值有无重复 聪儿判断有无循环\nvar isHappy = function (n) {\n  let map = {};\n  let res = getPow(n);\n  // map中没有该计算结果\n  // 则添加进map中\n  // 不是undefined 说明该计算结果之前已经被塞进map中\n  // 得到循环\n  while (map[res] == undefined && res != 1) {\n    map[res] = '1';\n    res = getPow(res);\n  }\n  return res == 1 ? true : false;\n}\n```\n\n","slug":"Two-Pointers","published":1,"updated":"2020-10-29T10:57:02.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafw000mmm9h2bipbryl","content":"<h4 id=\"11-Container-With-Most-Water\"><a href=\"#11-Container-With-Most-Water\" class=\"headerlink\" title=\"[11] Container With Most Water\"></a>[11] Container With Most Water</h4><blockquote>\n<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>\n</blockquote>\n<h6 id=\"my-solution-Brute-Force\"><a href=\"#my-solution-Brute-Force\" class=\"headerlink\" title=\"my solution : Brute Force\"></a>my solution : Brute Force</h6><p>穷举所有面积的可能性,最后对面积进行排序,找到最大值.</p>\n<p>中间一度尝试过将 <code>partArea</code> 组成数组先排序,也还是超时.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> partMaxSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; height.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; height.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> yVal = height[j] &lt; height[i] ? height[j] : height[i];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> partArea = (j - i) * yVal;</span><br><span class=\"line\">      partMaxSet.add(partArea);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> partMaxList = <span class=\"built_in\">Array</span>.from(partMaxSet);</span><br><span class=\"line\">  <span class=\"comment\">// 数字降序排列</span></span><br><span class=\"line\">  partMaxList.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123; <span class=\"keyword\">return</span> b - a &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> partMaxList[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"comment\">// return Math.max.apply(null, partMaxList);</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Two-pointers\"><a href=\"#Two-pointers\" class=\"headerlink\" title=\"Two pointers\"></a>Two pointers</h6><p>采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.</p>\n<p>移动短板, 短板有可能变长, 面积有可能变大.</p>\n<p>但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此算法需要证明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = height.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> areaList = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (j - i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 计算面积以短边为准</span></span><br><span class=\"line\">      areaList.push((j - i) * height[i]);</span><br><span class=\"line\">      <span class=\"comment\">// 移动短边有可能获得更大面积</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      areaList.push((j - i) * height[j]);</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将可能的面积列表倒序排列,返回第一个</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> areaList.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b - a)[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Single pass.</li>\n<li>Space complexity : O(1)<em>O</em>(1). Constant space is used.</li>\n</ul>\n<h4 id=\"26-Remove-Duplicates-from-Sorted-Array\"><a href=\"#26-Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"[26] Remove Duplicates from Sorted Array\"></a>[26] Remove Duplicates from Sorted Array</h4><blockquote>\n<p>Given a sorted array <em>nums</em>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n</blockquote>\n<h6 id=\"my-solution\"><a href=\"#my-solution\" class=\"headerlink\" title=\"my solution\"></a>my solution</h6><p>借用 js 数组splice方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (nums[j] == nums[i]) &#123;</span><br><span class=\"line\">      nums.splice(j, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Two-pointers-1\"><a href=\"#Two-pointers-1\" class=\"headerlink\" title=\"Two pointers\"></a>Two pointers</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参考双指针的方法, 优化了解法</span></span><br><span class=\"line\"><span class=\"comment\">// js的数组越界不会报错,只会得到 undefined 值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[j] != nums[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      nums[i] = nums[j];</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"27-Remove-Element\"><a href=\"#27-Remove-Element\" class=\"headerlink\" title=\"[27] Remove Element\"></a>[27] Remove Element</h4><blockquote>\n<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>\n</blockquote>\n<h6 id=\"my-solution-1\"><a href=\"#my-solution-1\" class=\"headerlink\" title=\"my solution\"></a>my solution</h6><p>我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 while 保证对于同一个i, 去除该位置所有与val相等的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 不会遗漏由于删除数组元素而位置前移的新元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (nums[i] == val) &#123;</span><br><span class=\"line\">      nums.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Two-pointers-2\"><a href=\"#Two-pointers-2\" class=\"headerlink\" title=\"Two pointers\"></a>Two pointers</h6><p>下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.</p>\n<p>主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution two pointers</span></span><br><span class=\"line\"><span class=\"comment\">// 只保留与val不同的元素</span></span><br><span class=\"line\"><span class=\"comment\">// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[j] != val) &#123;</span><br><span class=\"line\">      nums[i] = nums[j];</span><br><span class=\"line\">      <span class=\"comment\">// console.log(\"i=\", i, \" \", nums[i]);</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity : O(n). Assume the array has a total of n<em>n</em> elements, both <em>i</em> and <em>j</em> traverse at most 2<em>n</em> steps.</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<h4 id=\"15-3Sum\"><a href=\"#15-3Sum\" class=\"headerlink\" title=\"[15] 3Sum\"></a>[15] 3Sum</h4><blockquote>\n<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p><strong>Note:</strong></p>\n<p>The solution set must not contain duplicate triplets.</p>\n</blockquote>\n<p>数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 2 ：将数组排序后的双指针解法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> threeSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b); <span class=\"comment\">// 将数组正序排列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一个数大于 0，肯定加起来和不为0了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 去掉重复元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> target = -nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = i + <span class=\"number\">1</span>, right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class=\"line\">        res.push([nums[i], nums[left], nums[right]]);</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">        <span class=\"comment\">// 这里是否判断 left &lt; right 都没有那么重要, 因为最外面还会再判断一次</span></span><br><span class=\"line\">        <span class=\"comment\">// 但是加上判断可能会少做一次计算</span></span><br><span class=\"line\">        <span class=\"comment\">// 去掉重复元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"16-3Sum-Closest\"><a href=\"#16-3Sum-Closest\" class=\"headerlink\" title=\"[16] 3Sum Closest\"></a>[16] 3Sum Closest</h4><blockquote>\n<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n</blockquote>\n<p>注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.</p>\n<p>与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right—, 总之就是不断靠近target.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> threeSumClosest = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> closest = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> diff = <span class=\"built_in\">Math</span>.abs(closest - target);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由于数组是排好序的</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果nums[i] * 3 &gt; target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值</span></span><br><span class=\"line\">    <span class=\"comment\">// 后面差距只会越来越大</span></span><br><span class=\"line\">    <span class=\"comment\">// 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值</span></span><br><span class=\"line\">    <span class=\"comment\">// 优化部分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] * <span class=\"number\">3</span> &gt; target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> cDiff = <span class=\"built_in\">Math</span>.abs(closest - target);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> tempMin = nums[i] + nums[i + <span class=\"number\">1</span>] + nums[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> tDiff = <span class=\"built_in\">Math</span>.abs(tempMin - target);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cDiff &lt; tDiff ? closest : tempMin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双指针 遍历数组剩余元素</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = i + <span class=\"number\">1</span>, right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> newDiff = <span class=\"built_in\">Math</span>.abs(sum - target);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newDiff == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newDiff &lt; diff) &#123;</span><br><span class=\"line\">        diff = newDiff;</span><br><span class=\"line\">        closest = sum;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log('closest:', closest);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> closest;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"18-4Sum\"><a href=\"#18-4Sum\" class=\"headerlink\" title=\"[18] 4Sum\"></a>[18] 4Sum</h4><blockquote>\n<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>\n<p><strong>Note:</strong></p>\n<p>The solution set must not contain duplicate quadruplets.</p>\n</blockquote>\n<p>有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fourSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length, res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 去重</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] == nums[i - <span class=\"number\">1</span>] &amp;&amp; i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len - <span class=\"number\">2</span>; j++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[j] == nums[j - <span class=\"number\">1</span>] &amp;&amp; j &gt; i + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"keyword\">let</span> t = target - nums[i] - nums[j];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> left = j + <span class=\"number\">1</span>, right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> twoSum = nums[left] + nums[right];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (twoSum == t) &#123;</span><br><span class=\"line\">          res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class=\"line\">          left++;</span><br><span class=\"line\">          right--;</span><br><span class=\"line\">          <span class=\"comment\">// 去重</span></span><br><span class=\"line\">          <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class=\"number\">1</span>])</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class=\"number\">1</span>])</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (twoSum &gt; t) &#123;</span><br><span class=\"line\">          right--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(res);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"283-Move-Zeroes\"><a href=\"#283-Move-Zeroes\" class=\"headerlink\" title=\"[283] Move Zeroes\"></a>[283] Move Zeroes</h4><blockquote>\n<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>\n<p><strong>Note</strong>:</p>\n<ol>\n<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ol>\n</blockquote>\n<p>双指针解法, 一次成功.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution: two pointers</span></span><br><span class=\"line\"><span class=\"comment\">// 借鉴之前的做题经验, 这题算是完成的比较快</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> moveZeroes = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length, i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[j] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums[i] = nums[j];</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = i; t &lt; len; t++) &#123;</span><br><span class=\"line\">    nums[t] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(nums);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"66-Plus-One\"><a href=\"#66-Plus-One\" class=\"headerlink\" title=\"[66] Plus One\"></a>[66] Plus One</h4><blockquote>\n<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, increment one to the integer.</p>\n<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>\n<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>\n</blockquote>\n<p>主要是运用数组特性.不是很难, 理解题意即可.</p>\n<p>还挺多人不喜欢这道题的, 可能觉得太弱智了?…</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> plusOne = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">digits</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = digits.length;</span><br><span class=\"line\">  <span class=\"comment\">// c 表示进位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = len - <span class=\"number\">1</span>, c = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没有向前进位, 就 +1 结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digits[i] + c &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      digits[i]++;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">      <span class=\"comment\">// 首位元素 +1 后有进位, 向数组头部插入 1 结束</span></span><br><span class=\"line\">      digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      digits.unshift(<span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不是首位元素 +1 后有进位</span></span><br><span class=\"line\">      <span class=\"comment\">// 当前元素设为 0 , 继续看更高位元素</span></span><br><span class=\"line\">      digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(digits);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"88-Merge-Sorted-Array\"><a href=\"#88-Merge-Sorted-Array\" class=\"headerlink\" title=\"[88] Merge Sorted Array\"></a>[88] Merge Sorted Array</h4><blockquote>\n<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em>and <em>n</em> respectively.</li>\n<li>You may assume that <em>nums1</em> has enough space (size that is <strong>equal</strong> to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>\n</ul>\n</blockquote>\n<p>我用的方法比较死板, 感觉没有什么难度. 就是分情况讨论. </p>\n<p>不过用到了 js 里 Array 的特性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 说明没有自己的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            nums1[i] = nums2[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = nums1.length;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> j = m;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len &amp;&amp; k &lt; n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums2[k] &gt;= nums1[i] &amp;&amp; nums2[k] &lt; nums1[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                nums1.splice(i + <span class=\"number\">1</span>, <span class=\"number\">0</span>, nums2[k]);</span><br><span class=\"line\">                nums1.pop();</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums2[k] &gt;= nums1[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                nums1[j] = nums2[k];</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums2[k] &lt;= nums1[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                nums1.unshift(nums2[k]);</span><br><span class=\"line\">                nums1.pop();</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">                i = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"80-Remove-Duplicates-from-Sorted-Array-II\"><a href=\"#80-Remove-Duplicates-from-Sorted-Array-II\" class=\"headerlink\" title=\"[80] Remove Duplicates from Sorted Array II\"></a>[80] Remove Duplicates from Sorted Array II</h4><blockquote>\n<p>Given a sorted array <em>nums</em>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>: 遍历整个数组 $O(N)$</p>\n<p><strong>空间复杂度</strong>: 仅使用两个index: left和right标记数组元素位置, $O(1)$ </p>\n<p>使用splice方法直接修改数组. (这个方法的实现原理需要了解一下 TODO)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组是排好序的</span></span><br><span class=\"line\"><span class=\"comment\">// 不能使用额外空间,直接修改数组</span></span><br><span class=\"line\"><span class=\"comment\">// 使所有元素出现次数最多不超过2次</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[right] == nums[left] &amp;&amp; right - left == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      right++;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 说明至少是第三个相同的元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要将该元素删除</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[right] == nums[left] &amp;&amp; right - left &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      nums.splice(right, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 删除元素时会影响原数组的长度</span></span><br><span class=\"line\">      <span class=\"comment\">// 但是right仍然需要控制不能超过数组的边界</span></span><br><span class=\"line\">      len = nums.length;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// right和left指向的元素不同</span></span><br><span class=\"line\">    left = right;</span><br><span class=\"line\">    right = right + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当right==len的时候,说明数组遍历结束</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回当前删除重复元素后的数组长度</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"202-Happy-Number\"><a href=\"#202-Happy-Number\" class=\"headerlink\" title=\"[202] Happy Number\"></a>[202] Happy Number</h4><blockquote>\n<p>Write an algorithm to determine if a number <code>n</code> is “happy”.</p>\n<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1. Those numbers for which this process <strong>ends in 1</strong> are happy numbers.</p>\n<p>Return True if <code>n</code> is a happy number, and False if not.</p>\n</blockquote>\n<p>复杂度分析有点困难, 以及为什么只有循环或者归1两种结果, 而不是无穷大.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1: 快慢指针法</span></span><br><span class=\"line\"><span class=\"comment\">// 快慢指针找循环</span></span><br><span class=\"line\"><span class=\"comment\">// 在平方累加的过程中, 要不最后等于1, 要不最后陷入循环, 至于为什么不是无穷大</span></span><br><span class=\"line\"><span class=\"comment\">// 需要再琢磨一下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isHappy1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 慢指针一次计算一步, 快指针一次计算两步</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果两个指针的值一样, 说明进入循环</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则, 快指针一定比慢指针率先到达1</span></span><br><span class=\"line\">  <span class=\"comment\">// 初始化快慢指针</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = getPow(n), fast = getPow(getPow(n));</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (fast != <span class=\"number\">1</span> &amp;&amp; fast != slow) &#123;</span><br><span class=\"line\">    slow = getPow(slow);</span><br><span class=\"line\">    fast = getPow(fast);</span><br><span class=\"line\">    fast = getPow(fast);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fast == <span class=\"number\">1</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算某个数的各个数位上的平方</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getPow = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = n % <span class=\"number\">10</span>;</span><br><span class=\"line\">    sum += num * num;</span><br><span class=\"line\">    n = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// solution 2: 使用hashmap来判断值有无重复 聪儿判断有无循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isHappy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = getPow(n);</span><br><span class=\"line\">  <span class=\"comment\">// map中没有该计算结果</span></span><br><span class=\"line\">  <span class=\"comment\">// 则添加进map中</span></span><br><span class=\"line\">  <span class=\"comment\">// 不是undefined 说明该计算结果之前已经被塞进map中</span></span><br><span class=\"line\">  <span class=\"comment\">// 得到循环</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (map[res] == <span class=\"literal\">undefined</span> &amp;&amp; res != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    map[res] = <span class=\"string\">'1'</span>;</span><br><span class=\"line\">    res = getPow(res);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res == <span class=\"number\">1</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"11-Container-With-Most-Water\"><a href=\"#11-Container-With-Most-Water\" class=\"headerlink\" title=\"[11] Container With Most Water\"></a>[11] Container With Most Water</h4><blockquote>\n<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>\n</blockquote>\n<h6 id=\"my-solution-Brute-Force\"><a href=\"#my-solution-Brute-Force\" class=\"headerlink\" title=\"my solution : Brute Force\"></a>my solution : Brute Force</h6><p>穷举所有面积的可能性,最后对面积进行排序,找到最大值.</p>\n<p>中间一度尝试过将 <code>partArea</code> 组成数组先排序,也还是超时.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> partMaxSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; height.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; height.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> yVal = height[j] &lt; height[i] ? height[j] : height[i];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> partArea = (j - i) * yVal;</span><br><span class=\"line\">      partMaxSet.add(partArea);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> partMaxList = <span class=\"built_in\">Array</span>.from(partMaxSet);</span><br><span class=\"line\">  <span class=\"comment\">// 数字降序排列</span></span><br><span class=\"line\">  partMaxList.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123; <span class=\"keyword\">return</span> b - a &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> partMaxList[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"comment\">// return Math.max.apply(null, partMaxList);</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Two-pointers\"><a href=\"#Two-pointers\" class=\"headerlink\" title=\"Two pointers\"></a>Two pointers</h6><p>采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.</p>\n<p>移动短板, 短板有可能变长, 面积有可能变大.</p>\n<p>但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此算法需要证明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">height</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = height.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> areaList = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (j - i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 计算面积以短边为准</span></span><br><span class=\"line\">      areaList.push((j - i) * height[i]);</span><br><span class=\"line\">      <span class=\"comment\">// 移动短边有可能获得更大面积</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      areaList.push((j - i) * height[j]);</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将可能的面积列表倒序排列,返回第一个</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> areaList.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b - a)[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Single pass.</li>\n<li>Space complexity : O(1)<em>O</em>(1). Constant space is used.</li>\n</ul>\n<h4 id=\"26-Remove-Duplicates-from-Sorted-Array\"><a href=\"#26-Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"[26] Remove Duplicates from Sorted Array\"></a>[26] Remove Duplicates from Sorted Array</h4><blockquote>\n<p>Given a sorted array <em>nums</em>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n</blockquote>\n<h6 id=\"my-solution\"><a href=\"#my-solution\" class=\"headerlink\" title=\"my solution\"></a>my solution</h6><p>借用 js 数组splice方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (nums[j] == nums[i]) &#123;</span><br><span class=\"line\">      nums.splice(j, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Two-pointers-1\"><a href=\"#Two-pointers-1\" class=\"headerlink\" title=\"Two pointers\"></a>Two pointers</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参考双指针的方法, 优化了解法</span></span><br><span class=\"line\"><span class=\"comment\">// js的数组越界不会报错,只会得到 undefined 值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[j] != nums[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      nums[i] = nums[j];</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"27-Remove-Element\"><a href=\"#27-Remove-Element\" class=\"headerlink\" title=\"[27] Remove Element\"></a>[27] Remove Element</h4><blockquote>\n<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>\n</blockquote>\n<h6 id=\"my-solution-1\"><a href=\"#my-solution-1\" class=\"headerlink\" title=\"my solution\"></a>my solution</h6><p>我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 while 保证对于同一个i, 去除该位置所有与val相等的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 不会遗漏由于删除数组元素而位置前移的新元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (nums[i] == val) &#123;</span><br><span class=\"line\">      nums.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"Two-pointers-2\"><a href=\"#Two-pointers-2\" class=\"headerlink\" title=\"Two pointers\"></a>Two pointers</h6><p>下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.</p>\n<p>主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution two pointers</span></span><br><span class=\"line\"><span class=\"comment\">// 只保留与val不同的元素</span></span><br><span class=\"line\"><span class=\"comment\">// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[j] != val) &#123;</span><br><span class=\"line\">      nums[i] = nums[j];</span><br><span class=\"line\">      <span class=\"comment\">// console.log(\"i=\", i, \" \", nums[i]);</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity : O(n). Assume the array has a total of n<em>n</em> elements, both <em>i</em> and <em>j</em> traverse at most 2<em>n</em> steps.</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<h4 id=\"15-3Sum\"><a href=\"#15-3Sum\" class=\"headerlink\" title=\"[15] 3Sum\"></a>[15] 3Sum</h4><blockquote>\n<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p><strong>Note:</strong></p>\n<p>The solution set must not contain duplicate triplets.</p>\n</blockquote>\n<p>数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 2 ：将数组排序后的双指针解法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> threeSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b); <span class=\"comment\">// 将数组正序排列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一个数大于 0，肯定加起来和不为0了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 去掉重复元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> target = -nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = i + <span class=\"number\">1</span>, right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class=\"line\">        res.push([nums[i], nums[left], nums[right]]);</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">        <span class=\"comment\">// 这里是否判断 left &lt; right 都没有那么重要, 因为最外面还会再判断一次</span></span><br><span class=\"line\">        <span class=\"comment\">// 但是加上判断可能会少做一次计算</span></span><br><span class=\"line\">        <span class=\"comment\">// 去掉重复元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"16-3Sum-Closest\"><a href=\"#16-3Sum-Closest\" class=\"headerlink\" title=\"[16] 3Sum Closest\"></a>[16] 3Sum Closest</h4><blockquote>\n<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n</blockquote>\n<p>注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.</p>\n<p>与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right—, 总之就是不断靠近target.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> threeSumClosest = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> closest = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> diff = <span class=\"built_in\">Math</span>.abs(closest - target);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由于数组是排好序的</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果nums[i] * 3 &gt; target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值</span></span><br><span class=\"line\">    <span class=\"comment\">// 后面差距只会越来越大</span></span><br><span class=\"line\">    <span class=\"comment\">// 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值</span></span><br><span class=\"line\">    <span class=\"comment\">// 优化部分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] * <span class=\"number\">3</span> &gt; target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> cDiff = <span class=\"built_in\">Math</span>.abs(closest - target);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> tempMin = nums[i] + nums[i + <span class=\"number\">1</span>] + nums[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> tDiff = <span class=\"built_in\">Math</span>.abs(tempMin - target);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cDiff &lt; tDiff ? closest : tempMin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双指针 遍历数组剩余元素</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = i + <span class=\"number\">1</span>, right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> newDiff = <span class=\"built_in\">Math</span>.abs(sum - target);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newDiff == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newDiff &lt; diff) &#123;</span><br><span class=\"line\">        diff = newDiff;</span><br><span class=\"line\">        closest = sum;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log('closest:', closest);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> closest;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"18-4Sum\"><a href=\"#18-4Sum\" class=\"headerlink\" title=\"[18] 4Sum\"></a>[18] 4Sum</h4><blockquote>\n<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>\n<p><strong>Note:</strong></p>\n<p>The solution set must not contain duplicate quadruplets.</p>\n</blockquote>\n<p>有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fourSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  nums = nums.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length, res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 去重</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] == nums[i - <span class=\"number\">1</span>] &amp;&amp; i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len - <span class=\"number\">2</span>; j++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[j] == nums[j - <span class=\"number\">1</span>] &amp;&amp; j &gt; i + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"keyword\">let</span> t = target - nums[i] - nums[j];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> left = j + <span class=\"number\">1</span>, right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> twoSum = nums[left] + nums[right];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (twoSum == t) &#123;</span><br><span class=\"line\">          res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class=\"line\">          left++;</span><br><span class=\"line\">          right--;</span><br><span class=\"line\">          <span class=\"comment\">// 去重</span></span><br><span class=\"line\">          <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class=\"number\">1</span>])</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class=\"number\">1</span>])</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (twoSum &gt; t) &#123;</span><br><span class=\"line\">          right--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(res);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"283-Move-Zeroes\"><a href=\"#283-Move-Zeroes\" class=\"headerlink\" title=\"[283] Move Zeroes\"></a>[283] Move Zeroes</h4><blockquote>\n<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>\n<p><strong>Note</strong>:</p>\n<ol>\n<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ol>\n</blockquote>\n<p>双指针解法, 一次成功.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution: two pointers</span></span><br><span class=\"line\"><span class=\"comment\">// 借鉴之前的做题经验, 这题算是完成的比较快</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> moveZeroes = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length, i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[j] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums[i] = nums[j];</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> t = i; t &lt; len; t++) &#123;</span><br><span class=\"line\">    nums[t] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(nums);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"66-Plus-One\"><a href=\"#66-Plus-One\" class=\"headerlink\" title=\"[66] Plus One\"></a>[66] Plus One</h4><blockquote>\n<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, increment one to the integer.</p>\n<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>\n<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>\n</blockquote>\n<p>主要是运用数组特性.不是很难, 理解题意即可.</p>\n<p>还挺多人不喜欢这道题的, 可能觉得太弱智了?…</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> plusOne = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">digits</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = digits.length;</span><br><span class=\"line\">  <span class=\"comment\">// c 表示进位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = len - <span class=\"number\">1</span>, c = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没有向前进位, 就 +1 结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digits[i] + c &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      digits[i]++;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">      <span class=\"comment\">// 首位元素 +1 后有进位, 向数组头部插入 1 结束</span></span><br><span class=\"line\">      digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      digits.unshift(<span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不是首位元素 +1 后有进位</span></span><br><span class=\"line\">      <span class=\"comment\">// 当前元素设为 0 , 继续看更高位元素</span></span><br><span class=\"line\">      digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(digits);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"88-Merge-Sorted-Array\"><a href=\"#88-Merge-Sorted-Array\" class=\"headerlink\" title=\"[88] Merge Sorted Array\"></a>[88] Merge Sorted Array</h4><blockquote>\n<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em>and <em>n</em> respectively.</li>\n<li>You may assume that <em>nums1</em> has enough space (size that is <strong>equal</strong> to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>\n</ul>\n</blockquote>\n<p>我用的方法比较死板, 感觉没有什么难度. 就是分情况讨论. </p>\n<p>不过用到了 js 里 Array 的特性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 说明没有自己的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            nums1[i] = nums2[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = nums1.length;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> j = m;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len &amp;&amp; k &lt; n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums2[k] &gt;= nums1[i] &amp;&amp; nums2[k] &lt; nums1[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                nums1.splice(i + <span class=\"number\">1</span>, <span class=\"number\">0</span>, nums2[k]);</span><br><span class=\"line\">                nums1.pop();</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums2[k] &gt;= nums1[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                nums1[j] = nums2[k];</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums2[k] &lt;= nums1[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                nums1.unshift(nums2[k]);</span><br><span class=\"line\">                nums1.pop();</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">                i = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"80-Remove-Duplicates-from-Sorted-Array-II\"><a href=\"#80-Remove-Duplicates-from-Sorted-Array-II\" class=\"headerlink\" title=\"[80] Remove Duplicates from Sorted Array II\"></a>[80] Remove Duplicates from Sorted Array II</h4><blockquote>\n<p>Given a sorted array <em>nums</em>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n</blockquote>\n<p><strong>时间复杂度</strong>: 遍历整个数组 $O(N)$</p>\n<p><strong>空间复杂度</strong>: 仅使用两个index: left和right标记数组元素位置, $O(1)$ </p>\n<p>使用splice方法直接修改数组. (这个方法的实现原理需要了解一下 TODO)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组是排好序的</span></span><br><span class=\"line\"><span class=\"comment\">// 不能使用额外空间,直接修改数组</span></span><br><span class=\"line\"><span class=\"comment\">// 使所有元素出现次数最多不超过2次</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[right] == nums[left] &amp;&amp; right - left == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      right++;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 说明至少是第三个相同的元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要将该元素删除</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[right] == nums[left] &amp;&amp; right - left &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      nums.splice(right, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 删除元素时会影响原数组的长度</span></span><br><span class=\"line\">      <span class=\"comment\">// 但是right仍然需要控制不能超过数组的边界</span></span><br><span class=\"line\">      len = nums.length;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// right和left指向的元素不同</span></span><br><span class=\"line\">    left = right;</span><br><span class=\"line\">    right = right + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当right==len的时候,说明数组遍历结束</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回当前删除重复元素后的数组长度</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"202-Happy-Number\"><a href=\"#202-Happy-Number\" class=\"headerlink\" title=\"[202] Happy Number\"></a>[202] Happy Number</h4><blockquote>\n<p>Write an algorithm to determine if a number <code>n</code> is “happy”.</p>\n<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1. Those numbers for which this process <strong>ends in 1</strong> are happy numbers.</p>\n<p>Return True if <code>n</code> is a happy number, and False if not.</p>\n</blockquote>\n<p>复杂度分析有点困难, 以及为什么只有循环或者归1两种结果, 而不是无穷大.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solution 1: 快慢指针法</span></span><br><span class=\"line\"><span class=\"comment\">// 快慢指针找循环</span></span><br><span class=\"line\"><span class=\"comment\">// 在平方累加的过程中, 要不最后等于1, 要不最后陷入循环, 至于为什么不是无穷大</span></span><br><span class=\"line\"><span class=\"comment\">// 需要再琢磨一下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isHappy1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 慢指针一次计算一步, 快指针一次计算两步</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果两个指针的值一样, 说明进入循环</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则, 快指针一定比慢指针率先到达1</span></span><br><span class=\"line\">  <span class=\"comment\">// 初始化快慢指针</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = getPow(n), fast = getPow(getPow(n));</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (fast != <span class=\"number\">1</span> &amp;&amp; fast != slow) &#123;</span><br><span class=\"line\">    slow = getPow(slow);</span><br><span class=\"line\">    fast = getPow(fast);</span><br><span class=\"line\">    fast = getPow(fast);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fast == <span class=\"number\">1</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算某个数的各个数位上的平方</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getPow = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = n % <span class=\"number\">10</span>;</span><br><span class=\"line\">    sum += num * num;</span><br><span class=\"line\">    n = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// solution 2: 使用hashmap来判断值有无重复 聪儿判断有无循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isHappy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = getPow(n);</span><br><span class=\"line\">  <span class=\"comment\">// map中没有该计算结果</span></span><br><span class=\"line\">  <span class=\"comment\">// 则添加进map中</span></span><br><span class=\"line\">  <span class=\"comment\">// 不是undefined 说明该计算结果之前已经被塞进map中</span></span><br><span class=\"line\">  <span class=\"comment\">// 得到循环</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (map[res] == <span class=\"literal\">undefined</span> &amp;&amp; res != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    map[res] = <span class=\"string\">'1'</span>;</span><br><span class=\"line\">    res = getPow(res);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res == <span class=\"number\">1</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Vue Learning","abbrlink":"c1889358","date":"2020-07-29T05:34:01.000Z","_content":"\n","source":"_posts/Vue-Learning.md","raw":"---\ntitle: Vue Learning\nabbrlink: c1889358\ndate: 2020-07-29 13:34:01\ntags: [Vue, js]\ncategories: 前端框架\n---\n\n","slug":"Vue-Learning","published":1,"updated":"2020-07-29T05:38:25.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fafy000qmm9h066narly","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JavaScript Notes","abbrlink":11485,"date":"2020-09-01T01:17:06.000Z","_content":"\n\n\n# JavaScript 简介\n\n## 诞生\n\n本名 ECMAScript, 被创建的原因是, 在浏览器输入数据时需要进行验证, 而不是传到服务器才告知客户数据错误或者空白等, 于是被创建时诞生在 NetScape 浏览器中.  \n\n## 特点\n\n只能在浏览器中运行, 不能单独运行, 不能读取文件\n\n由浏览器中的执行模块(JS引擎)执行, 考虑到页面打开的速度, 不编译执行.\n\n## 功能\n\n### 操作HTML的DOM\n\n浏览器从服务器取到HTML页面之后, 会展示页面出来, 但是浏览器内部将HTML组织成一个树给JS, 这个树称为 DOM.\n\n![htmltree](JavaScript-Notes/htmltree.jpg)\n\nJS可以定位并操作DOM中的任意一个节点, 且不用刷新页面, 操作就可以立刻显示出效果. 而且操作是内部进行, 并没有改变 html的源码.\n\n### 控制浏览器\n\n打开窗口/在一个窗口内前进后退/获得浏览器名称+版本(判断是什么浏览器, 才能做这个浏览器支持的特殊操作)...\n\n### 异步调用\n\n不能像java一样访问网络, 就不能调用服务器的接口去获取数据. 用户只能get或者post向服务器发送请求, 服务器返回整个页面, 而不是一个片段, 整个页面得重新刷新.\n\n`XMLHttpRequest` 使得 JS 可以直接向服务器发起接口调用, 等获得服务器返回的数据(此时为`XML`)后执行浏览器提供的回调函数. Called 异步调用. 回调函数基本就是更新DOM树的某个节点, 实现网页的局部刷新. 后来上述的异步调用被称为 `AJAX` (Asynchronous JavaScript And XML).\n\n由于`XML`的标签太多, 真正数据很少, 而且需要XML解析器进行解析, 后来 `JS` 和服务器之间的数据传输使用 `JSON` 这种更简洁的格式.\n\nHTML 结构, CSS 展示, JS(AJAX JSON) 逻辑 = 前端. 可以在浏览器实现 `MVC`.\n\n 后来出现了多种框架, ExtJS/prototype/JQuery/AngularJS将前端推向另一个高峰. \n\n\n\n## JS 移动到服务器端\n\n需要满足下述两个要求:\n\n1. 引擎移动到服务器端, 需要执行地足够快. Chrome V8\n\n2. 绕开 JAVA 服务器的问题, 即线程遇到IO/数据库/网络这样的耗时操作, 不能等待, 换成异步处理.\n\n即后来出现的 node.js, 巨大优势就是: 前后端均使用JS开发.\n\n### Node.js 工作特点\n\n**只用一个线程来处理所有请求, 事件驱动编程.**\n\n需要等待的操作, 会有一个回调函数在那, 线程不会等待. 操作一完成则发出事件通知线程, 线程立马回来执行对应的回调函数, 执行完回调函数再去接着执行那些不需要等待的操作.\n\n即: 需要等待的操作先跳过, 先去执行那些不需要等待的操作, 耗时操作完成后事件通知线程后, 线程再立即回来执行其对应的回调函数. 事件驱动编程, 有需要处理的事件才去处理, 耗时操作先跳过.\n\n<!--more-->\n\n# 数据类型\n\n\n\n## 值类型\n\n### * 布尔值 Boolean\n\ntrue/false\n\n\n\n### * 字符串 String\n\n#### 创建\n\n```javascript\nlet s1 = 'hello'; // 字面量创建\nlet thing = 98; // 任何可以转换成字符串的值\n/* String 函数 生成或者将值转换为字符串 */\nlet s2 = String(thing); // 将thing转换为原始字符串\nlet s3 = new String(thing); // 新建String对象, 并存储thing的字符串表示\nconsole.log(s1, typeof s1); // hello string\nconsole.log(s2, typeof s2); // 98 string\nconsole.log(s3, typeof s3); // [String: '98'] object\n```\n\n字符串一旦创建, 其内容不可被修改, 只能重新被赋值.\n\n```javascript\nlet str = \"hello\";\nstr[1] = '*';\nconsole.log(str, str[1]); // hello e\nstr = \"world\";\nconsole.log(str); // world\n```\n\n\n\n#### 属性\n\n`length`\n\n字符串长度\n\n```javascript\nlet s = 'hello';\nconsole.log(s.length); // 5\n```\n\n`constructor`\n\n对创建该对象的函数的引用\n\n```javascript\nlet s = 'hello';\nconsole.log(s.constructor); // [Function: String]\n```\n\n\n\n#### 方法\n\n##### 处理\n\n`toUpperCase`  \n\n字符串变大写\n\n`toLowerCase `  \n\n字符串变小写\n\n```javascript\nlet s = 'hello', t = 'JINLING';\nconsole.log(s.toUpperCase(), s); // HELLO hello\nconsole.log(t.toLowerCase(), t); // jinling JINLING\n```\n\n`trim`\n\n去除字符串两边的空白. 原字符串未改变.\n\n```javascript\nlet str = \"   hello   *   \";\nconsole.log(str.trim(), ', |' + str + '|'); // hello   * , |   hello   *   |\n```\n\n`split` \n\n根据分隔符将字符串分割为数组\n\n```javascript\nlet s = 'hel,l,o';\n// 不切割 整个字符串视作数组的一个元素\nconsole.log(s.split());  // [ 'hel,l,o' ]\n// 每个字符都是数组中的元素\nconsole.log(s.split(''));\n/* \n[\n 'h', 'e', 'l',\n ',', 'l', ',',\n 'o'\n]\n*/\n// 以逗号分割\nconsole.log(s.split(','), s); // [ 'hel', 'l', 'o' ] hel,l,o\n```\n\n##### 查找\n\n`indexOf`\n\n查找字符串中有无指定字符串, 有则返回下标, 没有则返回-1\n\n```javascript\nlet s = \"hello jinling!\"\nlet res1  = s.indexOf(\"hi\");\nlet res2  = s.indexOf(\"jin\");\nconsole.log(res1, res2); // -1 6\n```\n\n`includes`\n\n查找字符串是否包含指定子串, 有则返回`true`, 反之`false`.\n\n```javascript\nlet str = \"hello jinling good\";\nconsole.log(str.includes(\"hello\"), str.includes(\"world\")); // true false\n```\n\n`charAt`\n\n返回字符串中对应下标的字符\n\n```javascript\nlet s = \"hello*jinling!\"\nlet ch = s.charAt(5);\nconsole.log(ch); // *\n```\n\n##### 拼接/截取\n\n`concat`\n\n拼接两个或者更多字符串, 返回新字符串, 不改变原字符串.\n\n```javascript\nlet s1 = \"hello\", s2 = \"*go\", s3 = \"*hhh\";\nlet s = s1.concat(s2, s3);\nconsole.log(s, s1, s2, s3) // hello*go*hhh hello *go *hhh\n```\n\n`slice`\n\n截取字符串的片段, 不改变原字符串.\n\n```javascript\nlet str = \"helloWorld\";\nlet s = str.slice(3, 7); // [起始位置, 结束位置)\nconsole.log(s, str); // loWo helloWorld\n```\n\n`substring`\n\n截取字符串的片段, 不改变原字符串.\n\n```javascript\nlet s = 'helloWorld';\n // [起始位置, 结束位置)\nconsole.log(s.substring(1, 8), s); // elloWor helloWorld\n```\n\n`substr`\n\n截取指定长度的子串. (ps. ECMAscript 没有对该方法进行标准化，因此反对使用它。)\n\n```javascript\nlet s = 'helloWorld';\n// 起始位置 截取长度\nconsole.log(s.substr(1, 4), s); // ello helloWorld\n```\n\n\n\n### * 数字 Number\n\n数字可以是数字或者对象, Number 对象是原始数值的包装对象. JS只有一种数字类型.\n\n#### 创建\n\n```javascript\n/* 基础类型创建 */\nlet k = 5;\nconsole.log(typeof k); // number\n// 科学计数法\nlet t = 123e5, k = 123e-5;\nconsole.log(typeof t, t, typeof k, k); // number 12300000 number 0.00123\n// 八进制以0开头\nlet n = 0122; // 数字以 0 开头, 且后面的数字都比8小, 则js解释为八进制\nconsole.log(n); // 82\nlet n = 0888; // 后面数字>=8, 则依然解释为十进制\nconsole.log(n); // 888\n// 十六进制以0x开头\nlet n = 0x11;\nconsole.log(n); // 17\n\n/* 对象形式创建 */\nlet m = new Number(\"99\"), n = new Number(10);\nconsole.log(typeof m, m, typeof n, n); \n// object [Number: 99] object [Number: 10]\n\nlet t = new Number(\"kill\"); // 不能转换为数字时\nconsole.log(typeof t, t); // object [Number: NaN]\n```\n\n#### 属性\n\n返回对创建此对象的 Number 函数的引用.\n\n```javascript\nlet a = 8;\nconsole.log(a.constructor); // [Function: Number]\n```\n\n\n\n#### 方法\n\n`toString`\n\n将数字转变为字符串, 使用指定的基数.\n\n```javascript\nlet t = new Number(\"99\");\nlet str = t.toString();\nconsole.log(typeof str, str); // string 99\n\n// 使用指定的基数\nlet t = new Number(\"10\");\nlet str = t.toString(2); // 十进制转变为二进制\nconsole.log(typeof str, str); // 1010\n\nlet t = new Number(\"10\");\nlet str = t.toString(8); // 十进制转变为八进制\nconsole.log(typeof str, str); string 12\n```\n\n`valueOf`\n\n返回一个 Number 对象的基本数字值.\n\n```javascript\nlet t = new Number(\"99\");\nconsole.log(t.valueOf()); // 99\n```\n\n`isFinite`\n\n判断参数是否为无穷大\n\n```javascript\nNumber.isFinite(123) // true\nNumber.isFinite(-1.23) // true\nNumber.isFinite(5-2) // true\nNumber.isFinite(0) // true\nNumber.isFinite('123') // false\nNumber.isFinite('Hello') // false\nNumber.isFinite('2005/12/12') // false\nNumber.isFinite(Infinity) // false\nNumber.isFinite(-Infinity) // false\nNumber.isFinite(0 / 0) // false\nNumber.isFinite(NaN) // false\n```\n\n`isNaN`\n\n使用全局函数判断`NaN`(教程推荐).\n\n```javascript\nlet a = NaN;\nconsole.log(isNaN(a), isNaN(8), isNaN(\"11\")); // true false false\n```\n\n\n\n### * Symbol (ES6)\n\n基本数据类型, ES6新增, 表示独一无二的值. 由于 ES5 对象的属性名只能是字符串, 容易造成属性名的冲突, 需要独一无二的值.\n\n具有静态属性与静态方法. 模拟对象私有属性.\n\n#### 概述\n\n通过`Symbol`函数产生.\n\n```javascript\n// 接受字符串作为参数, 表示对Synbol实例的描述, 主要为了在控制台显示或者转为字符串时容易被区分.\nSymbol(**description?: string | number**): symbol\n\nDescription of the new Symbol object.\n\nReturns a new unique Symbol value.\n```\n\n每个从 Symbol 返回的symbol值都是唯一的, 尽管参数相同.\n\n```javascript\nlet sym = Symbol();\nlet sym1 = Symbol(34); \n// Symbol 不会将'hello'转变为symbol类型, 每次创建一个新的symbol类型.\nlet sym2 = Symbol('hello'); \nlet sym3 = Symbol('hello'); \n\nconsole.log(typeof sym, sym); // symbol Symbol()\nconsole.log(sym1 == 34); // false\nconsole.log(sym2 == 'hello', sym2, sym2.toString()); // false Symbol(hello) 'Symbol(hello)'\nconsole.log(sym2 === sym3); // false\n```\n\n`Symbol`可以转换为**字符串**以及**布尔值**, 但是不能转换为数值.\n\n```javascript\nlet s1 = Symbol('happy');\nconsole.log(s1.toString(), String(s1)); // Symbol(happy) Symbol(happy)\n\nlet s1 = Symbol('happy');\nconsole.log(Boolean(s1)); // true\n\nlet s1 = Symbol('happy');\nconsole.log(Number(s1)); // TypeError: Cannot convert a Symbol value to a number\n```\n\n对原始数据类型创建一个显式包装器对象从ES6开始不再被支持, 但是原有的 new Boolean/new String/new Number 由于遗留原因仍然可以被创建.\n\n如果真的想创建一个Symbol包装器, 可以使用Object()函数.\n\n```javascript\n// symbol 是原始数据类型 不是对象\nlet s = new Symbol(); // TypeError: Symbol is not a constructor\n\nlet sym = Symbol(34); \nconsole.log(typeof sym); // symbol\nlet symObj = Object(sym);\nconsole.log(typeof symObj); // object\n```\n\n#### 作为属性名\n\n```javascript\nlet mySymbol = Symbol();\n\n// 第一种写法\nlet obj = {};\nobj[mySymbol] = 'hello';\n\n// 第二种写法\nlet obj = {\n  [mySymbol]: 'hello'\n}\n\n// 第三种写法\nlet obj = {};\n// 将对象的属性名指定为一个 Symbol 值\nObject.defineProperty(obj, mySymbol, { value: 'hello' });\n\n// 三种写法 同样结果\nobj[mySymbol] // 'hello'\n```\n\n`Symbol` 作为对象属性时, 不能使用点运算符, 只能使用方框`[]`.\n\n```javascript\nlet mySymbol = Symbol();\n\nlet obj = {};\nobj[mySymbol] = 'hello';\nobj.mySymbol = 'hi'; // 相当于属性名为 'mySymbol' 字符串\nconsole.log(obj.mySymbol); // hi\nconsole.log(obj[mySymbol]); // hello\n\n// 作为对象属性, 只能使用方框\nlet obj = {\n  [s]: function (arg) { ... }\n}\n\n// 增强的对象写法\nlet obj = {\n  [s] (arg) { ... }\n}\n```\n\n\n\n### * null\n\n`null` : 表示主动释放指向对象的引用.\n\n```javascript\nlet a = [1,2]\na = null;\nconsole.log(a); // 释放指向数组的引用\n```\n\n设计之初, `null` 像在java里一样, 被当成一个**对象**.\n\n```javascript\nconsole.log(typeof null); // object\n```\n\n可以自动转为 0 \n\n```javascript\nconsole.log(Number(null), 8 + null); // 0 8\n```\n\n**用法: null 表示\"没有对象\", 即 该处不应该有值.**\n\n1. 作为函数的参数, 表示该函数的参数不是对象\n2. 作为对象原型链的终点\n\n```javascript\nconsole.log(Object.getPrototypeOf(Object.prototype)); // null\n```\n\n\n\n### * undefined\n\nBrendan Eich 觉得, 表示'无'的值, 最好不是对象. 其次, 由于js初版本没有错误处理机制, null 自动转为 0 不容易发现错误. 于是 Brendan Eich又设计了一个`undefined`.\n\n一开始 `undefined` 被设计为表示'无'的原始值, 转为数字时为 NaN\n\n```javascript\nconsole.log(Number(undefined), 8 + undefined); // NaN NaN\n```\n\n**用法: undefined 表示\"缺少值\", 就是此处应该有一个值, 但是还没有定义.**\n\n1. 变量被声明过, 但是没有赋值, 等于 undefined\n2. 调用函数时, 应该提供的参数没有提供, 则该参数为 undefined\n3. 对象没有赋值的属性, 该属性值为 undefined\n4. 函数没有返回值时, 默认返回 undefined.\n\n```javascript\n// 用法 1\nvar a;\nlet b;\nconsole.log(a,b); // undefined undefined\n\n// 用法 2\nlet test = (a) => {\n  console.log(a);\n}\ntest(); // undefined\n\n// 用法 3\nlet obj = {}\nconsole.log(obj.a); // undefined\n\n// 用法 4\nlet test = () => { }\nconsole.log(test()); // undefined\n```\n\n\n\n#### undefined 与 null 区别\n\n两者使用 == 时为true, === 时为false.\n\n```javascript\nconsole.log(undefined == null, undefined === null);\n// true false\n\n// 在if语句中, 两者都被转成 false\nif (!undefined) console.log('undefined if false'); // undefined if false\nif (!null) console.log('null if false'); // null if false\n```\n\n\n\n## 引用类型\n\n\n\n### * 数组 Array\n\n#### 创建\n\n```javascript\nlet arr0 = []; // 字面\nlet arr1 = new Array(); // 不固定长度\nlet arr2 = new Array(5); // 固定长度\nlet arr3 = new Array(1,2,3,5);\n\nconsole.log(arr0, arr1, arr2, arr3); // [] [] [ <5 empty items> ] [ 1, 2, 3, 5 ]\n```\n\n#### 其他数据类型转数组\n\nset->Array\n\nArray.from(set)\n\nstring->Array\n\n#### 属性\n\n`length`\n\n> 计算并返回数组长度\n\n```javascript\nlet arr0 = [1,2,3,4]; // 字面\nconsole.log(arr0.length); // 4\n```\n\n`constructor`\n\n> 返回创建该对象的函数的引用, 因为js的一切变量都是对象, 是对象就有其构造函数.\n>\n\n```javascript\nvar test=new Array();\nif (test.constructor==Array){\n\tdocument.write(test.constructor);\n}\n// output: function Array() { [native code] }\n```\n\n#### 方法\n\n##### 改变原数组\n\n**Array.sort()**\n\n> 对数组元素进行排序, 默认是字符串顺序.\n>\n\n```javascript\n// 按照字母顺序排序 默认\nlet arr = ['hi', 'Bob', 'good', 'are', 'you', 'google'];\narr.sort();\nconsole.log(arr); // [ 'Bob', 'are', 'good', 'google', 'hi', 'you' ]\n```\n\n> 添加比值函数, 使得能对**数字进行排序**.\n>\n\n```javascript\n// 不使用比值函数\nlet arr = [3, 7, 9, 1, 0, 12, 34, 76, 91];\narr.sort();\nconsole.log(arr); \n/* \n[\n  0,  1, 12,  3, 34,\n  7, 76,  9, 91\n]\n*/\n\n// 使用比值函数 倒序\nlet arr = [3, 7, 9, 1, 0, 12, 34, 76, 91];\narr.sort((a, b) => b - a);\nconsole.log(arr);\n/*\n[\n  91, 76, 34, 12, 9,\n   7,  3,  1,  0\n]\n*/\n\n// 使用比值函数 正序\nlet arr = [3, 7, 9, 1, 0, 12, 34, 76, 91];\narr.sort((a, b) => a - b);\nconsole.log(arr); \n/*\n[\n   0,  1,  3,  7, 9,\n  12, 34, 76, 91\n]\n*/\n```\n\n**Array.pop()**\n\n> 删除数组的最后一个元素并返回该元素. 空数组返回`undefined`.\n>\n\n```javascript\nlet arr0 = [1, 2, 3, 4];\nconsole.log(arr0.pop(), arr0);\n// output: 4 [ 1, 2, 3 ]\n\nlet arr1 = [];\nconsole.log(arr1.pop(), arr1);\n// output: undefined []\n```\n\n**Array.shift()**\n\n> 删除并返回数组的第一个元素\n>\n\n```javascript\nlet arr1 = [1,2,3];\nconsole.log(arr1.shift(), arr1);\n// 1 [ 2, 3 ]\n```\n\n**Array.unshift()**\n\n> 向数组的开头添加元素并返回现有长度\n>\n\n```javascript\nlet arr1 = [1, 2, 3, 4, 5];\nconsole.log(arr1.unshift(9), arr1);\n// 6 [ 9, 1, 2, 3, 4, 5 ]\n```\n\n**Array.push()**\n\n> 向数组末尾添加元素并返回数组现有长度\n>\n\n```javascript\nlet arr1 = [1,2,3];\nconsole.log(arr1.push(4), arr1);\n// output: 4 [ 1, 2, 3, 4 ]\n```\n\n**Array.reverse()**\n\n> 颠倒数组中元素顺序\n>\n\n```javascript\nlet arr1 = [1,2,3];\nconsole.log(arr1.reverse(), arr1);\n// output: [ 3, 2, 1 ] [ 3, 2, 1 ]\n```\n\n**Array.splice()** \n\n> 推荐使用该方法删除数组元素\n>\n> 注意: 删除的元素以数组形式返回.\n>\n\n```javascript\nlet arr = [1, 2, 3, 4, 5]\narr.splice(2, 1, 'ok', 'fine'); // 从数组下标为2的位置开始删除1个元素,再插入2个元素\nconsole.log(arr); // [ 1, 2, 'ok', 'fine', 4, 5 ]\n\n// 不留空洞地删除元素\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\n// 从下标为3的位置开始, 删除2个元素\nconsole.log(arr.splice(3, 2)); // ['fine', 'you'] 注意这里是数组形式!\nconsole.log(arr); // [ 1, 2, 'ok', 'bye' ]\n```\n\n**delete**  \n\nJS运算符\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\ndelete arr[0];\nconsole.log(arr[0], arr); // 留下了空洞\n// undefined [ <1 empty item>, 2, 'ok', 'fine', 'you', 'bye' ]\n```\n\n\n\n##### 不改变原数组\n\n**Array.slice()**\n\n> 根据下标获取数组的一部分, 返回新数组.\n>\n\n```javascript\nlet arr1 = [1, 2, 3, 4, 5];\nconsole.log(arr1.slice(3), arr1.slice(2,4), arr1);\n// output: [ 4, 5 ] [ 3, 4 ] [ 1, 2, 3, 4, 5 ]\n```\n\n**Array.concat()**\n\n> 拼接数组成一个新数组\n>\n\n```javascript\nlet arr0 = [1, 2, 3, 4];\nlet arr1 = [5, 6];\nconsole.log(arr0.concat(arr1), arr0, arr1);\n// output: [ 1, 2, 3, 4, 5, 6 ] [ 1, 2, 3, 4 ] [ 5, 6 ]\n```\n\n**Array.flat()**\n\n> 按照指定的深度递归遍历数组, 将所有元素与遍历到的子数组中的元素合并为一个**新数组**返回.\n>\n> 将数组扁平化\n\n```javascript\n/* 默认递归深度为1 */\nlet arr = [1, 2, ['ok', 'fine']]\nlet arr1 = arr.flat();\nconsole.log(arr1, arr);\n// [ 1, 2, 'ok', 'fine' ] [ 1, 2, [ 'ok', 'fine' ] ]\n\n// 移除数组空项\nlet arr = [1, 2, null, undefined, , , 5];\nconsole.log(arr.flat());\n// [ 1, 2, null, undefined, 5 ]\n\n/* 指定递归深度 */\nlet arr = [1, 2, [[['ok', 'fine']]]];\nconsole.log(arr.flat(2), arr.flat(3));\n// [ 1, 2, [ 'ok', 'fine' ] ] [ 1, 2, 'ok', 'fine' ]\n```\n\n**Array.join()**  默认使用 `,` 为分隔符\n\n> `toString` 所有 JavaScript 对象都拥有`toString()`方法\n>\n> 数组所有元素组成字符串, 可以指定分隔符.\n>\n\n```javascript\nlet arr0 = [1, 2, 3, 4];\nconsole.log(arr0.join(), arr0.toString()); // 1,2,3,4  1,2,3,4\nconsole.log(arr0.join('*')); // 1*2*3*4\nconsole.log(arr0); // [ 1, 2, 3, 4 ]\n```\n\n**Array.map()**\n\n> 对数组的每个元素均执行函数, 对其做一些处理, 来生成新数组. **不改变原数组**.\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\nlet arr2 = arr.map((val, index, array) => {\n  return val + '*' + index;\n});\n// 原数组不变\nconsole.log(arr2, arr);\n// [ '1*0', '2*1', 'ok*2', 'fine*3', 'you*4', 'bye*5' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]\n\nvar arr = [1, 2, 3, 4, 5]\nlet a = arr.map(c => c - 1);\nconsole.log(a); // [ 0, 1, 2, 3, 4 ]\n```\n\n**Array.filter()**\n\n> 对数组的每个元素均执行函数, 筛选符合条件的元素来生成新数组.**不改变原数组**.\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\nlet arr2 = arr.filter((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(arr2, arr);\n// [ 'ok', 'fine', 'you', 'bye' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]\n```\n\n**Array.forEach()**\n\n> 对数组的每个元素均执行一次函数(回调函数)\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\nlet s = '';\n// 该函数的参数1为数组元素,参数2为数组元素下标,参数3为该数组本身\narr.forEach((val, index, array) => {\n  s += (val + '/' + index + ' ');\n});\nconsole.log(s); // 1/0 2/1 ok/2 fine/3 you/4 bye/5 \n```\n\n**Array.reduce()**\n\n> 参数`total` 默认是数组的第一个元素, 可以设置初始值.\n\n```javascript\nlet arr = ['bye', 'hi', 'ok', 'fine', 'you', 'bye']\nlet res = arr.reduce((total, val, index, array) => {\n  console.log(\"total=\", total, val, index); // 从index=1开始打印\n  return total + '*' + val;\n});\nconsole.log(res, arr);\n/*\ntotal= bye hi 1\ntotal= bye*hi ok 2\ntotal= bye*hi*ok fine 3\ntotal= bye*hi*ok*fine you 4\ntotal= bye*hi*ok*fine*you bye 5\nbye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]\n*/\n\n// 设置total初始值\nlet arr = ['bye', 'hi', 'ok', 'fine', 'you', 'bye']\nlet res = arr.reduce((total, val, index, array) => {\n  return total + '*' + val;\n}, \"this is :\");\nconsole.log(res, arr);\n// this is :*bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]\n```\n\n**Array.reduceRight()**\n\n> 类似于`Array.reduce()`, 只不过是从右往左遍历元素.\n\n```javascript\nlet arr = ['bye1', 'hi', 'ok', 'fine', 'you', 'bye2']\nlet res = arr.reduceRight((total, val, index, array) => {\n  return total + '*' + val;\n}, \"this is res:\");\nconsole.log(res, arr);\n// this is res:*bye2*you*fine*ok*hi*bye1 [ 'bye1', 'hi', 'ok', 'fine', 'you', 'bye2' ]\n```\n\n**Array.every()**\n\n> 检查数组中的元素是否**都符合条件**, 都符合才返回true, 否则返回false.\n\n```javascript\n// 有元素不符合条件 false\nlet arr = [1, 'hi', 'ok', 'fine']\nlet res = arr.every((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(res, arr);\n// false [ 1, 'hi', 'ok', 'fine' ]\n\n// 所有元素均符合条件 true\nlet arr = [1, 2, 3];\nlet res = arr.every((val, index, array) => {\n  return typeof val == 'number';\n});\nconsole.log(res, arr);\n// true [ 1, 2, 3 ]\n```\n\n**Array.some()**\n\n> 检查是否**有元素符合条件**, 有则返回true, 没有则返回false.\n\n```javascript\n// 有元素符合条件 true\nlet arr = [1, 'hi', 'ok', 'fine']\nlet res = arr.some((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(res, arr);\n// true [ 1, 'hi', 'ok', 'fine' ]\n\n// 所有元素均不符合条件 false\nlet arr = [1, 2, 3];\nlet res = arr.some((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(res, arr);\n// false [ 1, 2, 3 ]\n```\n\n**Array.indexOf()**\n\n> 找到给定元素在数组中第一次出现的位置, 没有则返回-1, 找到则返回元素下标.\n\n```javascript\n// 找不到 -1, 找到就下标\nlet arr = ['hi', 'Bob', 'how', 'are', 'you'];\nlet res1 = arr.indexOf(3);\nlet res2 = arr.indexOf('how');\nconsole.log(res1, res2); // -1 2\n\n// 元素多次出现 返回第一次出现的位置\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob'];\nlet res2 = arr.indexOf('Bob');\nconsole.log(res2); // 1\n\n// 指定搜索位置\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob'];\nlet res2 = arr.indexOf('Bob', 2);\nconsole.log(res2); // 5\n\n// 搜索起始位置可以是负值\n// 负值是从数组末尾给定位置开始搜索, 直至末尾.\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.indexOf('Bob', -1), // 从倒数第一个位置开始, 搜索不到\n    res2 = arr.indexOf('Bob', -2); // 从倒数第二个位置开始搜索, 是可以检索到的, 返回正数下标\nconsole.log(res1, res2); // -1 5\n```\n\n**Array.lastIndexOf()**\n\n> 与上一个类似, 只是从数组末尾开始检索.\n\n```javascript\n// 出现两次Bob, 但是返回了从右往左的第一个.\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.lastIndexOf('Bob');\nconsole.log(res1); // 5\n\n// 设定搜索起始位置\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.lastIndexOf('Bob', -3); // 从倒数第三个元素开始往左搜索, 返回匹配的第一个元素的下标\nconsole.log(res1); // 1\n```\n\n**Array.find()**\n\n> 返回符合条件的第一个元素\n\n```javascript\nlet arr = ['hi', 'Bob', 'good', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.find((val, index, array) => {\n  return val.length > 3;\n});\nconsole.log(res1); // good\n```\n\n**Array.findIndex()**\n\n> 返回符合条件的第一个元素**下标**\n\n```javascript\nlet arr = ['hi', 'Bob', 'good', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.findIndex((val, index, array) => {\n  return val.length > 3\n});\nconsole.log(res1); // 2\n```\n\n\n\n#### 数组操作\n\n##### 去重\n\n利用键本身的不可重复性\n\n> 利用ES6 Set 去重 (ES6中最常用)\n\n```javascript\nlet arr = [1, 2, 2, 3, 3, 3];\nlet res = Array.from(new Set(arr));\nconsole.log(res); // [ 1, 2, 3 ]\n\n// 简易写法\n[...new Set(arr)]\n```\n\n双层循环法 \n\n> splice去重(ES5 常用)\n\n```javascript\nfunction unique (arr) {\n  // 每一个元素都向后检查有没有与自己相同的元素\n  // 如果有 则删除第二个元素\n  // 由于splice的特性 删除后 需要j-- 保证j指向被删除元素的下一个元素而不会遗漏元素\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) { // 注意使用===, 因为 null === undefined 为true\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n}\n\nlet arr1 = [1, 2, 2, 3, 3, 3];\nunique(arr1);\nconsole.log('arr1:', arr1); // arr1: [ 1, 2, 3 ]\n```\n\n> 使用 fliter+indexOf\n\n```javascript\nfunction unique (arr) {\n  return arr.filter((val, index) => {\n    // 返回符合条件的元素\n    // 返回所有第一次出现的元素\n    return arr.indexOf(val, 0) == index;\n  })\n}\n\nlet arr1 = [1, 2, 2, 3, 3, 3, null, undefined];\nlet res = unique(arr1);\nconsole.log('res:', res);\n// res: [ 1, 2, 3, null, undefined ]\n```\n\n\n\n### * Map (ES6)\n\n解决js对象的键只能是字符串的问题, **ES6标准新增**的数据类型.\n\n#### 创建/添加/删除/是否包含\n\n```javascript\n// 二维数组\nlet map = new Map([['Michael', 90], ['Bob', 80], ['Lily', 95]]);\nconsole.log(map.get('Lily')); // 95\nconsole.log(map); // Map { 'Michael' => 90, 'Bob' => 80, 'Lily' => 95 }\n\n// 初始化一个空map, 然后添加元素\nlet map = new Map();\nmap.set('Michael', 90); // 添加Key\nmap.set('Bob', 80);\nmap.set('Lily', 95);\nconsole.log(map); // Map { 'Michael' => 90, 'Bob' => 80, 'Lily' => 95 }\nmap.delete('Lily'); // 删除 key\nconsole.log(map); // Map { 'Michael' => 90, 'Bob' => 80 }\n// 判断是否包含某key\nconsole.log(map.has('hello'), map.has('Bob')); // false true\n// 获取值\n// 一个key只对应一个value, 重复设置会覆盖之前的值\nmap.set('Bob', 100);\nconsole.log(map.get('Bob')); // 100\n```\n\n\n\n### * Set (ES6)\n\n一组不重复key的集合.ES6标准新增的数据类型.\n\n#### 创建/添加/删除/是否包含\n\n```javascript\n// 数组作为输入\nlet set1 = let set1 = new Set([5, 6, 7, 8, 8, 7]);\nconsole.log(set1); // Set { 5, 6, 7, 8 } 重复元素被自动过滤\n\n// 初始化空Set, 再添加值\nlet set = new Set();\nset.add(1); // 添加元素\nset.add(2);\nset.add(3);\nset.add(4);\nconsole.log(set); //Set { 1, 2, 3, 4 }\nset.delete(3); // 删除元素\nconsole.log(set); // Set { 1, 2, 4 }\nset.add(4); // 可以添加重复元素 但是无效\nconsole.log(set); // Set { 1, 2, 4 }\n// '4' 与 4 不同\nconsole.log(set.has('4'), set.has(4)); // false true\n```\n\n\n\n### * 函数\n\n函数定义是一个常规的绑定,  其中绑定的值是函数. \n\n函数的第一种表示法.\n\n```javascript\n// 大括号必要, 末尾建议带分号\nlet square = function (x) {\n  return x * x;\n};\n```\n\n函数也是值的一种, 可以被赋值给多个变量/作为参数传递给函数等.\n\n```javascript\nlet func1 = () => {\n  console.log('1111');\n}\nfunc1(); // 1111\n\n// func1 可以被绑定为其他函数\nfunc1 = () => {\n  console.log('2222');\n}\nfunc1 // 2222\n```\n\n没有 `return` 语句或 `return` 后面没有返回值, 函数将返回 `undefined`.\n\n```javascript\nlet func1 = () => {\n  return;\n}\nconsole.log(func1()); // undefined\n\nlet func2 = () => {\n}\nconsole.log(func2()); // undefined\n```\n\n每个局部作用域可以查看包含它的局部作用域, 所有局部作用域都能看见全局作用域.\n\n#### 声明表示法\n\n函数的第二种表示法.\n\n声明在调用之后也能够工作, 声明在概念上被移到了作用域的顶部.\n\n```javascript\nfunction square (x) {\n  return x * x;\n} // 不需要分号\n```\n\n#### 箭头函数\n\n函数的第三种表示法. 以较简明的方式编写小型函数表达式.\n\n```javascript\n// 两种写法相同\nlet square1 = (x) => {\n  return x * x;\n};\n\nlet square2 = x => x * x;\n```\n\n#### 调用栈\n\n函数返回时必须跳回到调用它的位置, 所以计算机必须记住调用发生的上下文. 存储此上下文的位置是调用栈, 每次调用函数时, 当前上下文都存储在此栈的顶部.\n\n#### 可选参数\n\n多余参数自动忽略, 不足参数为 `undefined`.\n\n```javascript\nlet square1 = (x, y) => {\n  console.log(x, y);\n  return x * y;\n};\n\nconsole.log(square1(2, 7, 'helloo'[2, 3]), square1(2));\n// 2 7\n// 2 undefined\n// 14 NaN\n```\n\n参数设定默认值\n\n```javascript\nlet square1 = (x, y = 3) => {\n  console.log(x, y);\n  return x * y;\n};\n\nconsole.log(square1(2, 7), square1(2));\n// 2 7\n// 2 3\n// 14 6\n```\n\n#### 作用域链\n\n定义了一个函数激活执行的时候, 去哪里找变量的值.\n\n```javascript\nfunction createFunc () {\n  var desc = ' is eating';\n  function eat (animal) {\n    console.log(animal.name + desc);\n  }\n  return eat;\n}\nlet dog = { name: 'dog' }\nvar eat = createFunc();\n// 全局变量\nvar desc = '吃东西';\neat(dog); // dog is eating\n```\n\n`eat` 函数的作用域链如下:\n\n```javascript\neat函数作用域[parent作用域-A]\n\nA = createFunc作用域[desc: ' is eating', eat: <func 定义>, parent作用域-B]\n\nB = Global作用域[desc: '吃东西', createFunc: <func 定义>, parent作用域-null]\n```\n\neat 函数中没有定义 `desc` 这个变量值, 就沿着作用域链去找, 在 `createFunc` 作用域中找到了 `desc` 变量的值, 于是就使用了.如果还没有找到, 就接着往上找.\n\n当执行 `createFunc` 的时候, `eat` 函数被创建, 此时 eat 函数会把外部函数的作用域链记录下来, 留到执行时使用. \n\n注意: 作用域链是**函数创建时刻**发生关联的, 不是运行时刻. Called **静态作用域/词法作用域**. 函数被创建即函数被定义.\n\n```javascript\nvar x = 1;\n// 此处 foo 函数被创建, 与全局作用域相关联\nfunction foo () {\n  console.log(x);\n}\n\nfunction bar (func) {\n  var x = 2;\n  func();\n}\n\n// foo 函数执行时直接去全局作用域找 x 变量\nbar(foo); // 1\n```\n\n静态作用域是实现闭包的必需条件.\n\n\n\n#### 闭包\n\n闭包在 JS 中就是一个以函数和以静态方式存储的父作用域的一个集合体.\n\n能够**读取函数局部变量的函数**就是闭包. 下面例子中, `func2`函数就是闭包.\n\n```javascript\nvar func1 = () => {\n  let a = 999;\n  var func2 = () => {\n    return a;\n  }\n  return func2;\n}\nlet func = func1();\nconsole.log(func()); // 999\n```\n\n用途: 读取函数内部变量 / 让这些变量的值始终保持在内存中.\n\n```javascript\nlet nAdd;\nvar func1 = () => {\n  let a = 999;\n  nAdd = function(){\n    a++;\n  }\n  var func2 = () => {\n    console.log('a:',a);\n  }\n  return func2;\n}\nlet func = func1(); // 闭包函数\nfunc(); // a 999\nnAdd();\nfunc(); // a 1000\n```\n\n证明了`func1`的局部变量`a`一直在内存中, 并没有在func1被调用后被自动清除. \n\n因为`func1`是`func2`的父函数, 而`func2`被赋予了局部变量`func`, 导致`func2`一直在内存中, 则`func2`依赖的`func1`也一直在内存中, 不会在调用结束后, 被垃圾回收机制回收.\n\n这里`nAdd`也是一个匿名函数, 也是一个闭包, 相当于一个setter, 可以在函数外部对函数内部局部变量进行操作.\n\n使用闭包的注意点:\n\n1. 闭包会使函数中的局部变量在内存中, 因此会使得内存占用过多, 不能滥用. 在退出函数前, 将不使用的局部变量全部删除.\n2. 闭包会在函数外部, 改变父函数内部变量的值, 注意不要随便改变.\n\n思考题:\n\n1. `this` 在函数中而不是方法中使用时, 指向全局对象\n\n```javascript\nvar name = \"The Window\";\n\nvar object = {\n  name: \"My Object\",\n\n  getNameFunc: function () {\n    return function () {\n      console.log(this);\n      return this.name;\n    };\n  }\n};\n\n// 这里直接在 vscode 中执行, 所以打出来是 undefined, 可能原本是 The Window\nconsole.log(object.getNameFunc()()); // undefined\n\n// this 打印出来如下\n/* \nObject [global] {\n  global: [Circular],\n  clearInterval: [Function: clearInterval],\n  clearTimeout: [Function: clearTimeout],\n  setInterval: [Function: setInterval],\n  setTimeout: [Function: setTimeout] {\n    [Symbol(nodejs.util.promisify.custom)]: [Function]\n  },\n  queueMicrotask: [Function: queueMicrotask],\n  clearImmediate: [Function: clearImmediate],\n  setImmediate: [Function: setImmediate] {\n    [Symbol(nodejs.util.promisify.custom)]: [Function]\n  }\n}\n*/\n```\n\n2. 这里 `that` 指向整个 object.\n\n```javascript\nvar name = \"The Window\";\n\nvar object = {\n  name: \"My Object\",\n  getNameFunc: function () {\n    var that = this;\n    return function () {\n      return that.name;\n    };\n  }\n};\n\nconsole.log(object.getNameFunc()()); // My Object\n```\n\n\n\n#### arguments\n\n对应于传递给函数的参数的类数组对象, 是所有非箭头函数中可用的局部变量, 可以使用它来引用函数的参数.\n\n1. arguments参数可以被设置\n2. 不是一个Array, 只是类似, 类型是 object\n3. 只有length和索引元素功能\n4. 可以被转换为真正的数组\n\n```javascript\nfunction unique (a, b, c, d, e) {\n  console.log(arguments[1]); // 2\n  // 参数被设置\n  arguments[1] = 3;\n  arguments[4][0] = 'Mary';\n  console.log(arguments[1], arguments[4]); // 3 [ 'Mary', 'hi', 'go' ]\n\n  // arguments转换为数组\n  let args0 = Array.prototype.slice.call(arguments);\n  let args1 = [].slice.call(arguments);\n  // 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)\n  // 注重性能 使用被忽视的Array构造函数作为一个函数\n  let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));\n  console.log('ES6', args0, args1, '遍历对象构造数组', args);\n  // ES6 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] 遍历对象构造数组 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]\n  \n  // ES2015\n  let args3 = Array.from(arguments);\n  let args4 = [...arguments];\n  console.log('ES5', args3, args4);\n  // ES5 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]\n  \n  console.log(typeof arguments); // object\n}\n\nunique(1, 2, 3, 4, ['hello', 'hi', 'go']);\n```\n\n#### eval 函数\n\n计算某个**原始字符串**(不是String对象), 并执行其中的JS代码, 并返回结果(如果不存在, 则返回undefined). 是全局对象的一个函数属性.\n\n```javascript\nlet x = 8;\nlet res = eval('x+2');\nconsole.log(res, eval('4+8')); // 10 12\neval('let a = 10, b = 9; console.log(a*b)'); // 90\nconsole.log(eval()); // undefined\n// 不是字符串的话, 原封不动返回\nconsole.log(eval(67)); // 67\nconsole.log(eval(new String(777))); // [String: '777']\n```\n\n\n\n## 操作符 typeof\n\n### 判断变量数据类型\n\n```javascript\nconsole.log(\n  // 通用数据类型\n\ttypeof 'jinling' + '\\n' +  // string\n\ttypeof 23 + '\\n' + // number\n\ttypeof true + '\\n' +  // boolean\n\ttypeof [1,2,3] + '\\n' + // object\n\ttypeof {k1:'v1', k2:'v2'} + '\\n' // object\n  // 特殊字符类型\n  typeof null + '\\n' + // object\n\ttypeof undefined + '\\n' + // undefined\n\ttypeof NaN + '\\n' // number\n)\n\n// undefined与null值相同,但类型不同\nconsole.log(undefined===null, undefined==null); // false true\n\n// 判断数组可以用 Array.isArray\nconsole.log(Array.isArray([1,2,3])) // true\nconsole.log(Array.isArray({k1:'v1', k2:'v2'})) // false\n```\n\n\n\n\n\n# 对象 Object\n\n使用{}表示, 键必须是字符串.\n\n## 封装\n\n接口与实现分离, 常称为封装. 常见在属性开头加上_表示是私有属性.\n\n## 创建对象\n\n创建一个对象, 定义属性和方法, 不需要 Class.\n\n对象中的方法就是保存函数的属性.\n\n```javascript\nlet animal = {\n  name: 'dog',\n  eat () {\n    console.log(`${this.name} eat meat`);\n  }\n}\nanimal.eat(); // dog eat meat\nanimal.color = 'red';\nconsole.log(animal.color); // red\n```\n\n显式修改方法的调用对象. 使用函数的 `call` 方法, 该方法将 `this` 值作为第一个参数, 其他参数为普通参数. 则此时 `obj` 是 `eat` 方法的调用者, 通过 `call` 进行了显式的调用对象的修改.\n\n```javascript\nlet animal = {\n  name: 'dog',\n  eat (thing) {\n    console.log(`${this.name} eat ${thing}`);\n  }\n}\n\nlet obj = { name: 'monkey' };\n// obj 成为 eat 方法的调用者\nanimal.eat.call(obj, 'carrot'); // monkey eat carrot\n```\n\n## 原型\n\n对象有自己的默认属性集. `Object.getPrototypeOf` 方法返回一个对象的原型.\n\n`Object.prototype` 提供在所有对象中显示的方法, 是最根部的原型.\n\n函数派生自 `Function.prototype`, 数组派生自 `Array.prototype`, 他们具有不同的默认属性集.\n\n```javascript\nlet obj = {}\nconsole.log(obj.toString); // [Function: toString]\nconsole.log(obj.toString()); // [object Object]\n\nlet obj = {}\nconsole.log(obj.__proto__); // {}\n\n// 空对象的原型是 Object.prototype\nconsole.log(Object.getPrototypeOf({}) == Object.prototype); // true\n\n// Object.prototype 原型为 null\nconsole.log(Object.getPrototypeOf(Object.prototype)); // null\n```\n\n### Object.create\n\n使用 `Object.create` 创建具有特定原型的对象.\n\n```javascript\nlet protoDog = {\n  speak(word){\n    console.log(this.name + ' is speaking ' + word);\n  }\n}\n\nlet dog = Object.create(protoDog);\ndog.name = 'doggi'; // dog 对象此时仅包含自身属性 name\n// speak 方法来自原型\ndog.speak('hello'); // doggi is speaking hello\n```\n\n\n\n### __proto\\_\\_ 属性\n\n继承是让两个对象产生关联, 使用 __proto\\_\\_, 这个属性每个对象都有. \n\n```javascript\nlet animal = {\n  name: 'animal',\n  eat () {\n    console.log(`${this.name} eat meat`);\n  }\n}\n\n// 属性覆盖 方法不覆盖\n// 对象 dog 的原型是 animal\nlet dog = {\n  name: 'dog',\n  __proto__: animal // 指向animal对象\n}\n\n// 对象 cat 的原型是 animal\nlet cat = {\n  name: 'cat',\n  __proto__: animal // 指向animal对象\n}\ndog.eat(); // dog eat meat\ncat.eat(); // cat eat meat\n\n// 单纯关联 不做属性或者方法覆盖\nlet dog = {\n  __proto__: animal\n}\nlet cat = {\n  __proto__: animal\n}\nconsole.log(dog.name, cat.name); // animal animal\ndog.eat(); // animal eat meat\ncat.eat(); // animal eat meat\n\n// 方法覆盖 属性不覆盖\nlet dog = {\n  __proto__: animal,\n  eat () {\n    console.log('dog is eating');\n  }\n}\nlet cat = {\n  __proto__: animal,\n  eat () {\n    console.log('cat is eating');\n  }\n}\nconsole.log(dog.name, cat.name); // animal animal\ndog.eat(); // dog is eating\ncat.eat(); // cat is eating\n```\n\n如下所示, 对象 `dog` 和 `cat` 的原型均是 `animal`, 但是均没有定义 `eat` 方法. 在执行 `eat` 方法时, 会到其原型中去寻找, 如果找到则执行, 没有则继续去原型的原型中去寻找, 直至找到或者为`null`. 不断寻找原型的过程依赖于__proto\\_\\_建立的原型链.\n\n可以看出, 尽管执行的是原型中的方法, 但是方法中的`this`仍然指的是调用该方法的上级对象, 由于是`dog`和`cat`这两个对象进行调用的, 所以 this 指向的就是这两个对象而不是 animal.\n\n### 构造函数\n\n但是 JS 也可以通过 `new` 关键字来创建对象, 是给不理解原型链又需要创建对象的程序员使用的.\n\n```javascript\n// 模仿 java 中的 Class 而提供的构造函数\n// Student 的首字母大写\nfunction Student (name) {\n  this.name = name;\n  this.sayHello = function () {\n    console.log('hello ' + this.name);\n  }\n}\n\nlet lily = new Student(\"lily\");\nlet mary = new Student(\"mary\");\n\nlily.sayHello(); // hello lily\nmary.sayHello(); // hello mary\n```\n\n这样有个问题就是, 每个对象都会有一个 `sayHello` 函数, 太重复, 而 java 中函数是定义在 `class` 中的.\n\n### prototype\n\nJS  使用更加高效的方式, 创建一个原型对象 A, 将方法都放在这个原型对象 A 中, 而通过同一个构造函数创建的对象的原型, 都是这个原型对象 A, 这样对象找不到方法时, 就会去其原型即 A 中寻找.\n\n达到这样的效果,  则需要将构造函数与原型对象 A 关联起来, 将 A 赋值给构造函数的 `prototype` 属性, 则 A 就会成为这个构造函数创建的对象的原型.\n\n```javascript\nfunction Student (name) {\n  this.name = name;\n}\n\n// 原型对象\nStudent.prototype = {\n  sayHello () {\n    console.log('hello ' + this.name);\n  }\n}\n\nlet lily = new Student(\"lily\");\nlet mary = new Student(\"mary\");\n\nlily.sayHello(); // hello lily\nmary.sayHello(); // hello mary\n```\n\n### 语法糖 Class\n\n上述语法有点复杂, JS 推出语法糖, 将构造函数与原型对象的函数写在一个 `class` 中.\n\n上述写法等同于下面这种.\n\n```javascript\nclass Student {\n  constructor(name) {\n    this.name = name;\n  }\n  // 构造函数的 prototype\n  // 原型对象\n  // 作为对象的方法, this 指向的是 调用该方法的对象\n  sayHello = () => {\n    console.log('hello ' + this.name);\n  }\n}\n\nlet mary = new Student('mary');\n// mary 对象调用其原型(__proto__)的方法 sayHello\n// 此时方法中的 this 指向 mary 对象\nmary.sayHello(); // hello mary\n```\n\n\n\n## 类 Class\n\n一种语法糖, 特殊的函数, 由**类表达式**和**类声明**组成. 类定义了一种对象的形状, 具有哪些属性与方法. 而这种对象称之为类的实例.\n\nJS 类就是带有 prototype 属性的构造函数. 类中的方法, 都是构造函数原型对象中的方法. 类中的`constructor`方法是实际的构造函数, 并被绑定名称 `Animal`.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  // 目前只支持将函数添加进构造函数原型中 \n  // 不支持其他类型\n  speak () {\n    console.log(this.name + ' is speaking!');\n  }\n}\n```\n\n\n\n### 定义类\n\n1. 类声明 带有`class`关键字\n\n   ```javascript\n   // 类需要先声明 再使用 不像函数声明会提升\n   class hello {\n     constructor(height, width) {\n       this.height = height;\n       this.width = width;\n     }\n   }\n   ```\n\n2. 类表达式 可以具名或者匿名\n\n   ```javascript\n   // 匿名类\n   let hello = class {\n     constructor(height, width) {\n       this.height = height;\n       this.width = width;\n     }\n   }\n   console.log(hello.name); // hello\n   \n   // 具名类\n   let hello = class hello2{\n     constructor(height, width) {\n       this.height = height;\n       this.width = width;\n     }\n   }\n   console.log(hello.name); // hello2\n   ```\n\n3. 传统的基于函数的类\n\n   ```javascript\n   function Animal(name){\n     this.name = name;\n   }\n   \n   Animal.prototype.speak = function () {\n     console.log(this.name + ' makes a noise.');\n   }\n   \n   class Dog extends Animal{\n     speak(){\n       super.speak();\n       console.log(this.name + ' barks.');\n     }\n   }\n   \n   let d = new Dog('cookie')\n   d.speak(); \n   // cookie makes a noise.\n   // cookie barks.\n   ```\n\n\n\n### 类体和方法定义\n\n`constructor` \n\n构造函数, 一种特殊方法, 创建和初始化一个由 `class` 创建的对象. \n\n构造函数可以使用`super`调用父类的构造函数.\n\n### 覆盖派生属性\n\n向对象中添加属性, 属性被添加到对象本身, 原型中的此属性将不再影响该对象.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak () {\n    console.log(this.name + ' is speaking!');\n  }\n}\n\n// 给构造函数的原型对象添加属性\nAnimal.prototype.age = 5;\n\nlet dog = new Animal('dog');\ndog.age = 10; // 覆盖原型属性\nconsole.log(dog.age); // 10\n\nlet cat = new Animal('cat');\nconsole.log(cat.age); // 5\n\nconsole.log(Object.getPrototypeOf(dog).age); // 5\n```\n\n数组原型提供的 `toString` 方法与基本原型对象提供的有所差别, 这样对原型属性的覆盖有利于更通用的对象类中表达异常属性.\n\n```javascript\nconsole.log(Array.prototype.toString == Object.prototype.toString); // false\nconsole.log([1, 2, 3].toString()); // 1,2,3\n\n// Object.prototype.toString 并不知道数组的信息, 只是将 object 与调用对象的类型名称放在[]中\nconsole.log(Object.prototype.toString.call([1, 2]), Object.prototype.toString.call(4)); \n// [object Array] [object Number]\n```\n\n### 多态\n\n对原型方法的覆盖, 以实现实例的特殊化需求. `String` 实际调用的仍然是 `toString` 方法.\n\n```javascript\nlet dog = new Animal('dog');\nconsole.log(String(dog)); // [object Object]\nAnimal.prototype.toString = function () {\n  return 'This is ' + this.name;\n}\nconsole.log(String(dog)); // This is dog\n```\n\n任何支持 `toString` 方法的对象都可以使用它.\n\n**多态**: 多态代码可以支持不同类型的值, 只要这些值支持它指定的接口. 比如 toString 方法, 所有值都支持该接口, 则所有值都能使用该方法.\n\n\n\n### 映射\n\n普通对象派生自 `Object.prototype` , 含有祖先原型的所有属性, 在一些实际场景下, 这些属性可能显得多余. \n\n→ 可以创建没有原型的对象.\n\n```javascript\n// 传递 null 生成的对象不会从 Object.prototype 派生\nconsole.log('toString' in Object.create(null)); // false\nconsole.log('toString' in {}); // true\n```\n\n而且普通对象要求键值必须为字符串.\n\n→ 使用 Map 类, 存储映射并可以使用任何类型的 key.\n\n```javascript\nlet ages = new Map();\nages.set('Bob', 23);\nages.set('Mary', 17);\nconsole.log(ages.get('Bob')); // 23\nconsole.log(ages.has('Mary'), ages.has('toString')); // true false\n```\n\nset get has 是 Map 对象接口的一部分.\n\n\n\n某种情况下,  如果确实需要使用普通对象来作为映射, 则 `Object.keys` 只返回一个**对象自己的键,** 而不包括其原型中的那些属性. \n\n```javascript\nclass Animal{\n  constructor(name){\n    this.name = name;\n    this.age = 18;\n  }\n  speak(){\n    console.log(this.name + 'is speaking');\n  }\n}\n\nlet dog = new Animal('dog');\nconsole.log(Object.keys(dog)); // [ 'name', 'age' ]\n\n// 给原型添加属性\ndog.__proto__.type = 'animal';\n// Object.keys(dog) 仍然只显示自己的属性, 不包括原型中的属性\nconsole.log(Object.keys(dog), Object.keys(dog.__proto__)); // [ 'name', 'age' ] [ 'type' ]\n```\n\n`hasOwnProperty` 方法也只判断某键**是不是该对象自己的**, 没找到也不会去搜索其原型对象. 与关键字 `in` 不同.\n\n```javascript\nconsole.log(dog.hasOwnProperty('name'), dog.hasOwnProperty('speak')); // true false\nconsole.log('name' in dog, 'speak' in dog); // true true\n```\n\n\n\n### extends 创建子类\n\n```javascript\nclass Dog1 extends Animal {\n  constructor(name, sex) {\n    // 调用超类构造函数并传入name参数\n    // 必须先super 然后才能使用this\n    super(name);\n    this.sex = sex;\n  }\n  speak () {\n    console.log(`${this.name} is ${this.sex} and barks`);\n  }\n}\n\nlet d = new Dog1('cookie', 'girl');\nd.speak(); // cookie is girl and barks\n```\n\n### instanceof 运算符\n\n判断一个对象是否来自某一个类.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  // 目前只支持将函数添加进构造函数原型中 \n  // 不支持其他类型\n  speak () {\n    console.log(this.name + ' is speaking!');\n  }\n}\n\nlet dog = new Animal('dog');\nconsole.log(dog instanceof Animal, dog instanceof Object); // true true\n\n// TO DO \nconsole.log(dog instanceof Object.prototype); // TypeError: Right-hand side of 'instanceof' is not callable\n```\n\n\n\n## 静态方法\n\n> 部署在object对象自身的方法\n\n`Object.values` 获取对象的所有key, 输出类型为数组\n\n`Object.keys` 获取对象的所有value, 输出类型为数组\n\n```javascript\nlet obj = {key1:'val1', key2:'val2', key3:'val3'}\nconsole.log(Object.keys(obj)); // [ 'key1', 'key2', 'key3' ]\nconsole.log(Object.values(obj)); // [ 'val1', 'val2', 'val3' ]\n```\n\n`Object.getOwnPropertyNames` 也是返回对象的所有属性名, 但是还会返回不可枚举的属性; 可枚举属性方面, 与`Object.keys`相同\n\n```javascript\n// 不可枚举属性 二者不同\nlet obj1 = ['hello', 'world', 'jinling']\nconsole.log(Object.keys(obj1)); // [ '0', '1', '2' ]\nconsole.log(Object.getOwnPropertyNames(obj1)); // [ '0', '1', '2', 'length' ] 包含不可枚举属性\n\n// 可枚举属性 二者相同\nlet obj = {key1:'val1', key2:'val2', key3:'val3'}\nconsole.log(Object.keys(obj)); // [ 'key1', 'key2', 'key3' ]\nconsole.log(Object.getOwnPropertyNames(obj)); // [ 'key1', 'key2', 'key3' ]\n```\n\n\n\n## 实例方法\n\n`Object.hasOwnProperty `判断对象是否拥有某项属性\n\n```javascript\nlet obj = {key1:'val1', key2:'val2', key3:'val3'}\nconsole.log(obj.hasOwnProperty('key2')); // true\n```\n\n\n\n\n\n# 函数式编程\n\n摩尔定律失效, 多核时代来临, 函数式编程能够很好地为并发编程服务, 具有 没有 side effect/ 不共享变量/安全调度到任何一个CPU core 上运行/没有加锁问题...等诸多优点.\n\n## 纯函数\n\n1. 对于相同的输入, 永远有相同的输出. 没有可观察的副作用, 不依赖外部条件.\n2. 不能修改传递给函数的参数\n3. 不能修改全局变量\n\n比如数组操作中, 对于给定的数组, slice就是纯的, splice就是不纯的.\n\n纯函数可以有效降低系统复杂性, 还有很多其他的优秀特性, 例如可缓存性.\n\n```javascript\nimport _ from 'lodash';\nvar sin = _.memorize(x => Math.sin(x));\n\n//第一次计算的时候会稍慢一点\nvar a = sin(1);\n\n//第二次有了缓存，速度极快\nvar b = sin(1);\n```\n\n## 使用递归而非迭代\n\n使用尾递归, 保证不溢出.\n\n```javascript\n// 迭代不被允许\nlet arr = [1,2,3,4];\nlet result = 0; // result 不能改变\nfor(let i of arr){\n  result += i; // i 不能改变\n}\nconsole.log(result); // 10\n\n// 递归\nvar first = arr => arr[0]\nvar rest = arr => arr.slice(1)\nvar sum = (arr, res) => {\n  if (arr.length == 0) return res;\n  else return sum(rest(arr), res + first(arr));\n}\nlet arr = [1, 2, 3, 4];\nconsole.log(sum(arr, 0)); // 10\n```\n\n## 高阶函数\n\n很多函数大体相同, 重复代码很多, 只有一些细节不一样, 于是产生高阶函数.\n\n高阶函数: 让函数来产生函数, 共用的部分抽取出来, 不共用的部分与共用的部分能组合起来.\n\n比如 JS 中的 `map/filter/forEach/...` 函数都是高阶函数, 能快速操作集合数据.\n\n### 函数的柯里化\n\ncurry: 传递给函数一部分的参数来调用它, 让他返回一个函数去处理剩下的参数.\n\n就是传递一部分的参数, 形成固定模式的函数(部分参数数值已经固定), 得到已经记住参数的新函数. 这样对应固定的输入, 就得到固定的输出.\n\n```javascript\nvar check = x => (y => y > x);\nlet check7 = check(7);\nconsole.log(check7(10)); // true\n```\n\n### 函数组合\n\n包菜式代码  `h(g(f(x)))` => 更优雅 函数组合\n\n```javascript\n// 传的是g函数需要的参数\n// 将任何两个纯函数结合在一起, 组合函数式的代码\nvar compose = (f, g) => (x => f(g(x)));\n\nvar add1 = x => x + 1;\nvar mul5 = x => x * 5;\n\nlet res = compose(add1, mul5);\nconsole.log(res(2)); // 11\n\n\nvar first = arr => arr[0];\nvar reverse = arr => arr.reverse();\n\nvar last = compose(first, reverse);\nconsole.log(last([1, 2, 3, 4, 5])); // 5\n```\n\n## 惰性求值\n\n待补充\n\n## 宏(macro)\n\n待补充\n\n## Point Free\n\n减少对不必要的中间变量的命名\n\n## 声明式与命令式代码\n\n**命令式**: 写出一条一条指令让计算机执行, 一般会涉及到很多繁琐的细节. **既说做什么, 也说怎么做**.\n\n**声明式**: 写表达式表明自己想做的事情, 而不是一步一步的指示. 隐藏细节.  **只说做什么, 不说怎么做**.\n\n```javascript\n//命令式\nvar CEOs = [];\nfor(var i = 0; i < companies.length; i++){\n    CEOs.push(companies[i].CEO)\n}\n\n//声明式\nvar CEOs = companies.map(c => c.CEO);\n```\n\n函数式编程一个优点就是声明式代码以及纯函数. 工作时专注于业务代码, 优化时专注于函数内部. 还有其他的特点, 比如高阶函数/函数没有side effect/只有值没有变量/用递归而不是用迭代等.\n\n\n\n# 遍历器与 for...of\n\n## 遍历器概念\n\n是用来处理可遍历数据结构的统一接口, 只要部署 `iterator` 接口, 就可以进行遍历操作.\n\n作用: 提供统一的访问接口/数据结构的成员按照某种顺序排列/为ES6新增的`for...of`服务\n\n数据结构有遍历器接口, 就称为该数据结构是可遍历的/可迭代的.\n\n## JS 默认遍历器接口 \n\nJS中默认的遍历器接口, 即数据结构的原型对象有 `Symbol.iterator` 属性, 该属性对应的函数返回一个遍历器对象, 调用对象的`next`方法, 即可返回数据结构的下一个数据..\n\n```javascript\nlet arr = [3, 4, 5];\nlet it = arr[Symbol.iterator]();\nconsole.log(it.next(), it.next(), it.next(), it.next());\n// { value: 3, done: false } { value: 4, done: false } { value: 5, done: false } { value: undefined, done: true }\n// done 表示是否遍历结束\n```\n\n原生具备 Iterator 接口的数据结构如下。\n\n- Array\n\n- Map\n\n- Set\n\n- String\n\n- TypedArray\n\n- 函数的 arguments 对象\n\n- NodeList 对象\n\n上述数据结构不用自己写遍历器函数, `for...of`循环会自动进行遍历.\n\n```javascript\nlet arr = [3, 4, 5];\nfor(let i of arr) console.log(i);\n// 3\n// 4\n// 5\n```\n\n没有遍历器函数的数据结构, 可以根据实际需求进行手动部署, 即在`Symbol.iterator`属性上手写遍历器对象生成函数.\n\n\n\n# 解构赋值\n\n针对数组或者对象进行模式匹配, 然后对其中的变量进行赋值. 解构目标 = 解构源.\n\n## 数组的解构\n\n```javascript\n// 基本\nlet [a, b, c] = [1, 2, 3];\nconsole.log(a, b, c); // 1 2 3\n\n// 嵌套\nlet [a, [[b], c]] = [1, [[2], 3]];\nconsole.log(a, b, c); // 1 2 3\n\n// 可忽略\nlet [a, , c] = [1, 2, 3];\nconsole.log(a, c); // 1 3\n\n// 剩余运算符\nlet [a, ...b] = [1, 2, 3];\nconsole.log(a, b); // 1 [2, 3]\n```\n\n数组解构中, 若解构目标为可遍历对象(实现iterator接口的数据), 都可以进行解构赋值.\n\n```javascript\n// 字符串\nlet [a, b, c, ...d] = 'hello';\nconsole.log(a, b, c, d); // h e l [ 'l', 'o' ]\n```\n\n### 解构默认值\n\n解构匹配到`undefined`, 触发默认值作为返回结果.\n\n```javascript\n// 均匹配到 undefined\nlet [a = 2] = [undefined]; console.log(a); // 2\nlet [a = 3, b = a] = []; console.log(a, b); // 3 3\n// b 匹配到 undefined, 触发默认值 b=a=1\nlet [a = 3, b = a] = [1]; console.log(a, b); // 1 1\n// 正常解构赋值\nlet [a = 3, b = a] = [1, 9]; console.log(a, b); // 1 9\n```\n\n\n\n## 对象的解构\n\n\n\n```javascript\n// 报错\nlet { a, b } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(a, b); // undefined undefined\n// 报错\nlet { a: b } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(a, b); // ReferenceError: a is not defined\n// 报错\nlet { a } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(a); // undefined\n\n/* 正确使用 解构目标必须与key一致 */\n\nlet { hello, apple } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(hello, apple); // aaa bbb\n\nlet { hello: b } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(b); // aaa\n\nlet { hello } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(hello); // aaa\n\n/* 剩余运算符 */\n\nlet { a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 };\nconsole.log(a, b, rest); // 10 20 { c: 30, d: 40 }\n\n/* 解构默认值 */\n\nlet { hello = 3, apple = 5 } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(hello, apple); // aaa bbb\n\n// apple 匹配到 undefined\nlet { hello = 3, apple = 5 } = { hello: 'aaa'};\nconsole.log(hello, apple); // aaa 5\n\nlet { hello: aa = 3, apple: bb = 5 } = {};\nconsole.log(aa, bb); // 3 5\n\nlet { hello: aa = 3, apple: bb = 5 } = { apple: 'aaa' };\nconsole.log(aa, bb); // 3 aaa\n```\n\n\n\n\n\n#  关键字 this\n\njs中`this`随着执行环境的变化而变化, 是函数运行时, 在函数体内部自动生成的一个对象, 只能在函数体内部使用. 即, **this 是函数运行时所在的环境对象**. 箭头函数不绑定自己的 `this` .\n\n## 单独使用\n\n无论有无严格模式, `this`始终指向全局对象. 浏览器中, 全局对象为`[object Window]`\n\n```javascript\n// 'use strict'\nconsole.log(this); // {}\n```\n\n## 纯粹的函数调用\n\n函数中, 默认`this`指向全局对象\n\n```javascript\nvar name = \"ok\";\nfunction test() {\n  console.log(this.name);\n}\ntest(); // ok\n\n\nlet fun = ()=>{\n\treturn this;\n}\nconsole.log(fun()); // {}\n```\n\n严格模式下不允许默认绑定, 所以函数中的`this`为`undefined`\n\n```javascript\n// 严格模式\n\"use strict\"\nfunction myFunction() {\n  return this;\n}\nconsole.log(myFunction()); // undefined\n```\n\n## 函数作为对象方法\n\n指向上级对象\n\n```javascript\nlet obj = {\n\tsize : 14,\n\tcolor: 'red',\n\tgetColor: function () {\n\t\treturn '颜色是' + this.color\n\t}\n}\n// 该实例中, this指向getColor方法所在的对象\nconsole.log(obj.getColor) // [Function: getColor]\nconsole.log(obj.getColor()) // 颜色是red (加括号表示调用方法)\n\n// 方法中的this单独打印, 会打印出所属对象的内容\nvar person = {\n  firstName  : \"John\",\n  lastName   : \"Doe\",\n  id         : 5566,\n  myFunction : function() {\n    return this;\n  }\n};\nconsole.log(person.myFunction()); \n\n/*\n{\n  firstName: 'John',\n  lastName: 'Doe',\n  id: 5566,\n  myFunction: [Function: myFunction]\n}\n*/\n```\n\n### 类方法中的 `this` 指向\n\n`speak` 方法中的 `this` 从打印结果来看, 指的是**构造函数生成的新对象**, 并未打印`speak`方法.\n\n但是 `this.speak` 却能够调用, 说明`this`不仅指向的是构造函数对应的对象, 而且在行为上也与构造函数的对象一致, 就是对象中找不到方法, 就去对象的原型中去找.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak () {\n    console.log(this.speak, this);\n  }\n}\n\nlet dog = new Animal();\n// 此时 speak 中的this指的是它的调用对象, 也就是 dog\n// speak 在打印 this.speak 时, 相当于打印 dog.speak, 但是 dog 本身是没有 speak 函数的\n// 只能去 dog 原型对象里去找, 最后找到了 speak 函数, 其实打印的是 dog 原型的 speak 函数\ndog.speak();\n// [Function: speak] Animal { name: undefined }\n\n\n// eat 中的 this 与 speak 中的 this 一样\n// 均是指构造函数对应的对象\nAnimal.prototype.eat = function () {\n  console.log(this);\n}\n\n// 下面 eat 在执行时, 均是指向调用 eat 方法的类的实例\n// 即 panda 和 cat\nlet panda = new Animal('panda');\npanda.eat(); // Animal { name: 'panda' }\nlet cat = new Animal('cat');\ncat.eat(); // Animal { name: 'cat' }\n```\n\n\n\n## 函数作为构造函数\n\n构造函数就是, 通过这个函数, 能够生成一个新对象. 此时, `this` 指向这个新对象.\n\n```javascript\nfunction test() {\n  this.x = 'hello';\n}\n\nvar obj = new test();\nconsole.log(obj.x); // hello\n\n\nvar x = \"ok\";\nfunction test() {\n  this.x = 'hello';\n}\n\nvar obj = new test();\nconsole.log(x); // ok 此时全局变量x的值没有变化, 说明 this 不是全局对象\n```\n\n## apply 调用\n\n`apply()`是函数的一个方法, 作用是改变函数的调用对象. 第一个参数表示改变后的调用这个函数的对象, 此时 `this` 指向这个参数.\n\n```javascript\nvar x = \"ok\";\n\nfunction test() {\n  console.log(this.x);\n}\n\nvar obj = {};\nobj.x = 'hi';\nobj.method= test;\n\n// 参数为空时, 默认 obj.method 这个方法的调用者修改为 全局对象.\nobj.method.apply(); // o.apply(); // ok\n\n// 修改 obj.method 这个方法的调用者为 obj, 则此时 obj.method 作为对象方法被调用\n// this 指向 obj\nobj.method.apply(obj); // hi\n```\n\n\n\n# 模块化\n\n## 概述\n\nES6之前使用 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。\n\nES6 引入了模块化，在编译时就能确定模块的依赖关系 + 输入和输出的变量。\n\nES6 的模块化 = 导出（export） 与导入（import）两个模块。\n\n## 特点\n\n自动开启严格模式\n\n模块中可以导入导出各种类型的变量, 如函数/对象/字符串/布尔值/类等.\n\n每个模块都有自己的上下文, 模块内声明的变量都是局部变量.\n\n每个模块只加载一次, 再去加载该模块, 则直接从内存中读取.\n\n## 用法\n\n导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 \n\nexport 命令可以出现在模块的任何位置，但必需处于模块顶层。\n\nimport 命令会提升到整个模块的头部，首先执行。\n\n### 基本用法\n\n```javascript\n/*-----export [test.js]-----*/\nlet myName = \"Tom\";\nlet myAge = 20;\nlet myfn = function(){\n    return \"My name is\" + myName + \"! I'm '\" + myAge + \"years old.\"\n}\nlet myClass =  class myClass {\n    static a = \"yeah!\";\n}\nexport { myName, myAge, myfn, myClass }\n// 建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口\n// 函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称\n\n/*-----import [xxx.js]-----*/\nimport { myName, myAge, myfn, myClass } from \"./test.js\";\nconsole.log(myfn());// My name is Tom! I'm 20 years old.\nconsole.log(myAge);// 20\nconsole.log(myName);// Tom\nconsole.log(myClass.a );// yeah!\n```\n\n### as 的用法\n\n```javascript\n/*-----export [test.js]-----*/\nlet myName = \"Tom\";\nexport { myName as exportName }\n \n/*-----import [xxx.js]-----*/\nimport { exportName } from \"./test.js\";\nconsole.log(exportName);// Tom\n// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量\n\n/*-----export [test1.js]-----*/\nlet myName = \"Tom\";\nexport { myName }\n\n/*-----export [test2.js]-----*/\nlet myName = \"Jerry\";\nexport { myName }\n\n/*-----import [xxx.js]-----*/\n// 不同模块导出接口名称命名重复， 使用 as 重新定义变量名。\nimport { myName as name1 } from \"./test1.js\";\nimport { myName as name2 } from \"./test2.js\";\nconsole.log(name1);// Tom\nconsole.log(name2);// Jerry\n```\n\n### import 命令的特点\n\n#### 只读属性\n\n#### 单例模式\n\n```javascript\nimport { a } \"./xxx.js\";\nimport { a } \"./xxx.js\";\n// 相当于 import { a } \"./xxx.js\"; 只执行一次\n \nimport { a } from \"./xxx.js\";\nimport { b } from \"./xxx.js\";\n// 相当于 import { a, b } from \"./xxx.js\"; 只执行一次\n```\n\n#### 静态执行特性\n\n`import` 静态执行, 不能使用表达式和变量.\n\n```javascript\nimport { \"f\" + \"oo\" } from \"methods\";\n// 表达式 error\n\nlet module = \"methods\";\nimport { foo } from module;\n// 变量 error\n\nif (true) {\n  import { foo } from \"method1\";\n} else {\n  import { foo } from \"method2\";\n}\n// error\n```\n\n### export default 命令\n\n在一个文件或者模块中, export/import可以有多个, export default 仅有一个。\n\n导出时不需要加{}\n\n```javascript\nvar a = \"My name is Tom!\";\nexport default a; // 仅有一个 不需要加{}\nexport default var c = \"error\"; \n// error，default 已经是对应的导出变量，不能跟着变量声明语句\n \nimport b from \"./xxx.js\"; // 不需要加{}， 使用任意变量接收\n```\n\n\n\n# 最佳实践\n\n1. 避免使用 全局变量 `new` `===` `eval()`\n\n2. 所有声明放在脚本或者函数的顶部, **顶部声明, 稍后使用**\n\n   ```javascript\n   // 在顶部声明\n   var firstName, lastName, price, discount, fullPrice;\n   \n   // 稍后使用\n   firstName = \"Bill\";\n   lastName = \"Gates\";\n   \n   price = 19.90;\n   discount = 0.10;\n   \n   fullPrice = price * 100 / discount;\n   ```\n\n3. 声明变量时同时初始化\n\n4. 将数值/字符串/布尔值声明为原始值而非对象, 否则会拖慢速度\n\n   ```javascript\n   let x = 'bill' // 字符串\n   let y = new String('bill') // 对象\n   console.log(x===y); // false\n   ```\n\n5. 请勿使用 new Object()\n\n|   推荐使用    |     不建议     |\n| :-----------: | :------------: |\n|      {}       |  new Object()  |\n|      []       |  new Array()   |\n| function (){} | new Function() |\n|      \"\"       |  new String()  |\n|       0       |  new Number()  |\n|     false     | new Boolean()  |\n|     /()/      |  new RegExp()  |\n\n6. 意识到自动类型转换, 变量可以通过赋值改变其数据类型, 变量可包含不同的数据类型.\n\n   ```javascript\n   let a = 'hello'\n   a = 5;\n   console.log(typeof a); // number\n   ```\n\n7. 为函数中的参数设置默认值, `undefined` 会破坏代码\n\n8. 用`default`来结束`switch`.\n\n\n\n# 缺陷与错误\n\n## 错误处理\n\n> 原因\n\njs代码中会出现错误, 由于编写代码/编译/用户输入等各种各样的原因.\n\n> 处理\n\n发生错误时, js引擎会停止并生成一个错误消息.\n\ntry与catch成对出现, finally是最后一定会执行的语句(可以没有).\n\nthrow抛出错误, 实际上就是抛出一个表示错误信息的字符串s, 因此可以自定义错误.\n\n在catch中可以捕获s,实际上就是可以获得s的值并打印出来.\n\n```javascript\ntest = (x) => {\n  try {\n    if (x === '') throw 'is kong'\n    if (x === '1') throw 'is 1'\n    if (x === '2') throw 'is 2'\n  } catch (error) {\n  \tconsole.log(error);\n  }\n}\ntest('1'); // is 1\ntest(''); // is kong\n```\n\n\n\n## 调试\n\n> 操作\n\n设置断点, 检查变量值, 浏览器内置调试器(按下F12, 选择`console`)\n\n> `debugger`关键字\n\n代码会在`debugger`行停下, 并执行调试函数. 没有调试函数则不起作用.\n\n与在调试工具中设置断点效果一样.\n\n\n\n## 严格模式\n\n> 原因\n\n`use strict` \n\n消除js语法的不合理之处, 保证代码安全; 增加编译效率;\n\n> 使用\n\n只能放在脚本或者函数的开头\n\n> 具体内容\n\n- 禁止使用未定义/声明的变量\n- 禁止删除变量/函数\n- 禁止变量重名\n- 禁止使用八进制/转义字符\n- 禁止对只读属性赋值\n- 禁止删除不能删除的属性, 比如prototype\n- 禁止变量名为eval/arguments\n- 禁止使用右侧类似语句 with (Math){x = cos(2)};\n- 禁止在作用域eval创建的变量被使用\n- 禁止this指向全局对象\n\n\n\n","source":"_posts/JavaScript-Notes.md","raw":"---\ntitle: JavaScript Notes\ntags: '-JavaScript'\nabbrlink: 11485\ndate: 2020-09-01 09:17:06\n---\n\n\n\n# JavaScript 简介\n\n## 诞生\n\n本名 ECMAScript, 被创建的原因是, 在浏览器输入数据时需要进行验证, 而不是传到服务器才告知客户数据错误或者空白等, 于是被创建时诞生在 NetScape 浏览器中.  \n\n## 特点\n\n只能在浏览器中运行, 不能单独运行, 不能读取文件\n\n由浏览器中的执行模块(JS引擎)执行, 考虑到页面打开的速度, 不编译执行.\n\n## 功能\n\n### 操作HTML的DOM\n\n浏览器从服务器取到HTML页面之后, 会展示页面出来, 但是浏览器内部将HTML组织成一个树给JS, 这个树称为 DOM.\n\n![htmltree](JavaScript-Notes/htmltree.jpg)\n\nJS可以定位并操作DOM中的任意一个节点, 且不用刷新页面, 操作就可以立刻显示出效果. 而且操作是内部进行, 并没有改变 html的源码.\n\n### 控制浏览器\n\n打开窗口/在一个窗口内前进后退/获得浏览器名称+版本(判断是什么浏览器, 才能做这个浏览器支持的特殊操作)...\n\n### 异步调用\n\n不能像java一样访问网络, 就不能调用服务器的接口去获取数据. 用户只能get或者post向服务器发送请求, 服务器返回整个页面, 而不是一个片段, 整个页面得重新刷新.\n\n`XMLHttpRequest` 使得 JS 可以直接向服务器发起接口调用, 等获得服务器返回的数据(此时为`XML`)后执行浏览器提供的回调函数. Called 异步调用. 回调函数基本就是更新DOM树的某个节点, 实现网页的局部刷新. 后来上述的异步调用被称为 `AJAX` (Asynchronous JavaScript And XML).\n\n由于`XML`的标签太多, 真正数据很少, 而且需要XML解析器进行解析, 后来 `JS` 和服务器之间的数据传输使用 `JSON` 这种更简洁的格式.\n\nHTML 结构, CSS 展示, JS(AJAX JSON) 逻辑 = 前端. 可以在浏览器实现 `MVC`.\n\n 后来出现了多种框架, ExtJS/prototype/JQuery/AngularJS将前端推向另一个高峰. \n\n\n\n## JS 移动到服务器端\n\n需要满足下述两个要求:\n\n1. 引擎移动到服务器端, 需要执行地足够快. Chrome V8\n\n2. 绕开 JAVA 服务器的问题, 即线程遇到IO/数据库/网络这样的耗时操作, 不能等待, 换成异步处理.\n\n即后来出现的 node.js, 巨大优势就是: 前后端均使用JS开发.\n\n### Node.js 工作特点\n\n**只用一个线程来处理所有请求, 事件驱动编程.**\n\n需要等待的操作, 会有一个回调函数在那, 线程不会等待. 操作一完成则发出事件通知线程, 线程立马回来执行对应的回调函数, 执行完回调函数再去接着执行那些不需要等待的操作.\n\n即: 需要等待的操作先跳过, 先去执行那些不需要等待的操作, 耗时操作完成后事件通知线程后, 线程再立即回来执行其对应的回调函数. 事件驱动编程, 有需要处理的事件才去处理, 耗时操作先跳过.\n\n<!--more-->\n\n# 数据类型\n\n\n\n## 值类型\n\n### * 布尔值 Boolean\n\ntrue/false\n\n\n\n### * 字符串 String\n\n#### 创建\n\n```javascript\nlet s1 = 'hello'; // 字面量创建\nlet thing = 98; // 任何可以转换成字符串的值\n/* String 函数 生成或者将值转换为字符串 */\nlet s2 = String(thing); // 将thing转换为原始字符串\nlet s3 = new String(thing); // 新建String对象, 并存储thing的字符串表示\nconsole.log(s1, typeof s1); // hello string\nconsole.log(s2, typeof s2); // 98 string\nconsole.log(s3, typeof s3); // [String: '98'] object\n```\n\n字符串一旦创建, 其内容不可被修改, 只能重新被赋值.\n\n```javascript\nlet str = \"hello\";\nstr[1] = '*';\nconsole.log(str, str[1]); // hello e\nstr = \"world\";\nconsole.log(str); // world\n```\n\n\n\n#### 属性\n\n`length`\n\n字符串长度\n\n```javascript\nlet s = 'hello';\nconsole.log(s.length); // 5\n```\n\n`constructor`\n\n对创建该对象的函数的引用\n\n```javascript\nlet s = 'hello';\nconsole.log(s.constructor); // [Function: String]\n```\n\n\n\n#### 方法\n\n##### 处理\n\n`toUpperCase`  \n\n字符串变大写\n\n`toLowerCase `  \n\n字符串变小写\n\n```javascript\nlet s = 'hello', t = 'JINLING';\nconsole.log(s.toUpperCase(), s); // HELLO hello\nconsole.log(t.toLowerCase(), t); // jinling JINLING\n```\n\n`trim`\n\n去除字符串两边的空白. 原字符串未改变.\n\n```javascript\nlet str = \"   hello   *   \";\nconsole.log(str.trim(), ', |' + str + '|'); // hello   * , |   hello   *   |\n```\n\n`split` \n\n根据分隔符将字符串分割为数组\n\n```javascript\nlet s = 'hel,l,o';\n// 不切割 整个字符串视作数组的一个元素\nconsole.log(s.split());  // [ 'hel,l,o' ]\n// 每个字符都是数组中的元素\nconsole.log(s.split(''));\n/* \n[\n 'h', 'e', 'l',\n ',', 'l', ',',\n 'o'\n]\n*/\n// 以逗号分割\nconsole.log(s.split(','), s); // [ 'hel', 'l', 'o' ] hel,l,o\n```\n\n##### 查找\n\n`indexOf`\n\n查找字符串中有无指定字符串, 有则返回下标, 没有则返回-1\n\n```javascript\nlet s = \"hello jinling!\"\nlet res1  = s.indexOf(\"hi\");\nlet res2  = s.indexOf(\"jin\");\nconsole.log(res1, res2); // -1 6\n```\n\n`includes`\n\n查找字符串是否包含指定子串, 有则返回`true`, 反之`false`.\n\n```javascript\nlet str = \"hello jinling good\";\nconsole.log(str.includes(\"hello\"), str.includes(\"world\")); // true false\n```\n\n`charAt`\n\n返回字符串中对应下标的字符\n\n```javascript\nlet s = \"hello*jinling!\"\nlet ch = s.charAt(5);\nconsole.log(ch); // *\n```\n\n##### 拼接/截取\n\n`concat`\n\n拼接两个或者更多字符串, 返回新字符串, 不改变原字符串.\n\n```javascript\nlet s1 = \"hello\", s2 = \"*go\", s3 = \"*hhh\";\nlet s = s1.concat(s2, s3);\nconsole.log(s, s1, s2, s3) // hello*go*hhh hello *go *hhh\n```\n\n`slice`\n\n截取字符串的片段, 不改变原字符串.\n\n```javascript\nlet str = \"helloWorld\";\nlet s = str.slice(3, 7); // [起始位置, 结束位置)\nconsole.log(s, str); // loWo helloWorld\n```\n\n`substring`\n\n截取字符串的片段, 不改变原字符串.\n\n```javascript\nlet s = 'helloWorld';\n // [起始位置, 结束位置)\nconsole.log(s.substring(1, 8), s); // elloWor helloWorld\n```\n\n`substr`\n\n截取指定长度的子串. (ps. ECMAscript 没有对该方法进行标准化，因此反对使用它。)\n\n```javascript\nlet s = 'helloWorld';\n// 起始位置 截取长度\nconsole.log(s.substr(1, 4), s); // ello helloWorld\n```\n\n\n\n### * 数字 Number\n\n数字可以是数字或者对象, Number 对象是原始数值的包装对象. JS只有一种数字类型.\n\n#### 创建\n\n```javascript\n/* 基础类型创建 */\nlet k = 5;\nconsole.log(typeof k); // number\n// 科学计数法\nlet t = 123e5, k = 123e-5;\nconsole.log(typeof t, t, typeof k, k); // number 12300000 number 0.00123\n// 八进制以0开头\nlet n = 0122; // 数字以 0 开头, 且后面的数字都比8小, 则js解释为八进制\nconsole.log(n); // 82\nlet n = 0888; // 后面数字>=8, 则依然解释为十进制\nconsole.log(n); // 888\n// 十六进制以0x开头\nlet n = 0x11;\nconsole.log(n); // 17\n\n/* 对象形式创建 */\nlet m = new Number(\"99\"), n = new Number(10);\nconsole.log(typeof m, m, typeof n, n); \n// object [Number: 99] object [Number: 10]\n\nlet t = new Number(\"kill\"); // 不能转换为数字时\nconsole.log(typeof t, t); // object [Number: NaN]\n```\n\n#### 属性\n\n返回对创建此对象的 Number 函数的引用.\n\n```javascript\nlet a = 8;\nconsole.log(a.constructor); // [Function: Number]\n```\n\n\n\n#### 方法\n\n`toString`\n\n将数字转变为字符串, 使用指定的基数.\n\n```javascript\nlet t = new Number(\"99\");\nlet str = t.toString();\nconsole.log(typeof str, str); // string 99\n\n// 使用指定的基数\nlet t = new Number(\"10\");\nlet str = t.toString(2); // 十进制转变为二进制\nconsole.log(typeof str, str); // 1010\n\nlet t = new Number(\"10\");\nlet str = t.toString(8); // 十进制转变为八进制\nconsole.log(typeof str, str); string 12\n```\n\n`valueOf`\n\n返回一个 Number 对象的基本数字值.\n\n```javascript\nlet t = new Number(\"99\");\nconsole.log(t.valueOf()); // 99\n```\n\n`isFinite`\n\n判断参数是否为无穷大\n\n```javascript\nNumber.isFinite(123) // true\nNumber.isFinite(-1.23) // true\nNumber.isFinite(5-2) // true\nNumber.isFinite(0) // true\nNumber.isFinite('123') // false\nNumber.isFinite('Hello') // false\nNumber.isFinite('2005/12/12') // false\nNumber.isFinite(Infinity) // false\nNumber.isFinite(-Infinity) // false\nNumber.isFinite(0 / 0) // false\nNumber.isFinite(NaN) // false\n```\n\n`isNaN`\n\n使用全局函数判断`NaN`(教程推荐).\n\n```javascript\nlet a = NaN;\nconsole.log(isNaN(a), isNaN(8), isNaN(\"11\")); // true false false\n```\n\n\n\n### * Symbol (ES6)\n\n基本数据类型, ES6新增, 表示独一无二的值. 由于 ES5 对象的属性名只能是字符串, 容易造成属性名的冲突, 需要独一无二的值.\n\n具有静态属性与静态方法. 模拟对象私有属性.\n\n#### 概述\n\n通过`Symbol`函数产生.\n\n```javascript\n// 接受字符串作为参数, 表示对Synbol实例的描述, 主要为了在控制台显示或者转为字符串时容易被区分.\nSymbol(**description?: string | number**): symbol\n\nDescription of the new Symbol object.\n\nReturns a new unique Symbol value.\n```\n\n每个从 Symbol 返回的symbol值都是唯一的, 尽管参数相同.\n\n```javascript\nlet sym = Symbol();\nlet sym1 = Symbol(34); \n// Symbol 不会将'hello'转变为symbol类型, 每次创建一个新的symbol类型.\nlet sym2 = Symbol('hello'); \nlet sym3 = Symbol('hello'); \n\nconsole.log(typeof sym, sym); // symbol Symbol()\nconsole.log(sym1 == 34); // false\nconsole.log(sym2 == 'hello', sym2, sym2.toString()); // false Symbol(hello) 'Symbol(hello)'\nconsole.log(sym2 === sym3); // false\n```\n\n`Symbol`可以转换为**字符串**以及**布尔值**, 但是不能转换为数值.\n\n```javascript\nlet s1 = Symbol('happy');\nconsole.log(s1.toString(), String(s1)); // Symbol(happy) Symbol(happy)\n\nlet s1 = Symbol('happy');\nconsole.log(Boolean(s1)); // true\n\nlet s1 = Symbol('happy');\nconsole.log(Number(s1)); // TypeError: Cannot convert a Symbol value to a number\n```\n\n对原始数据类型创建一个显式包装器对象从ES6开始不再被支持, 但是原有的 new Boolean/new String/new Number 由于遗留原因仍然可以被创建.\n\n如果真的想创建一个Symbol包装器, 可以使用Object()函数.\n\n```javascript\n// symbol 是原始数据类型 不是对象\nlet s = new Symbol(); // TypeError: Symbol is not a constructor\n\nlet sym = Symbol(34); \nconsole.log(typeof sym); // symbol\nlet symObj = Object(sym);\nconsole.log(typeof symObj); // object\n```\n\n#### 作为属性名\n\n```javascript\nlet mySymbol = Symbol();\n\n// 第一种写法\nlet obj = {};\nobj[mySymbol] = 'hello';\n\n// 第二种写法\nlet obj = {\n  [mySymbol]: 'hello'\n}\n\n// 第三种写法\nlet obj = {};\n// 将对象的属性名指定为一个 Symbol 值\nObject.defineProperty(obj, mySymbol, { value: 'hello' });\n\n// 三种写法 同样结果\nobj[mySymbol] // 'hello'\n```\n\n`Symbol` 作为对象属性时, 不能使用点运算符, 只能使用方框`[]`.\n\n```javascript\nlet mySymbol = Symbol();\n\nlet obj = {};\nobj[mySymbol] = 'hello';\nobj.mySymbol = 'hi'; // 相当于属性名为 'mySymbol' 字符串\nconsole.log(obj.mySymbol); // hi\nconsole.log(obj[mySymbol]); // hello\n\n// 作为对象属性, 只能使用方框\nlet obj = {\n  [s]: function (arg) { ... }\n}\n\n// 增强的对象写法\nlet obj = {\n  [s] (arg) { ... }\n}\n```\n\n\n\n### * null\n\n`null` : 表示主动释放指向对象的引用.\n\n```javascript\nlet a = [1,2]\na = null;\nconsole.log(a); // 释放指向数组的引用\n```\n\n设计之初, `null` 像在java里一样, 被当成一个**对象**.\n\n```javascript\nconsole.log(typeof null); // object\n```\n\n可以自动转为 0 \n\n```javascript\nconsole.log(Number(null), 8 + null); // 0 8\n```\n\n**用法: null 表示\"没有对象\", 即 该处不应该有值.**\n\n1. 作为函数的参数, 表示该函数的参数不是对象\n2. 作为对象原型链的终点\n\n```javascript\nconsole.log(Object.getPrototypeOf(Object.prototype)); // null\n```\n\n\n\n### * undefined\n\nBrendan Eich 觉得, 表示'无'的值, 最好不是对象. 其次, 由于js初版本没有错误处理机制, null 自动转为 0 不容易发现错误. 于是 Brendan Eich又设计了一个`undefined`.\n\n一开始 `undefined` 被设计为表示'无'的原始值, 转为数字时为 NaN\n\n```javascript\nconsole.log(Number(undefined), 8 + undefined); // NaN NaN\n```\n\n**用法: undefined 表示\"缺少值\", 就是此处应该有一个值, 但是还没有定义.**\n\n1. 变量被声明过, 但是没有赋值, 等于 undefined\n2. 调用函数时, 应该提供的参数没有提供, 则该参数为 undefined\n3. 对象没有赋值的属性, 该属性值为 undefined\n4. 函数没有返回值时, 默认返回 undefined.\n\n```javascript\n// 用法 1\nvar a;\nlet b;\nconsole.log(a,b); // undefined undefined\n\n// 用法 2\nlet test = (a) => {\n  console.log(a);\n}\ntest(); // undefined\n\n// 用法 3\nlet obj = {}\nconsole.log(obj.a); // undefined\n\n// 用法 4\nlet test = () => { }\nconsole.log(test()); // undefined\n```\n\n\n\n#### undefined 与 null 区别\n\n两者使用 == 时为true, === 时为false.\n\n```javascript\nconsole.log(undefined == null, undefined === null);\n// true false\n\n// 在if语句中, 两者都被转成 false\nif (!undefined) console.log('undefined if false'); // undefined if false\nif (!null) console.log('null if false'); // null if false\n```\n\n\n\n## 引用类型\n\n\n\n### * 数组 Array\n\n#### 创建\n\n```javascript\nlet arr0 = []; // 字面\nlet arr1 = new Array(); // 不固定长度\nlet arr2 = new Array(5); // 固定长度\nlet arr3 = new Array(1,2,3,5);\n\nconsole.log(arr0, arr1, arr2, arr3); // [] [] [ <5 empty items> ] [ 1, 2, 3, 5 ]\n```\n\n#### 其他数据类型转数组\n\nset->Array\n\nArray.from(set)\n\nstring->Array\n\n#### 属性\n\n`length`\n\n> 计算并返回数组长度\n\n```javascript\nlet arr0 = [1,2,3,4]; // 字面\nconsole.log(arr0.length); // 4\n```\n\n`constructor`\n\n> 返回创建该对象的函数的引用, 因为js的一切变量都是对象, 是对象就有其构造函数.\n>\n\n```javascript\nvar test=new Array();\nif (test.constructor==Array){\n\tdocument.write(test.constructor);\n}\n// output: function Array() { [native code] }\n```\n\n#### 方法\n\n##### 改变原数组\n\n**Array.sort()**\n\n> 对数组元素进行排序, 默认是字符串顺序.\n>\n\n```javascript\n// 按照字母顺序排序 默认\nlet arr = ['hi', 'Bob', 'good', 'are', 'you', 'google'];\narr.sort();\nconsole.log(arr); // [ 'Bob', 'are', 'good', 'google', 'hi', 'you' ]\n```\n\n> 添加比值函数, 使得能对**数字进行排序**.\n>\n\n```javascript\n// 不使用比值函数\nlet arr = [3, 7, 9, 1, 0, 12, 34, 76, 91];\narr.sort();\nconsole.log(arr); \n/* \n[\n  0,  1, 12,  3, 34,\n  7, 76,  9, 91\n]\n*/\n\n// 使用比值函数 倒序\nlet arr = [3, 7, 9, 1, 0, 12, 34, 76, 91];\narr.sort((a, b) => b - a);\nconsole.log(arr);\n/*\n[\n  91, 76, 34, 12, 9,\n   7,  3,  1,  0\n]\n*/\n\n// 使用比值函数 正序\nlet arr = [3, 7, 9, 1, 0, 12, 34, 76, 91];\narr.sort((a, b) => a - b);\nconsole.log(arr); \n/*\n[\n   0,  1,  3,  7, 9,\n  12, 34, 76, 91\n]\n*/\n```\n\n**Array.pop()**\n\n> 删除数组的最后一个元素并返回该元素. 空数组返回`undefined`.\n>\n\n```javascript\nlet arr0 = [1, 2, 3, 4];\nconsole.log(arr0.pop(), arr0);\n// output: 4 [ 1, 2, 3 ]\n\nlet arr1 = [];\nconsole.log(arr1.pop(), arr1);\n// output: undefined []\n```\n\n**Array.shift()**\n\n> 删除并返回数组的第一个元素\n>\n\n```javascript\nlet arr1 = [1,2,3];\nconsole.log(arr1.shift(), arr1);\n// 1 [ 2, 3 ]\n```\n\n**Array.unshift()**\n\n> 向数组的开头添加元素并返回现有长度\n>\n\n```javascript\nlet arr1 = [1, 2, 3, 4, 5];\nconsole.log(arr1.unshift(9), arr1);\n// 6 [ 9, 1, 2, 3, 4, 5 ]\n```\n\n**Array.push()**\n\n> 向数组末尾添加元素并返回数组现有长度\n>\n\n```javascript\nlet arr1 = [1,2,3];\nconsole.log(arr1.push(4), arr1);\n// output: 4 [ 1, 2, 3, 4 ]\n```\n\n**Array.reverse()**\n\n> 颠倒数组中元素顺序\n>\n\n```javascript\nlet arr1 = [1,2,3];\nconsole.log(arr1.reverse(), arr1);\n// output: [ 3, 2, 1 ] [ 3, 2, 1 ]\n```\n\n**Array.splice()** \n\n> 推荐使用该方法删除数组元素\n>\n> 注意: 删除的元素以数组形式返回.\n>\n\n```javascript\nlet arr = [1, 2, 3, 4, 5]\narr.splice(2, 1, 'ok', 'fine'); // 从数组下标为2的位置开始删除1个元素,再插入2个元素\nconsole.log(arr); // [ 1, 2, 'ok', 'fine', 4, 5 ]\n\n// 不留空洞地删除元素\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\n// 从下标为3的位置开始, 删除2个元素\nconsole.log(arr.splice(3, 2)); // ['fine', 'you'] 注意这里是数组形式!\nconsole.log(arr); // [ 1, 2, 'ok', 'bye' ]\n```\n\n**delete**  \n\nJS运算符\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\ndelete arr[0];\nconsole.log(arr[0], arr); // 留下了空洞\n// undefined [ <1 empty item>, 2, 'ok', 'fine', 'you', 'bye' ]\n```\n\n\n\n##### 不改变原数组\n\n**Array.slice()**\n\n> 根据下标获取数组的一部分, 返回新数组.\n>\n\n```javascript\nlet arr1 = [1, 2, 3, 4, 5];\nconsole.log(arr1.slice(3), arr1.slice(2,4), arr1);\n// output: [ 4, 5 ] [ 3, 4 ] [ 1, 2, 3, 4, 5 ]\n```\n\n**Array.concat()**\n\n> 拼接数组成一个新数组\n>\n\n```javascript\nlet arr0 = [1, 2, 3, 4];\nlet arr1 = [5, 6];\nconsole.log(arr0.concat(arr1), arr0, arr1);\n// output: [ 1, 2, 3, 4, 5, 6 ] [ 1, 2, 3, 4 ] [ 5, 6 ]\n```\n\n**Array.flat()**\n\n> 按照指定的深度递归遍历数组, 将所有元素与遍历到的子数组中的元素合并为一个**新数组**返回.\n>\n> 将数组扁平化\n\n```javascript\n/* 默认递归深度为1 */\nlet arr = [1, 2, ['ok', 'fine']]\nlet arr1 = arr.flat();\nconsole.log(arr1, arr);\n// [ 1, 2, 'ok', 'fine' ] [ 1, 2, [ 'ok', 'fine' ] ]\n\n// 移除数组空项\nlet arr = [1, 2, null, undefined, , , 5];\nconsole.log(arr.flat());\n// [ 1, 2, null, undefined, 5 ]\n\n/* 指定递归深度 */\nlet arr = [1, 2, [[['ok', 'fine']]]];\nconsole.log(arr.flat(2), arr.flat(3));\n// [ 1, 2, [ 'ok', 'fine' ] ] [ 1, 2, 'ok', 'fine' ]\n```\n\n**Array.join()**  默认使用 `,` 为分隔符\n\n> `toString` 所有 JavaScript 对象都拥有`toString()`方法\n>\n> 数组所有元素组成字符串, 可以指定分隔符.\n>\n\n```javascript\nlet arr0 = [1, 2, 3, 4];\nconsole.log(arr0.join(), arr0.toString()); // 1,2,3,4  1,2,3,4\nconsole.log(arr0.join('*')); // 1*2*3*4\nconsole.log(arr0); // [ 1, 2, 3, 4 ]\n```\n\n**Array.map()**\n\n> 对数组的每个元素均执行函数, 对其做一些处理, 来生成新数组. **不改变原数组**.\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\nlet arr2 = arr.map((val, index, array) => {\n  return val + '*' + index;\n});\n// 原数组不变\nconsole.log(arr2, arr);\n// [ '1*0', '2*1', 'ok*2', 'fine*3', 'you*4', 'bye*5' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]\n\nvar arr = [1, 2, 3, 4, 5]\nlet a = arr.map(c => c - 1);\nconsole.log(a); // [ 0, 1, 2, 3, 4 ]\n```\n\n**Array.filter()**\n\n> 对数组的每个元素均执行函数, 筛选符合条件的元素来生成新数组.**不改变原数组**.\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\nlet arr2 = arr.filter((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(arr2, arr);\n// [ 'ok', 'fine', 'you', 'bye' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]\n```\n\n**Array.forEach()**\n\n> 对数组的每个元素均执行一次函数(回调函数)\n\n```javascript\nlet arr = [1, 2, 'ok', 'fine', 'you', 'bye']\nlet s = '';\n// 该函数的参数1为数组元素,参数2为数组元素下标,参数3为该数组本身\narr.forEach((val, index, array) => {\n  s += (val + '/' + index + ' ');\n});\nconsole.log(s); // 1/0 2/1 ok/2 fine/3 you/4 bye/5 \n```\n\n**Array.reduce()**\n\n> 参数`total` 默认是数组的第一个元素, 可以设置初始值.\n\n```javascript\nlet arr = ['bye', 'hi', 'ok', 'fine', 'you', 'bye']\nlet res = arr.reduce((total, val, index, array) => {\n  console.log(\"total=\", total, val, index); // 从index=1开始打印\n  return total + '*' + val;\n});\nconsole.log(res, arr);\n/*\ntotal= bye hi 1\ntotal= bye*hi ok 2\ntotal= bye*hi*ok fine 3\ntotal= bye*hi*ok*fine you 4\ntotal= bye*hi*ok*fine*you bye 5\nbye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]\n*/\n\n// 设置total初始值\nlet arr = ['bye', 'hi', 'ok', 'fine', 'you', 'bye']\nlet res = arr.reduce((total, val, index, array) => {\n  return total + '*' + val;\n}, \"this is :\");\nconsole.log(res, arr);\n// this is :*bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]\n```\n\n**Array.reduceRight()**\n\n> 类似于`Array.reduce()`, 只不过是从右往左遍历元素.\n\n```javascript\nlet arr = ['bye1', 'hi', 'ok', 'fine', 'you', 'bye2']\nlet res = arr.reduceRight((total, val, index, array) => {\n  return total + '*' + val;\n}, \"this is res:\");\nconsole.log(res, arr);\n// this is res:*bye2*you*fine*ok*hi*bye1 [ 'bye1', 'hi', 'ok', 'fine', 'you', 'bye2' ]\n```\n\n**Array.every()**\n\n> 检查数组中的元素是否**都符合条件**, 都符合才返回true, 否则返回false.\n\n```javascript\n// 有元素不符合条件 false\nlet arr = [1, 'hi', 'ok', 'fine']\nlet res = arr.every((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(res, arr);\n// false [ 1, 'hi', 'ok', 'fine' ]\n\n// 所有元素均符合条件 true\nlet arr = [1, 2, 3];\nlet res = arr.every((val, index, array) => {\n  return typeof val == 'number';\n});\nconsole.log(res, arr);\n// true [ 1, 2, 3 ]\n```\n\n**Array.some()**\n\n> 检查是否**有元素符合条件**, 有则返回true, 没有则返回false.\n\n```javascript\n// 有元素符合条件 true\nlet arr = [1, 'hi', 'ok', 'fine']\nlet res = arr.some((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(res, arr);\n// true [ 1, 'hi', 'ok', 'fine' ]\n\n// 所有元素均不符合条件 false\nlet arr = [1, 2, 3];\nlet res = arr.some((val, index, array) => {\n  return typeof val == 'string';\n});\nconsole.log(res, arr);\n// false [ 1, 2, 3 ]\n```\n\n**Array.indexOf()**\n\n> 找到给定元素在数组中第一次出现的位置, 没有则返回-1, 找到则返回元素下标.\n\n```javascript\n// 找不到 -1, 找到就下标\nlet arr = ['hi', 'Bob', 'how', 'are', 'you'];\nlet res1 = arr.indexOf(3);\nlet res2 = arr.indexOf('how');\nconsole.log(res1, res2); // -1 2\n\n// 元素多次出现 返回第一次出现的位置\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob'];\nlet res2 = arr.indexOf('Bob');\nconsole.log(res2); // 1\n\n// 指定搜索位置\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob'];\nlet res2 = arr.indexOf('Bob', 2);\nconsole.log(res2); // 5\n\n// 搜索起始位置可以是负值\n// 负值是从数组末尾给定位置开始搜索, 直至末尾.\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.indexOf('Bob', -1), // 从倒数第一个位置开始, 搜索不到\n    res2 = arr.indexOf('Bob', -2); // 从倒数第二个位置开始搜索, 是可以检索到的, 返回正数下标\nconsole.log(res1, res2); // -1 5\n```\n\n**Array.lastIndexOf()**\n\n> 与上一个类似, 只是从数组末尾开始检索.\n\n```javascript\n// 出现两次Bob, 但是返回了从右往左的第一个.\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.lastIndexOf('Bob');\nconsole.log(res1); // 5\n\n// 设定搜索起始位置\nlet arr = ['hi', 'Bob', 'how', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.lastIndexOf('Bob', -3); // 从倒数第三个元素开始往左搜索, 返回匹配的第一个元素的下标\nconsole.log(res1); // 1\n```\n\n**Array.find()**\n\n> 返回符合条件的第一个元素\n\n```javascript\nlet arr = ['hi', 'Bob', 'good', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.find((val, index, array) => {\n  return val.length > 3;\n});\nconsole.log(res1); // good\n```\n\n**Array.findIndex()**\n\n> 返回符合条件的第一个元素**下标**\n\n```javascript\nlet arr = ['hi', 'Bob', 'good', 'are', 'you', 'Bob', 'google'];\nlet res1 = arr.findIndex((val, index, array) => {\n  return val.length > 3\n});\nconsole.log(res1); // 2\n```\n\n\n\n#### 数组操作\n\n##### 去重\n\n利用键本身的不可重复性\n\n> 利用ES6 Set 去重 (ES6中最常用)\n\n```javascript\nlet arr = [1, 2, 2, 3, 3, 3];\nlet res = Array.from(new Set(arr));\nconsole.log(res); // [ 1, 2, 3 ]\n\n// 简易写法\n[...new Set(arr)]\n```\n\n双层循环法 \n\n> splice去重(ES5 常用)\n\n```javascript\nfunction unique (arr) {\n  // 每一个元素都向后检查有没有与自己相同的元素\n  // 如果有 则删除第二个元素\n  // 由于splice的特性 删除后 需要j-- 保证j指向被删除元素的下一个元素而不会遗漏元素\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) { // 注意使用===, 因为 null === undefined 为true\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n}\n\nlet arr1 = [1, 2, 2, 3, 3, 3];\nunique(arr1);\nconsole.log('arr1:', arr1); // arr1: [ 1, 2, 3 ]\n```\n\n> 使用 fliter+indexOf\n\n```javascript\nfunction unique (arr) {\n  return arr.filter((val, index) => {\n    // 返回符合条件的元素\n    // 返回所有第一次出现的元素\n    return arr.indexOf(val, 0) == index;\n  })\n}\n\nlet arr1 = [1, 2, 2, 3, 3, 3, null, undefined];\nlet res = unique(arr1);\nconsole.log('res:', res);\n// res: [ 1, 2, 3, null, undefined ]\n```\n\n\n\n### * Map (ES6)\n\n解决js对象的键只能是字符串的问题, **ES6标准新增**的数据类型.\n\n#### 创建/添加/删除/是否包含\n\n```javascript\n// 二维数组\nlet map = new Map([['Michael', 90], ['Bob', 80], ['Lily', 95]]);\nconsole.log(map.get('Lily')); // 95\nconsole.log(map); // Map { 'Michael' => 90, 'Bob' => 80, 'Lily' => 95 }\n\n// 初始化一个空map, 然后添加元素\nlet map = new Map();\nmap.set('Michael', 90); // 添加Key\nmap.set('Bob', 80);\nmap.set('Lily', 95);\nconsole.log(map); // Map { 'Michael' => 90, 'Bob' => 80, 'Lily' => 95 }\nmap.delete('Lily'); // 删除 key\nconsole.log(map); // Map { 'Michael' => 90, 'Bob' => 80 }\n// 判断是否包含某key\nconsole.log(map.has('hello'), map.has('Bob')); // false true\n// 获取值\n// 一个key只对应一个value, 重复设置会覆盖之前的值\nmap.set('Bob', 100);\nconsole.log(map.get('Bob')); // 100\n```\n\n\n\n### * Set (ES6)\n\n一组不重复key的集合.ES6标准新增的数据类型.\n\n#### 创建/添加/删除/是否包含\n\n```javascript\n// 数组作为输入\nlet set1 = let set1 = new Set([5, 6, 7, 8, 8, 7]);\nconsole.log(set1); // Set { 5, 6, 7, 8 } 重复元素被自动过滤\n\n// 初始化空Set, 再添加值\nlet set = new Set();\nset.add(1); // 添加元素\nset.add(2);\nset.add(3);\nset.add(4);\nconsole.log(set); //Set { 1, 2, 3, 4 }\nset.delete(3); // 删除元素\nconsole.log(set); // Set { 1, 2, 4 }\nset.add(4); // 可以添加重复元素 但是无效\nconsole.log(set); // Set { 1, 2, 4 }\n// '4' 与 4 不同\nconsole.log(set.has('4'), set.has(4)); // false true\n```\n\n\n\n### * 函数\n\n函数定义是一个常规的绑定,  其中绑定的值是函数. \n\n函数的第一种表示法.\n\n```javascript\n// 大括号必要, 末尾建议带分号\nlet square = function (x) {\n  return x * x;\n};\n```\n\n函数也是值的一种, 可以被赋值给多个变量/作为参数传递给函数等.\n\n```javascript\nlet func1 = () => {\n  console.log('1111');\n}\nfunc1(); // 1111\n\n// func1 可以被绑定为其他函数\nfunc1 = () => {\n  console.log('2222');\n}\nfunc1 // 2222\n```\n\n没有 `return` 语句或 `return` 后面没有返回值, 函数将返回 `undefined`.\n\n```javascript\nlet func1 = () => {\n  return;\n}\nconsole.log(func1()); // undefined\n\nlet func2 = () => {\n}\nconsole.log(func2()); // undefined\n```\n\n每个局部作用域可以查看包含它的局部作用域, 所有局部作用域都能看见全局作用域.\n\n#### 声明表示法\n\n函数的第二种表示法.\n\n声明在调用之后也能够工作, 声明在概念上被移到了作用域的顶部.\n\n```javascript\nfunction square (x) {\n  return x * x;\n} // 不需要分号\n```\n\n#### 箭头函数\n\n函数的第三种表示法. 以较简明的方式编写小型函数表达式.\n\n```javascript\n// 两种写法相同\nlet square1 = (x) => {\n  return x * x;\n};\n\nlet square2 = x => x * x;\n```\n\n#### 调用栈\n\n函数返回时必须跳回到调用它的位置, 所以计算机必须记住调用发生的上下文. 存储此上下文的位置是调用栈, 每次调用函数时, 当前上下文都存储在此栈的顶部.\n\n#### 可选参数\n\n多余参数自动忽略, 不足参数为 `undefined`.\n\n```javascript\nlet square1 = (x, y) => {\n  console.log(x, y);\n  return x * y;\n};\n\nconsole.log(square1(2, 7, 'helloo'[2, 3]), square1(2));\n// 2 7\n// 2 undefined\n// 14 NaN\n```\n\n参数设定默认值\n\n```javascript\nlet square1 = (x, y = 3) => {\n  console.log(x, y);\n  return x * y;\n};\n\nconsole.log(square1(2, 7), square1(2));\n// 2 7\n// 2 3\n// 14 6\n```\n\n#### 作用域链\n\n定义了一个函数激活执行的时候, 去哪里找变量的值.\n\n```javascript\nfunction createFunc () {\n  var desc = ' is eating';\n  function eat (animal) {\n    console.log(animal.name + desc);\n  }\n  return eat;\n}\nlet dog = { name: 'dog' }\nvar eat = createFunc();\n// 全局变量\nvar desc = '吃东西';\neat(dog); // dog is eating\n```\n\n`eat` 函数的作用域链如下:\n\n```javascript\neat函数作用域[parent作用域-A]\n\nA = createFunc作用域[desc: ' is eating', eat: <func 定义>, parent作用域-B]\n\nB = Global作用域[desc: '吃东西', createFunc: <func 定义>, parent作用域-null]\n```\n\neat 函数中没有定义 `desc` 这个变量值, 就沿着作用域链去找, 在 `createFunc` 作用域中找到了 `desc` 变量的值, 于是就使用了.如果还没有找到, 就接着往上找.\n\n当执行 `createFunc` 的时候, `eat` 函数被创建, 此时 eat 函数会把外部函数的作用域链记录下来, 留到执行时使用. \n\n注意: 作用域链是**函数创建时刻**发生关联的, 不是运行时刻. Called **静态作用域/词法作用域**. 函数被创建即函数被定义.\n\n```javascript\nvar x = 1;\n// 此处 foo 函数被创建, 与全局作用域相关联\nfunction foo () {\n  console.log(x);\n}\n\nfunction bar (func) {\n  var x = 2;\n  func();\n}\n\n// foo 函数执行时直接去全局作用域找 x 变量\nbar(foo); // 1\n```\n\n静态作用域是实现闭包的必需条件.\n\n\n\n#### 闭包\n\n闭包在 JS 中就是一个以函数和以静态方式存储的父作用域的一个集合体.\n\n能够**读取函数局部变量的函数**就是闭包. 下面例子中, `func2`函数就是闭包.\n\n```javascript\nvar func1 = () => {\n  let a = 999;\n  var func2 = () => {\n    return a;\n  }\n  return func2;\n}\nlet func = func1();\nconsole.log(func()); // 999\n```\n\n用途: 读取函数内部变量 / 让这些变量的值始终保持在内存中.\n\n```javascript\nlet nAdd;\nvar func1 = () => {\n  let a = 999;\n  nAdd = function(){\n    a++;\n  }\n  var func2 = () => {\n    console.log('a:',a);\n  }\n  return func2;\n}\nlet func = func1(); // 闭包函数\nfunc(); // a 999\nnAdd();\nfunc(); // a 1000\n```\n\n证明了`func1`的局部变量`a`一直在内存中, 并没有在func1被调用后被自动清除. \n\n因为`func1`是`func2`的父函数, 而`func2`被赋予了局部变量`func`, 导致`func2`一直在内存中, 则`func2`依赖的`func1`也一直在内存中, 不会在调用结束后, 被垃圾回收机制回收.\n\n这里`nAdd`也是一个匿名函数, 也是一个闭包, 相当于一个setter, 可以在函数外部对函数内部局部变量进行操作.\n\n使用闭包的注意点:\n\n1. 闭包会使函数中的局部变量在内存中, 因此会使得内存占用过多, 不能滥用. 在退出函数前, 将不使用的局部变量全部删除.\n2. 闭包会在函数外部, 改变父函数内部变量的值, 注意不要随便改变.\n\n思考题:\n\n1. `this` 在函数中而不是方法中使用时, 指向全局对象\n\n```javascript\nvar name = \"The Window\";\n\nvar object = {\n  name: \"My Object\",\n\n  getNameFunc: function () {\n    return function () {\n      console.log(this);\n      return this.name;\n    };\n  }\n};\n\n// 这里直接在 vscode 中执行, 所以打出来是 undefined, 可能原本是 The Window\nconsole.log(object.getNameFunc()()); // undefined\n\n// this 打印出来如下\n/* \nObject [global] {\n  global: [Circular],\n  clearInterval: [Function: clearInterval],\n  clearTimeout: [Function: clearTimeout],\n  setInterval: [Function: setInterval],\n  setTimeout: [Function: setTimeout] {\n    [Symbol(nodejs.util.promisify.custom)]: [Function]\n  },\n  queueMicrotask: [Function: queueMicrotask],\n  clearImmediate: [Function: clearImmediate],\n  setImmediate: [Function: setImmediate] {\n    [Symbol(nodejs.util.promisify.custom)]: [Function]\n  }\n}\n*/\n```\n\n2. 这里 `that` 指向整个 object.\n\n```javascript\nvar name = \"The Window\";\n\nvar object = {\n  name: \"My Object\",\n  getNameFunc: function () {\n    var that = this;\n    return function () {\n      return that.name;\n    };\n  }\n};\n\nconsole.log(object.getNameFunc()()); // My Object\n```\n\n\n\n#### arguments\n\n对应于传递给函数的参数的类数组对象, 是所有非箭头函数中可用的局部变量, 可以使用它来引用函数的参数.\n\n1. arguments参数可以被设置\n2. 不是一个Array, 只是类似, 类型是 object\n3. 只有length和索引元素功能\n4. 可以被转换为真正的数组\n\n```javascript\nfunction unique (a, b, c, d, e) {\n  console.log(arguments[1]); // 2\n  // 参数被设置\n  arguments[1] = 3;\n  arguments[4][0] = 'Mary';\n  console.log(arguments[1], arguments[4]); // 3 [ 'Mary', 'hi', 'go' ]\n\n  // arguments转换为数组\n  let args0 = Array.prototype.slice.call(arguments);\n  let args1 = [].slice.call(arguments);\n  // 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)\n  // 注重性能 使用被忽视的Array构造函数作为一个函数\n  let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));\n  console.log('ES6', args0, args1, '遍历对象构造数组', args);\n  // ES6 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] 遍历对象构造数组 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]\n  \n  // ES2015\n  let args3 = Array.from(arguments);\n  let args4 = [...arguments];\n  console.log('ES5', args3, args4);\n  // ES5 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]\n  \n  console.log(typeof arguments); // object\n}\n\nunique(1, 2, 3, 4, ['hello', 'hi', 'go']);\n```\n\n#### eval 函数\n\n计算某个**原始字符串**(不是String对象), 并执行其中的JS代码, 并返回结果(如果不存在, 则返回undefined). 是全局对象的一个函数属性.\n\n```javascript\nlet x = 8;\nlet res = eval('x+2');\nconsole.log(res, eval('4+8')); // 10 12\neval('let a = 10, b = 9; console.log(a*b)'); // 90\nconsole.log(eval()); // undefined\n// 不是字符串的话, 原封不动返回\nconsole.log(eval(67)); // 67\nconsole.log(eval(new String(777))); // [String: '777']\n```\n\n\n\n## 操作符 typeof\n\n### 判断变量数据类型\n\n```javascript\nconsole.log(\n  // 通用数据类型\n\ttypeof 'jinling' + '\\n' +  // string\n\ttypeof 23 + '\\n' + // number\n\ttypeof true + '\\n' +  // boolean\n\ttypeof [1,2,3] + '\\n' + // object\n\ttypeof {k1:'v1', k2:'v2'} + '\\n' // object\n  // 特殊字符类型\n  typeof null + '\\n' + // object\n\ttypeof undefined + '\\n' + // undefined\n\ttypeof NaN + '\\n' // number\n)\n\n// undefined与null值相同,但类型不同\nconsole.log(undefined===null, undefined==null); // false true\n\n// 判断数组可以用 Array.isArray\nconsole.log(Array.isArray([1,2,3])) // true\nconsole.log(Array.isArray({k1:'v1', k2:'v2'})) // false\n```\n\n\n\n\n\n# 对象 Object\n\n使用{}表示, 键必须是字符串.\n\n## 封装\n\n接口与实现分离, 常称为封装. 常见在属性开头加上_表示是私有属性.\n\n## 创建对象\n\n创建一个对象, 定义属性和方法, 不需要 Class.\n\n对象中的方法就是保存函数的属性.\n\n```javascript\nlet animal = {\n  name: 'dog',\n  eat () {\n    console.log(`${this.name} eat meat`);\n  }\n}\nanimal.eat(); // dog eat meat\nanimal.color = 'red';\nconsole.log(animal.color); // red\n```\n\n显式修改方法的调用对象. 使用函数的 `call` 方法, 该方法将 `this` 值作为第一个参数, 其他参数为普通参数. 则此时 `obj` 是 `eat` 方法的调用者, 通过 `call` 进行了显式的调用对象的修改.\n\n```javascript\nlet animal = {\n  name: 'dog',\n  eat (thing) {\n    console.log(`${this.name} eat ${thing}`);\n  }\n}\n\nlet obj = { name: 'monkey' };\n// obj 成为 eat 方法的调用者\nanimal.eat.call(obj, 'carrot'); // monkey eat carrot\n```\n\n## 原型\n\n对象有自己的默认属性集. `Object.getPrototypeOf` 方法返回一个对象的原型.\n\n`Object.prototype` 提供在所有对象中显示的方法, 是最根部的原型.\n\n函数派生自 `Function.prototype`, 数组派生自 `Array.prototype`, 他们具有不同的默认属性集.\n\n```javascript\nlet obj = {}\nconsole.log(obj.toString); // [Function: toString]\nconsole.log(obj.toString()); // [object Object]\n\nlet obj = {}\nconsole.log(obj.__proto__); // {}\n\n// 空对象的原型是 Object.prototype\nconsole.log(Object.getPrototypeOf({}) == Object.prototype); // true\n\n// Object.prototype 原型为 null\nconsole.log(Object.getPrototypeOf(Object.prototype)); // null\n```\n\n### Object.create\n\n使用 `Object.create` 创建具有特定原型的对象.\n\n```javascript\nlet protoDog = {\n  speak(word){\n    console.log(this.name + ' is speaking ' + word);\n  }\n}\n\nlet dog = Object.create(protoDog);\ndog.name = 'doggi'; // dog 对象此时仅包含自身属性 name\n// speak 方法来自原型\ndog.speak('hello'); // doggi is speaking hello\n```\n\n\n\n### __proto\\_\\_ 属性\n\n继承是让两个对象产生关联, 使用 __proto\\_\\_, 这个属性每个对象都有. \n\n```javascript\nlet animal = {\n  name: 'animal',\n  eat () {\n    console.log(`${this.name} eat meat`);\n  }\n}\n\n// 属性覆盖 方法不覆盖\n// 对象 dog 的原型是 animal\nlet dog = {\n  name: 'dog',\n  __proto__: animal // 指向animal对象\n}\n\n// 对象 cat 的原型是 animal\nlet cat = {\n  name: 'cat',\n  __proto__: animal // 指向animal对象\n}\ndog.eat(); // dog eat meat\ncat.eat(); // cat eat meat\n\n// 单纯关联 不做属性或者方法覆盖\nlet dog = {\n  __proto__: animal\n}\nlet cat = {\n  __proto__: animal\n}\nconsole.log(dog.name, cat.name); // animal animal\ndog.eat(); // animal eat meat\ncat.eat(); // animal eat meat\n\n// 方法覆盖 属性不覆盖\nlet dog = {\n  __proto__: animal,\n  eat () {\n    console.log('dog is eating');\n  }\n}\nlet cat = {\n  __proto__: animal,\n  eat () {\n    console.log('cat is eating');\n  }\n}\nconsole.log(dog.name, cat.name); // animal animal\ndog.eat(); // dog is eating\ncat.eat(); // cat is eating\n```\n\n如下所示, 对象 `dog` 和 `cat` 的原型均是 `animal`, 但是均没有定义 `eat` 方法. 在执行 `eat` 方法时, 会到其原型中去寻找, 如果找到则执行, 没有则继续去原型的原型中去寻找, 直至找到或者为`null`. 不断寻找原型的过程依赖于__proto\\_\\_建立的原型链.\n\n可以看出, 尽管执行的是原型中的方法, 但是方法中的`this`仍然指的是调用该方法的上级对象, 由于是`dog`和`cat`这两个对象进行调用的, 所以 this 指向的就是这两个对象而不是 animal.\n\n### 构造函数\n\n但是 JS 也可以通过 `new` 关键字来创建对象, 是给不理解原型链又需要创建对象的程序员使用的.\n\n```javascript\n// 模仿 java 中的 Class 而提供的构造函数\n// Student 的首字母大写\nfunction Student (name) {\n  this.name = name;\n  this.sayHello = function () {\n    console.log('hello ' + this.name);\n  }\n}\n\nlet lily = new Student(\"lily\");\nlet mary = new Student(\"mary\");\n\nlily.sayHello(); // hello lily\nmary.sayHello(); // hello mary\n```\n\n这样有个问题就是, 每个对象都会有一个 `sayHello` 函数, 太重复, 而 java 中函数是定义在 `class` 中的.\n\n### prototype\n\nJS  使用更加高效的方式, 创建一个原型对象 A, 将方法都放在这个原型对象 A 中, 而通过同一个构造函数创建的对象的原型, 都是这个原型对象 A, 这样对象找不到方法时, 就会去其原型即 A 中寻找.\n\n达到这样的效果,  则需要将构造函数与原型对象 A 关联起来, 将 A 赋值给构造函数的 `prototype` 属性, 则 A 就会成为这个构造函数创建的对象的原型.\n\n```javascript\nfunction Student (name) {\n  this.name = name;\n}\n\n// 原型对象\nStudent.prototype = {\n  sayHello () {\n    console.log('hello ' + this.name);\n  }\n}\n\nlet lily = new Student(\"lily\");\nlet mary = new Student(\"mary\");\n\nlily.sayHello(); // hello lily\nmary.sayHello(); // hello mary\n```\n\n### 语法糖 Class\n\n上述语法有点复杂, JS 推出语法糖, 将构造函数与原型对象的函数写在一个 `class` 中.\n\n上述写法等同于下面这种.\n\n```javascript\nclass Student {\n  constructor(name) {\n    this.name = name;\n  }\n  // 构造函数的 prototype\n  // 原型对象\n  // 作为对象的方法, this 指向的是 调用该方法的对象\n  sayHello = () => {\n    console.log('hello ' + this.name);\n  }\n}\n\nlet mary = new Student('mary');\n// mary 对象调用其原型(__proto__)的方法 sayHello\n// 此时方法中的 this 指向 mary 对象\nmary.sayHello(); // hello mary\n```\n\n\n\n## 类 Class\n\n一种语法糖, 特殊的函数, 由**类表达式**和**类声明**组成. 类定义了一种对象的形状, 具有哪些属性与方法. 而这种对象称之为类的实例.\n\nJS 类就是带有 prototype 属性的构造函数. 类中的方法, 都是构造函数原型对象中的方法. 类中的`constructor`方法是实际的构造函数, 并被绑定名称 `Animal`.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  // 目前只支持将函数添加进构造函数原型中 \n  // 不支持其他类型\n  speak () {\n    console.log(this.name + ' is speaking!');\n  }\n}\n```\n\n\n\n### 定义类\n\n1. 类声明 带有`class`关键字\n\n   ```javascript\n   // 类需要先声明 再使用 不像函数声明会提升\n   class hello {\n     constructor(height, width) {\n       this.height = height;\n       this.width = width;\n     }\n   }\n   ```\n\n2. 类表达式 可以具名或者匿名\n\n   ```javascript\n   // 匿名类\n   let hello = class {\n     constructor(height, width) {\n       this.height = height;\n       this.width = width;\n     }\n   }\n   console.log(hello.name); // hello\n   \n   // 具名类\n   let hello = class hello2{\n     constructor(height, width) {\n       this.height = height;\n       this.width = width;\n     }\n   }\n   console.log(hello.name); // hello2\n   ```\n\n3. 传统的基于函数的类\n\n   ```javascript\n   function Animal(name){\n     this.name = name;\n   }\n   \n   Animal.prototype.speak = function () {\n     console.log(this.name + ' makes a noise.');\n   }\n   \n   class Dog extends Animal{\n     speak(){\n       super.speak();\n       console.log(this.name + ' barks.');\n     }\n   }\n   \n   let d = new Dog('cookie')\n   d.speak(); \n   // cookie makes a noise.\n   // cookie barks.\n   ```\n\n\n\n### 类体和方法定义\n\n`constructor` \n\n构造函数, 一种特殊方法, 创建和初始化一个由 `class` 创建的对象. \n\n构造函数可以使用`super`调用父类的构造函数.\n\n### 覆盖派生属性\n\n向对象中添加属性, 属性被添加到对象本身, 原型中的此属性将不再影响该对象.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak () {\n    console.log(this.name + ' is speaking!');\n  }\n}\n\n// 给构造函数的原型对象添加属性\nAnimal.prototype.age = 5;\n\nlet dog = new Animal('dog');\ndog.age = 10; // 覆盖原型属性\nconsole.log(dog.age); // 10\n\nlet cat = new Animal('cat');\nconsole.log(cat.age); // 5\n\nconsole.log(Object.getPrototypeOf(dog).age); // 5\n```\n\n数组原型提供的 `toString` 方法与基本原型对象提供的有所差别, 这样对原型属性的覆盖有利于更通用的对象类中表达异常属性.\n\n```javascript\nconsole.log(Array.prototype.toString == Object.prototype.toString); // false\nconsole.log([1, 2, 3].toString()); // 1,2,3\n\n// Object.prototype.toString 并不知道数组的信息, 只是将 object 与调用对象的类型名称放在[]中\nconsole.log(Object.prototype.toString.call([1, 2]), Object.prototype.toString.call(4)); \n// [object Array] [object Number]\n```\n\n### 多态\n\n对原型方法的覆盖, 以实现实例的特殊化需求. `String` 实际调用的仍然是 `toString` 方法.\n\n```javascript\nlet dog = new Animal('dog');\nconsole.log(String(dog)); // [object Object]\nAnimal.prototype.toString = function () {\n  return 'This is ' + this.name;\n}\nconsole.log(String(dog)); // This is dog\n```\n\n任何支持 `toString` 方法的对象都可以使用它.\n\n**多态**: 多态代码可以支持不同类型的值, 只要这些值支持它指定的接口. 比如 toString 方法, 所有值都支持该接口, 则所有值都能使用该方法.\n\n\n\n### 映射\n\n普通对象派生自 `Object.prototype` , 含有祖先原型的所有属性, 在一些实际场景下, 这些属性可能显得多余. \n\n→ 可以创建没有原型的对象.\n\n```javascript\n// 传递 null 生成的对象不会从 Object.prototype 派生\nconsole.log('toString' in Object.create(null)); // false\nconsole.log('toString' in {}); // true\n```\n\n而且普通对象要求键值必须为字符串.\n\n→ 使用 Map 类, 存储映射并可以使用任何类型的 key.\n\n```javascript\nlet ages = new Map();\nages.set('Bob', 23);\nages.set('Mary', 17);\nconsole.log(ages.get('Bob')); // 23\nconsole.log(ages.has('Mary'), ages.has('toString')); // true false\n```\n\nset get has 是 Map 对象接口的一部分.\n\n\n\n某种情况下,  如果确实需要使用普通对象来作为映射, 则 `Object.keys` 只返回一个**对象自己的键,** 而不包括其原型中的那些属性. \n\n```javascript\nclass Animal{\n  constructor(name){\n    this.name = name;\n    this.age = 18;\n  }\n  speak(){\n    console.log(this.name + 'is speaking');\n  }\n}\n\nlet dog = new Animal('dog');\nconsole.log(Object.keys(dog)); // [ 'name', 'age' ]\n\n// 给原型添加属性\ndog.__proto__.type = 'animal';\n// Object.keys(dog) 仍然只显示自己的属性, 不包括原型中的属性\nconsole.log(Object.keys(dog), Object.keys(dog.__proto__)); // [ 'name', 'age' ] [ 'type' ]\n```\n\n`hasOwnProperty` 方法也只判断某键**是不是该对象自己的**, 没找到也不会去搜索其原型对象. 与关键字 `in` 不同.\n\n```javascript\nconsole.log(dog.hasOwnProperty('name'), dog.hasOwnProperty('speak')); // true false\nconsole.log('name' in dog, 'speak' in dog); // true true\n```\n\n\n\n### extends 创建子类\n\n```javascript\nclass Dog1 extends Animal {\n  constructor(name, sex) {\n    // 调用超类构造函数并传入name参数\n    // 必须先super 然后才能使用this\n    super(name);\n    this.sex = sex;\n  }\n  speak () {\n    console.log(`${this.name} is ${this.sex} and barks`);\n  }\n}\n\nlet d = new Dog1('cookie', 'girl');\nd.speak(); // cookie is girl and barks\n```\n\n### instanceof 运算符\n\n判断一个对象是否来自某一个类.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  // 目前只支持将函数添加进构造函数原型中 \n  // 不支持其他类型\n  speak () {\n    console.log(this.name + ' is speaking!');\n  }\n}\n\nlet dog = new Animal('dog');\nconsole.log(dog instanceof Animal, dog instanceof Object); // true true\n\n// TO DO \nconsole.log(dog instanceof Object.prototype); // TypeError: Right-hand side of 'instanceof' is not callable\n```\n\n\n\n## 静态方法\n\n> 部署在object对象自身的方法\n\n`Object.values` 获取对象的所有key, 输出类型为数组\n\n`Object.keys` 获取对象的所有value, 输出类型为数组\n\n```javascript\nlet obj = {key1:'val1', key2:'val2', key3:'val3'}\nconsole.log(Object.keys(obj)); // [ 'key1', 'key2', 'key3' ]\nconsole.log(Object.values(obj)); // [ 'val1', 'val2', 'val3' ]\n```\n\n`Object.getOwnPropertyNames` 也是返回对象的所有属性名, 但是还会返回不可枚举的属性; 可枚举属性方面, 与`Object.keys`相同\n\n```javascript\n// 不可枚举属性 二者不同\nlet obj1 = ['hello', 'world', 'jinling']\nconsole.log(Object.keys(obj1)); // [ '0', '1', '2' ]\nconsole.log(Object.getOwnPropertyNames(obj1)); // [ '0', '1', '2', 'length' ] 包含不可枚举属性\n\n// 可枚举属性 二者相同\nlet obj = {key1:'val1', key2:'val2', key3:'val3'}\nconsole.log(Object.keys(obj)); // [ 'key1', 'key2', 'key3' ]\nconsole.log(Object.getOwnPropertyNames(obj)); // [ 'key1', 'key2', 'key3' ]\n```\n\n\n\n## 实例方法\n\n`Object.hasOwnProperty `判断对象是否拥有某项属性\n\n```javascript\nlet obj = {key1:'val1', key2:'val2', key3:'val3'}\nconsole.log(obj.hasOwnProperty('key2')); // true\n```\n\n\n\n\n\n# 函数式编程\n\n摩尔定律失效, 多核时代来临, 函数式编程能够很好地为并发编程服务, 具有 没有 side effect/ 不共享变量/安全调度到任何一个CPU core 上运行/没有加锁问题...等诸多优点.\n\n## 纯函数\n\n1. 对于相同的输入, 永远有相同的输出. 没有可观察的副作用, 不依赖外部条件.\n2. 不能修改传递给函数的参数\n3. 不能修改全局变量\n\n比如数组操作中, 对于给定的数组, slice就是纯的, splice就是不纯的.\n\n纯函数可以有效降低系统复杂性, 还有很多其他的优秀特性, 例如可缓存性.\n\n```javascript\nimport _ from 'lodash';\nvar sin = _.memorize(x => Math.sin(x));\n\n//第一次计算的时候会稍慢一点\nvar a = sin(1);\n\n//第二次有了缓存，速度极快\nvar b = sin(1);\n```\n\n## 使用递归而非迭代\n\n使用尾递归, 保证不溢出.\n\n```javascript\n// 迭代不被允许\nlet arr = [1,2,3,4];\nlet result = 0; // result 不能改变\nfor(let i of arr){\n  result += i; // i 不能改变\n}\nconsole.log(result); // 10\n\n// 递归\nvar first = arr => arr[0]\nvar rest = arr => arr.slice(1)\nvar sum = (arr, res) => {\n  if (arr.length == 0) return res;\n  else return sum(rest(arr), res + first(arr));\n}\nlet arr = [1, 2, 3, 4];\nconsole.log(sum(arr, 0)); // 10\n```\n\n## 高阶函数\n\n很多函数大体相同, 重复代码很多, 只有一些细节不一样, 于是产生高阶函数.\n\n高阶函数: 让函数来产生函数, 共用的部分抽取出来, 不共用的部分与共用的部分能组合起来.\n\n比如 JS 中的 `map/filter/forEach/...` 函数都是高阶函数, 能快速操作集合数据.\n\n### 函数的柯里化\n\ncurry: 传递给函数一部分的参数来调用它, 让他返回一个函数去处理剩下的参数.\n\n就是传递一部分的参数, 形成固定模式的函数(部分参数数值已经固定), 得到已经记住参数的新函数. 这样对应固定的输入, 就得到固定的输出.\n\n```javascript\nvar check = x => (y => y > x);\nlet check7 = check(7);\nconsole.log(check7(10)); // true\n```\n\n### 函数组合\n\n包菜式代码  `h(g(f(x)))` => 更优雅 函数组合\n\n```javascript\n// 传的是g函数需要的参数\n// 将任何两个纯函数结合在一起, 组合函数式的代码\nvar compose = (f, g) => (x => f(g(x)));\n\nvar add1 = x => x + 1;\nvar mul5 = x => x * 5;\n\nlet res = compose(add1, mul5);\nconsole.log(res(2)); // 11\n\n\nvar first = arr => arr[0];\nvar reverse = arr => arr.reverse();\n\nvar last = compose(first, reverse);\nconsole.log(last([1, 2, 3, 4, 5])); // 5\n```\n\n## 惰性求值\n\n待补充\n\n## 宏(macro)\n\n待补充\n\n## Point Free\n\n减少对不必要的中间变量的命名\n\n## 声明式与命令式代码\n\n**命令式**: 写出一条一条指令让计算机执行, 一般会涉及到很多繁琐的细节. **既说做什么, 也说怎么做**.\n\n**声明式**: 写表达式表明自己想做的事情, 而不是一步一步的指示. 隐藏细节.  **只说做什么, 不说怎么做**.\n\n```javascript\n//命令式\nvar CEOs = [];\nfor(var i = 0; i < companies.length; i++){\n    CEOs.push(companies[i].CEO)\n}\n\n//声明式\nvar CEOs = companies.map(c => c.CEO);\n```\n\n函数式编程一个优点就是声明式代码以及纯函数. 工作时专注于业务代码, 优化时专注于函数内部. 还有其他的特点, 比如高阶函数/函数没有side effect/只有值没有变量/用递归而不是用迭代等.\n\n\n\n# 遍历器与 for...of\n\n## 遍历器概念\n\n是用来处理可遍历数据结构的统一接口, 只要部署 `iterator` 接口, 就可以进行遍历操作.\n\n作用: 提供统一的访问接口/数据结构的成员按照某种顺序排列/为ES6新增的`for...of`服务\n\n数据结构有遍历器接口, 就称为该数据结构是可遍历的/可迭代的.\n\n## JS 默认遍历器接口 \n\nJS中默认的遍历器接口, 即数据结构的原型对象有 `Symbol.iterator` 属性, 该属性对应的函数返回一个遍历器对象, 调用对象的`next`方法, 即可返回数据结构的下一个数据..\n\n```javascript\nlet arr = [3, 4, 5];\nlet it = arr[Symbol.iterator]();\nconsole.log(it.next(), it.next(), it.next(), it.next());\n// { value: 3, done: false } { value: 4, done: false } { value: 5, done: false } { value: undefined, done: true }\n// done 表示是否遍历结束\n```\n\n原生具备 Iterator 接口的数据结构如下。\n\n- Array\n\n- Map\n\n- Set\n\n- String\n\n- TypedArray\n\n- 函数的 arguments 对象\n\n- NodeList 对象\n\n上述数据结构不用自己写遍历器函数, `for...of`循环会自动进行遍历.\n\n```javascript\nlet arr = [3, 4, 5];\nfor(let i of arr) console.log(i);\n// 3\n// 4\n// 5\n```\n\n没有遍历器函数的数据结构, 可以根据实际需求进行手动部署, 即在`Symbol.iterator`属性上手写遍历器对象生成函数.\n\n\n\n# 解构赋值\n\n针对数组或者对象进行模式匹配, 然后对其中的变量进行赋值. 解构目标 = 解构源.\n\n## 数组的解构\n\n```javascript\n// 基本\nlet [a, b, c] = [1, 2, 3];\nconsole.log(a, b, c); // 1 2 3\n\n// 嵌套\nlet [a, [[b], c]] = [1, [[2], 3]];\nconsole.log(a, b, c); // 1 2 3\n\n// 可忽略\nlet [a, , c] = [1, 2, 3];\nconsole.log(a, c); // 1 3\n\n// 剩余运算符\nlet [a, ...b] = [1, 2, 3];\nconsole.log(a, b); // 1 [2, 3]\n```\n\n数组解构中, 若解构目标为可遍历对象(实现iterator接口的数据), 都可以进行解构赋值.\n\n```javascript\n// 字符串\nlet [a, b, c, ...d] = 'hello';\nconsole.log(a, b, c, d); // h e l [ 'l', 'o' ]\n```\n\n### 解构默认值\n\n解构匹配到`undefined`, 触发默认值作为返回结果.\n\n```javascript\n// 均匹配到 undefined\nlet [a = 2] = [undefined]; console.log(a); // 2\nlet [a = 3, b = a] = []; console.log(a, b); // 3 3\n// b 匹配到 undefined, 触发默认值 b=a=1\nlet [a = 3, b = a] = [1]; console.log(a, b); // 1 1\n// 正常解构赋值\nlet [a = 3, b = a] = [1, 9]; console.log(a, b); // 1 9\n```\n\n\n\n## 对象的解构\n\n\n\n```javascript\n// 报错\nlet { a, b } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(a, b); // undefined undefined\n// 报错\nlet { a: b } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(a, b); // ReferenceError: a is not defined\n// 报错\nlet { a } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(a); // undefined\n\n/* 正确使用 解构目标必须与key一致 */\n\nlet { hello, apple } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(hello, apple); // aaa bbb\n\nlet { hello: b } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(b); // aaa\n\nlet { hello } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(hello); // aaa\n\n/* 剩余运算符 */\n\nlet { a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 };\nconsole.log(a, b, rest); // 10 20 { c: 30, d: 40 }\n\n/* 解构默认值 */\n\nlet { hello = 3, apple = 5 } = { hello: 'aaa', apple: 'bbb' };\nconsole.log(hello, apple); // aaa bbb\n\n// apple 匹配到 undefined\nlet { hello = 3, apple = 5 } = { hello: 'aaa'};\nconsole.log(hello, apple); // aaa 5\n\nlet { hello: aa = 3, apple: bb = 5 } = {};\nconsole.log(aa, bb); // 3 5\n\nlet { hello: aa = 3, apple: bb = 5 } = { apple: 'aaa' };\nconsole.log(aa, bb); // 3 aaa\n```\n\n\n\n\n\n#  关键字 this\n\njs中`this`随着执行环境的变化而变化, 是函数运行时, 在函数体内部自动生成的一个对象, 只能在函数体内部使用. 即, **this 是函数运行时所在的环境对象**. 箭头函数不绑定自己的 `this` .\n\n## 单独使用\n\n无论有无严格模式, `this`始终指向全局对象. 浏览器中, 全局对象为`[object Window]`\n\n```javascript\n// 'use strict'\nconsole.log(this); // {}\n```\n\n## 纯粹的函数调用\n\n函数中, 默认`this`指向全局对象\n\n```javascript\nvar name = \"ok\";\nfunction test() {\n  console.log(this.name);\n}\ntest(); // ok\n\n\nlet fun = ()=>{\n\treturn this;\n}\nconsole.log(fun()); // {}\n```\n\n严格模式下不允许默认绑定, 所以函数中的`this`为`undefined`\n\n```javascript\n// 严格模式\n\"use strict\"\nfunction myFunction() {\n  return this;\n}\nconsole.log(myFunction()); // undefined\n```\n\n## 函数作为对象方法\n\n指向上级对象\n\n```javascript\nlet obj = {\n\tsize : 14,\n\tcolor: 'red',\n\tgetColor: function () {\n\t\treturn '颜色是' + this.color\n\t}\n}\n// 该实例中, this指向getColor方法所在的对象\nconsole.log(obj.getColor) // [Function: getColor]\nconsole.log(obj.getColor()) // 颜色是red (加括号表示调用方法)\n\n// 方法中的this单独打印, 会打印出所属对象的内容\nvar person = {\n  firstName  : \"John\",\n  lastName   : \"Doe\",\n  id         : 5566,\n  myFunction : function() {\n    return this;\n  }\n};\nconsole.log(person.myFunction()); \n\n/*\n{\n  firstName: 'John',\n  lastName: 'Doe',\n  id: 5566,\n  myFunction: [Function: myFunction]\n}\n*/\n```\n\n### 类方法中的 `this` 指向\n\n`speak` 方法中的 `this` 从打印结果来看, 指的是**构造函数生成的新对象**, 并未打印`speak`方法.\n\n但是 `this.speak` 却能够调用, 说明`this`不仅指向的是构造函数对应的对象, 而且在行为上也与构造函数的对象一致, 就是对象中找不到方法, 就去对象的原型中去找.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak () {\n    console.log(this.speak, this);\n  }\n}\n\nlet dog = new Animal();\n// 此时 speak 中的this指的是它的调用对象, 也就是 dog\n// speak 在打印 this.speak 时, 相当于打印 dog.speak, 但是 dog 本身是没有 speak 函数的\n// 只能去 dog 原型对象里去找, 最后找到了 speak 函数, 其实打印的是 dog 原型的 speak 函数\ndog.speak();\n// [Function: speak] Animal { name: undefined }\n\n\n// eat 中的 this 与 speak 中的 this 一样\n// 均是指构造函数对应的对象\nAnimal.prototype.eat = function () {\n  console.log(this);\n}\n\n// 下面 eat 在执行时, 均是指向调用 eat 方法的类的实例\n// 即 panda 和 cat\nlet panda = new Animal('panda');\npanda.eat(); // Animal { name: 'panda' }\nlet cat = new Animal('cat');\ncat.eat(); // Animal { name: 'cat' }\n```\n\n\n\n## 函数作为构造函数\n\n构造函数就是, 通过这个函数, 能够生成一个新对象. 此时, `this` 指向这个新对象.\n\n```javascript\nfunction test() {\n  this.x = 'hello';\n}\n\nvar obj = new test();\nconsole.log(obj.x); // hello\n\n\nvar x = \"ok\";\nfunction test() {\n  this.x = 'hello';\n}\n\nvar obj = new test();\nconsole.log(x); // ok 此时全局变量x的值没有变化, 说明 this 不是全局对象\n```\n\n## apply 调用\n\n`apply()`是函数的一个方法, 作用是改变函数的调用对象. 第一个参数表示改变后的调用这个函数的对象, 此时 `this` 指向这个参数.\n\n```javascript\nvar x = \"ok\";\n\nfunction test() {\n  console.log(this.x);\n}\n\nvar obj = {};\nobj.x = 'hi';\nobj.method= test;\n\n// 参数为空时, 默认 obj.method 这个方法的调用者修改为 全局对象.\nobj.method.apply(); // o.apply(); // ok\n\n// 修改 obj.method 这个方法的调用者为 obj, 则此时 obj.method 作为对象方法被调用\n// this 指向 obj\nobj.method.apply(obj); // hi\n```\n\n\n\n# 模块化\n\n## 概述\n\nES6之前使用 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。\n\nES6 引入了模块化，在编译时就能确定模块的依赖关系 + 输入和输出的变量。\n\nES6 的模块化 = 导出（export） 与导入（import）两个模块。\n\n## 特点\n\n自动开启严格模式\n\n模块中可以导入导出各种类型的变量, 如函数/对象/字符串/布尔值/类等.\n\n每个模块都有自己的上下文, 模块内声明的变量都是局部变量.\n\n每个模块只加载一次, 再去加载该模块, 则直接从内存中读取.\n\n## 用法\n\n导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 \n\nexport 命令可以出现在模块的任何位置，但必需处于模块顶层。\n\nimport 命令会提升到整个模块的头部，首先执行。\n\n### 基本用法\n\n```javascript\n/*-----export [test.js]-----*/\nlet myName = \"Tom\";\nlet myAge = 20;\nlet myfn = function(){\n    return \"My name is\" + myName + \"! I'm '\" + myAge + \"years old.\"\n}\nlet myClass =  class myClass {\n    static a = \"yeah!\";\n}\nexport { myName, myAge, myfn, myClass }\n// 建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口\n// 函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称\n\n/*-----import [xxx.js]-----*/\nimport { myName, myAge, myfn, myClass } from \"./test.js\";\nconsole.log(myfn());// My name is Tom! I'm 20 years old.\nconsole.log(myAge);// 20\nconsole.log(myName);// Tom\nconsole.log(myClass.a );// yeah!\n```\n\n### as 的用法\n\n```javascript\n/*-----export [test.js]-----*/\nlet myName = \"Tom\";\nexport { myName as exportName }\n \n/*-----import [xxx.js]-----*/\nimport { exportName } from \"./test.js\";\nconsole.log(exportName);// Tom\n// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量\n\n/*-----export [test1.js]-----*/\nlet myName = \"Tom\";\nexport { myName }\n\n/*-----export [test2.js]-----*/\nlet myName = \"Jerry\";\nexport { myName }\n\n/*-----import [xxx.js]-----*/\n// 不同模块导出接口名称命名重复， 使用 as 重新定义变量名。\nimport { myName as name1 } from \"./test1.js\";\nimport { myName as name2 } from \"./test2.js\";\nconsole.log(name1);// Tom\nconsole.log(name2);// Jerry\n```\n\n### import 命令的特点\n\n#### 只读属性\n\n#### 单例模式\n\n```javascript\nimport { a } \"./xxx.js\";\nimport { a } \"./xxx.js\";\n// 相当于 import { a } \"./xxx.js\"; 只执行一次\n \nimport { a } from \"./xxx.js\";\nimport { b } from \"./xxx.js\";\n// 相当于 import { a, b } from \"./xxx.js\"; 只执行一次\n```\n\n#### 静态执行特性\n\n`import` 静态执行, 不能使用表达式和变量.\n\n```javascript\nimport { \"f\" + \"oo\" } from \"methods\";\n// 表达式 error\n\nlet module = \"methods\";\nimport { foo } from module;\n// 变量 error\n\nif (true) {\n  import { foo } from \"method1\";\n} else {\n  import { foo } from \"method2\";\n}\n// error\n```\n\n### export default 命令\n\n在一个文件或者模块中, export/import可以有多个, export default 仅有一个。\n\n导出时不需要加{}\n\n```javascript\nvar a = \"My name is Tom!\";\nexport default a; // 仅有一个 不需要加{}\nexport default var c = \"error\"; \n// error，default 已经是对应的导出变量，不能跟着变量声明语句\n \nimport b from \"./xxx.js\"; // 不需要加{}， 使用任意变量接收\n```\n\n\n\n# 最佳实践\n\n1. 避免使用 全局变量 `new` `===` `eval()`\n\n2. 所有声明放在脚本或者函数的顶部, **顶部声明, 稍后使用**\n\n   ```javascript\n   // 在顶部声明\n   var firstName, lastName, price, discount, fullPrice;\n   \n   // 稍后使用\n   firstName = \"Bill\";\n   lastName = \"Gates\";\n   \n   price = 19.90;\n   discount = 0.10;\n   \n   fullPrice = price * 100 / discount;\n   ```\n\n3. 声明变量时同时初始化\n\n4. 将数值/字符串/布尔值声明为原始值而非对象, 否则会拖慢速度\n\n   ```javascript\n   let x = 'bill' // 字符串\n   let y = new String('bill') // 对象\n   console.log(x===y); // false\n   ```\n\n5. 请勿使用 new Object()\n\n|   推荐使用    |     不建议     |\n| :-----------: | :------------: |\n|      {}       |  new Object()  |\n|      []       |  new Array()   |\n| function (){} | new Function() |\n|      \"\"       |  new String()  |\n|       0       |  new Number()  |\n|     false     | new Boolean()  |\n|     /()/      |  new RegExp()  |\n\n6. 意识到自动类型转换, 变量可以通过赋值改变其数据类型, 变量可包含不同的数据类型.\n\n   ```javascript\n   let a = 'hello'\n   a = 5;\n   console.log(typeof a); // number\n   ```\n\n7. 为函数中的参数设置默认值, `undefined` 会破坏代码\n\n8. 用`default`来结束`switch`.\n\n\n\n# 缺陷与错误\n\n## 错误处理\n\n> 原因\n\njs代码中会出现错误, 由于编写代码/编译/用户输入等各种各样的原因.\n\n> 处理\n\n发生错误时, js引擎会停止并生成一个错误消息.\n\ntry与catch成对出现, finally是最后一定会执行的语句(可以没有).\n\nthrow抛出错误, 实际上就是抛出一个表示错误信息的字符串s, 因此可以自定义错误.\n\n在catch中可以捕获s,实际上就是可以获得s的值并打印出来.\n\n```javascript\ntest = (x) => {\n  try {\n    if (x === '') throw 'is kong'\n    if (x === '1') throw 'is 1'\n    if (x === '2') throw 'is 2'\n  } catch (error) {\n  \tconsole.log(error);\n  }\n}\ntest('1'); // is 1\ntest(''); // is kong\n```\n\n\n\n## 调试\n\n> 操作\n\n设置断点, 检查变量值, 浏览器内置调试器(按下F12, 选择`console`)\n\n> `debugger`关键字\n\n代码会在`debugger`行停下, 并执行调试函数. 没有调试函数则不起作用.\n\n与在调试工具中设置断点效果一样.\n\n\n\n## 严格模式\n\n> 原因\n\n`use strict` \n\n消除js语法的不合理之处, 保证代码安全; 增加编译效率;\n\n> 使用\n\n只能放在脚本或者函数的开头\n\n> 具体内容\n\n- 禁止使用未定义/声明的变量\n- 禁止删除变量/函数\n- 禁止变量重名\n- 禁止使用八进制/转义字符\n- 禁止对只读属性赋值\n- 禁止删除不能删除的属性, 比如prototype\n- 禁止变量名为eval/arguments\n- 禁止使用右侧类似语句 with (Math){x = cos(2)};\n- 禁止在作用域eval创建的变量被使用\n- 禁止this指向全局对象\n\n\n\n","slug":"JavaScript-Notes","published":1,"updated":"2020-10-30T10:04:45.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fag0000smm9h51e8gb85","content":"<h1 id=\"JavaScript-简介\"><a href=\"#JavaScript-简介\" class=\"headerlink\" title=\"JavaScript 简介\"></a>JavaScript 简介</h1><h2 id=\"诞生\"><a href=\"#诞生\" class=\"headerlink\" title=\"诞生\"></a>诞生</h2><p>本名 ECMAScript, 被创建的原因是, 在浏览器输入数据时需要进行验证, 而不是传到服务器才告知客户数据错误或者空白等, 于是被创建时诞生在 NetScape 浏览器中.  </p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>只能在浏览器中运行, 不能单独运行, 不能读取文件</p>\n<p>由浏览器中的执行模块(JS引擎)执行, 考虑到页面打开的速度, 不编译执行.</p>\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><h3 id=\"操作HTML的DOM\"><a href=\"#操作HTML的DOM\" class=\"headerlink\" title=\"操作HTML的DOM\"></a>操作HTML的DOM</h3><p>浏览器从服务器取到HTML页面之后, 会展示页面出来, 但是浏览器内部将HTML组织成一个树给JS, 这个树称为 DOM.</p>\n<img src=\"/2020/09/01/JavaScript-Notes/htmltree.jpg\" class=\"\" title=\"htmltree\">\n<p>JS可以定位并操作DOM中的任意一个节点, 且不用刷新页面, 操作就可以立刻显示出效果. 而且操作是内部进行, 并没有改变 html的源码.</p>\n<h3 id=\"控制浏览器\"><a href=\"#控制浏览器\" class=\"headerlink\" title=\"控制浏览器\"></a>控制浏览器</h3><p>打开窗口/在一个窗口内前进后退/获得浏览器名称+版本(判断是什么浏览器, 才能做这个浏览器支持的特殊操作)…</p>\n<h3 id=\"异步调用\"><a href=\"#异步调用\" class=\"headerlink\" title=\"异步调用\"></a>异步调用</h3><p>不能像java一样访问网络, 就不能调用服务器的接口去获取数据. 用户只能get或者post向服务器发送请求, 服务器返回整个页面, 而不是一个片段, 整个页面得重新刷新.</p>\n<p><code>XMLHttpRequest</code> 使得 JS 可以直接向服务器发起接口调用, 等获得服务器返回的数据(此时为<code>XML</code>)后执行浏览器提供的回调函数. Called 异步调用. 回调函数基本就是更新DOM树的某个节点, 实现网页的局部刷新. 后来上述的异步调用被称为 <code>AJAX</code> (Asynchronous JavaScript And XML).</p>\n<p>由于<code>XML</code>的标签太多, 真正数据很少, 而且需要XML解析器进行解析, 后来 <code>JS</code> 和服务器之间的数据传输使用 <code>JSON</code> 这种更简洁的格式.</p>\n<p>HTML 结构, CSS 展示, JS(AJAX JSON) 逻辑 = 前端. 可以在浏览器实现 <code>MVC</code>.</p>\n<p> 后来出现了多种框架, ExtJS/prototype/JQuery/AngularJS将前端推向另一个高峰. </p>\n<h2 id=\"JS-移动到服务器端\"><a href=\"#JS-移动到服务器端\" class=\"headerlink\" title=\"JS 移动到服务器端\"></a>JS 移动到服务器端</h2><p>需要满足下述两个要求:</p>\n<ol>\n<li><p>引擎移动到服务器端, 需要执行地足够快. Chrome V8</p>\n</li>\n<li><p>绕开 JAVA 服务器的问题, 即线程遇到IO/数据库/网络这样的耗时操作, 不能等待, 换成异步处理.</p>\n</li>\n</ol>\n<p>即后来出现的 node.js, 巨大优势就是: 前后端均使用JS开发.</p>\n<h3 id=\"Node-js-工作特点\"><a href=\"#Node-js-工作特点\" class=\"headerlink\" title=\"Node.js 工作特点\"></a>Node.js 工作特点</h3><p><strong>只用一个线程来处理所有请求, 事件驱动编程.</strong></p>\n<p>需要等待的操作, 会有一个回调函数在那, 线程不会等待. 操作一完成则发出事件通知线程, 线程立马回来执行对应的回调函数, 执行完回调函数再去接着执行那些不需要等待的操作.</p>\n<p>即: 需要等待的操作先跳过, 先去执行那些不需要等待的操作, 耗时操作完成后事件通知线程后, 线程再立即回来执行其对应的回调函数. 事件驱动编程, 有需要处理的事件才去处理, 耗时操作先跳过.</p>\n<a id=\"more\"></a>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><h2 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h2><h3 id=\"布尔值-Boolean\"><a href=\"#布尔值-Boolean\" class=\"headerlink\" title=\"* 布尔值 Boolean\"></a>* 布尔值 Boolean</h3><p>true/false</p>\n<h3 id=\"字符串-String\"><a href=\"#字符串-String\" class=\"headerlink\" title=\"* 字符串 String\"></a>* 字符串 String</h3><h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"string\">'hello'</span>; <span class=\"comment\">// 字面量创建</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> thing = <span class=\"number\">98</span>; <span class=\"comment\">// 任何可以转换成字符串的值</span></span><br><span class=\"line\"><span class=\"comment\">/* String 函数 生成或者将值转换为字符串 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">String</span>(thing); <span class=\"comment\">// 将thing转换为原始字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s3 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(thing); <span class=\"comment\">// 新建String对象, 并存储thing的字符串表示</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1, <span class=\"keyword\">typeof</span> s1); <span class=\"comment\">// hello string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s2, <span class=\"keyword\">typeof</span> s2); <span class=\"comment\">// 98 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s3, <span class=\"keyword\">typeof</span> s3); <span class=\"comment\">// [String: '98'] object</span></span><br></pre></td></tr></table></figure>\n<p>字符串一旦创建, 其内容不可被修改, 只能重新被赋值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">str[<span class=\"number\">1</span>] = <span class=\"string\">'*'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str, str[<span class=\"number\">1</span>]); <span class=\"comment\">// hello e</span></span><br><span class=\"line\">str = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// world</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p><code>length</code></p>\n<p>字符串长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.length); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p><code>constructor</code></p>\n<p>对创建该对象的函数的引用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.constructor); <span class=\"comment\">// [Function: String]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"处理\"><a href=\"#处理\" class=\"headerlink\" title=\"处理\"></a>处理</h5><p><code>toUpperCase</code>  </p>\n<p>字符串变大写</p>\n<p><code>toLowerCase</code>  </p>\n<p>字符串变小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hello'</span>, t = <span class=\"string\">'JINLING'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.toUpperCase(), s); <span class=\"comment\">// HELLO hello</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(t.toLowerCase(), t); <span class=\"comment\">// jinling JINLING</span></span><br></pre></td></tr></table></figure>\n<p><code>trim</code></p>\n<p>去除字符串两边的空白. 原字符串未改变.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"   hello   *   \"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.trim(), <span class=\"string\">', |'</span> + str + <span class=\"string\">'|'</span>); <span class=\"comment\">// hello   * , |   hello   *   |</span></span><br></pre></td></tr></table></figure>\n<p><code>split</code> </p>\n<p>根据分隔符将字符串分割为数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hel,l,o'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 不切割 整个字符串视作数组的一个元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.split());  <span class=\"comment\">// [ 'hel,l,o' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 每个字符都是数组中的元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.split(<span class=\"string\">''</span>));</span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\"> 'h', 'e', 'l',</span></span><br><span class=\"line\"><span class=\"comment\"> ',', 'l', ',',</span></span><br><span class=\"line\"><span class=\"comment\"> 'o'</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 以逗号分割</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.split(<span class=\"string\">','</span>), s); <span class=\"comment\">// [ 'hel', 'l', 'o' ] hel,l,o</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h5><p><code>indexOf</code></p>\n<p>查找字符串中有无指定字符串, 有则返回下标, 没有则返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"hello jinling!\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> res1  = s.indexOf(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2  = s.indexOf(<span class=\"string\">\"jin\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1, res2); <span class=\"comment\">// -1 6</span></span><br></pre></td></tr></table></figure>\n<p><code>includes</code></p>\n<p>查找字符串是否包含指定子串, 有则返回<code>true</code>, 反之<code>false</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"hello jinling good\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.includes(<span class=\"string\">\"hello\"</span>), str.includes(<span class=\"string\">\"world\"</span>)); <span class=\"comment\">// true false</span></span><br></pre></td></tr></table></figure>\n<p><code>charAt</code></p>\n<p>返回字符串中对应下标的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"hello*jinling!\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ch = s.charAt(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ch); <span class=\"comment\">// *</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"拼接-截取\"><a href=\"#拼接-截取\" class=\"headerlink\" title=\"拼接/截取\"></a>拼接/截取</h5><p><code>concat</code></p>\n<p>拼接两个或者更多字符串, 返回新字符串, 不改变原字符串.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"string\">\"hello\"</span>, s2 = <span class=\"string\">\"*go\"</span>, s3 = <span class=\"string\">\"*hhh\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = s1.concat(s2, s3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s, s1, s2, s3) <span class=\"comment\">// hello*go*hhh hello *go *hhh</span></span><br></pre></td></tr></table></figure>\n<p><code>slice</code></p>\n<p>截取字符串的片段, 不改变原字符串.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"helloWorld\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = str.slice(<span class=\"number\">3</span>, <span class=\"number\">7</span>); <span class=\"comment\">// [起始位置, 结束位置)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s, str); <span class=\"comment\">// loWo helloWorld</span></span><br></pre></td></tr></table></figure>\n<p><code>substring</code></p>\n<p>截取字符串的片段, 不改变原字符串.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'helloWorld'</span>;</span><br><span class=\"line\"> <span class=\"comment\">// [起始位置, 结束位置)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.substring(<span class=\"number\">1</span>, <span class=\"number\">8</span>), s); <span class=\"comment\">// elloWor helloWorld</span></span><br></pre></td></tr></table></figure>\n<p><code>substr</code></p>\n<p>截取指定长度的子串. (ps. ECMAscript 没有对该方法进行标准化，因此反对使用它。)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'helloWorld'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 起始位置 截取长度</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.substr(<span class=\"number\">1</span>, <span class=\"number\">4</span>), s); <span class=\"comment\">// ello helloWorld</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数字-Number\"><a href=\"#数字-Number\" class=\"headerlink\" title=\"* 数字 Number\"></a>* 数字 Number</h3><p>数字可以是数字或者对象, Number 对象是原始数值的包装对象. JS只有一种数字类型.</p>\n<h4 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 基础类型创建 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> k = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> k); <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"comment\">// 科学计数法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"number\">123e5</span>, k = <span class=\"number\">123e-5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> t, t, <span class=\"keyword\">typeof</span> k, k); <span class=\"comment\">// number 12300000 number 0.00123</span></span><br><span class=\"line\"><span class=\"comment\">// 八进制以0开头</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">0122</span>; <span class=\"comment\">// 数字以 0 开头, 且后面的数字都比8小, 则js解释为八进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 82</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">0888</span>; <span class=\"comment\">// 后面数字&gt;=8, 则依然解释为十进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 888</span></span><br><span class=\"line\"><span class=\"comment\">// 十六进制以0x开头</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">0x11</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 对象形式创建 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"99\"</span>), n = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> m, m, <span class=\"keyword\">typeof</span> n, n); </span><br><span class=\"line\"><span class=\"comment\">// object [Number: 99] object [Number: 10]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"kill\"</span>); <span class=\"comment\">// 不能转换为数字时</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> t, t); <span class=\"comment\">// object [Number: NaN]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>返回对创建此对象的 Number 函数的引用.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.constructor); <span class=\"comment\">// [Function: Number]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p><code>toString</code></p>\n<p>将数字转变为字符串, 使用指定的基数.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"99\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = t.toString();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// string 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用指定的基数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"10\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = t.toString(<span class=\"number\">2</span>); <span class=\"comment\">// 十进制转变为二进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// 1010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"10\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = t.toString(<span class=\"number\">8</span>); <span class=\"comment\">// 十进制转变为八进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str, str); string <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<p><code>valueOf</code></p>\n<p>返回一个 Number 对象的基本数字值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"99\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(t.valueOf()); <span class=\"comment\">// 99</span></span><br></pre></td></tr></table></figure>\n<p><code>isFinite</code></p>\n<p>判断参数是否为无穷大</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">123</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">-1.23</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">5</span><span class=\"number\">-2</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'123'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'2005/12/12'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(-<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0</span> / <span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">NaN</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>isNaN</code></p>\n<p>使用全局函数判断<code>NaN</code>(教程推荐).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(a), <span class=\"built_in\">isNaN</span>(<span class=\"number\">8</span>), <span class=\"built_in\">isNaN</span>(<span class=\"string\">\"11\"</span>)); <span class=\"comment\">// true false false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Symbol-ES6\"><a href=\"#Symbol-ES6\" class=\"headerlink\" title=\"* Symbol (ES6)\"></a>* Symbol (ES6)</h3><p>基本数据类型, ES6新增, 表示独一无二的值. 由于 ES5 对象的属性名只能是字符串, 容易造成属性名的冲突, 需要独一无二的值.</p>\n<p>具有静态属性与静态方法. 模拟对象私有属性.</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>通过<code>Symbol</code>函数产生.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受字符串作为参数, 表示对Synbol实例的描述, 主要为了在控制台显示或者转为字符串时容易被区分.</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(**description?: string | number**): symbol</span><br><span class=\"line\"></span><br><span class=\"line\">Description <span class=\"keyword\">of</span> the <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span> object.</span><br><span class=\"line\"></span><br><span class=\"line\">Returns a <span class=\"keyword\">new</span> unique <span class=\"built_in\">Symbol</span> value.</span><br></pre></td></tr></table></figure>\n<p>每个从 Symbol 返回的symbol值都是唯一的, 尽管参数相同.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>(<span class=\"number\">34</span>); </span><br><span class=\"line\"><span class=\"comment\">// Symbol 不会将'hello'转变为symbol类型, 每次创建一个新的symbol类型.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'hello'</span>); </span><br><span class=\"line\"><span class=\"keyword\">let</span> sym3 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'hello'</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> sym, sym); <span class=\"comment\">// symbol Symbol()</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sym1 == <span class=\"number\">34</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sym2 == <span class=\"string\">'hello'</span>, sym2, sym2.toString()); <span class=\"comment\">// false Symbol(hello) 'Symbol(hello)'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sym2 === sym3); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code>可以转换为<strong>字符串</strong>以及<strong>布尔值</strong>, 但是不能转换为数值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'happy'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1.toString(), <span class=\"built_in\">String</span>(s1)); <span class=\"comment\">// Symbol(happy) Symbol(happy)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'happy'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Boolean</span>(s1)); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'happy'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(s1)); <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure>\n<p>对原始数据类型创建一个显式包装器对象从ES6开始不再被支持, 但是原有的 new Boolean/new String/new Number 由于遗留原因仍然可以被创建.</p>\n<p>如果真的想创建一个Symbol包装器, 可以使用Object()函数.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// symbol 是原始数据类型 不是对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">// TypeError: Symbol is not a constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"number\">34</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> sym); <span class=\"comment\">// symbol</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> symObj = <span class=\"built_in\">Object</span>(sym);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> symObj); <span class=\"comment\">// object</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为属性名\"><a href=\"#作为属性名\" class=\"headerlink\" title=\"作为属性名\"></a>作为属性名</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj[mySymbol] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [mySymbol]: <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将对象的属性名指定为一个 Symbol 值</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, mySymbol, &#123; <span class=\"attr\">value</span>: <span class=\"string\">'hello'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三种写法 同样结果</span></span><br><span class=\"line\">obj[mySymbol] <span class=\"comment\">// 'hello'</span></span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code> 作为对象属性时, 不能使用点运算符, 只能使用方框<code>[]</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj[mySymbol] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">obj.mySymbol = <span class=\"string\">'hi'</span>; <span class=\"comment\">// 相当于属性名为 'mySymbol' 字符串</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.mySymbol); <span class=\"comment\">// hi</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[mySymbol]); <span class=\"comment\">// hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 作为对象属性, 只能使用方框</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增强的对象写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s] (arg) &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"* null\"></a>* null</h3><p><code>null</code> : 表示主动释放指向对象的引用.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">a = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 释放指向数组的引用</span></span><br></pre></td></tr></table></figure>\n<p>设计之初, <code>null</code> 像在java里一样, 被当成一个<strong>对象</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>); <span class=\"comment\">// object</span></span><br></pre></td></tr></table></figure>\n<p>可以自动转为 0 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>), <span class=\"number\">8</span> + <span class=\"literal\">null</span>); <span class=\"comment\">// 0 8</span></span><br></pre></td></tr></table></figure>\n<p><strong>用法: null 表示”没有对象”, 即 该处不应该有值.</strong></p>\n<ol>\n<li>作为函数的参数, 表示该函数的参数不是对象</li>\n<li>作为对象原型链的终点</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"* undefined\"></a>* undefined</h3><p>Brendan Eich 觉得, 表示’无’的值, 最好不是对象. 其次, 由于js初版本没有错误处理机制, null 自动转为 0 不容易发现错误. 于是 Brendan Eich又设计了一个<code>undefined</code>.</p>\n<p>一开始 <code>undefined</code> 被设计为表示’无’的原始值, 转为数字时为 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">undefined</span>), <span class=\"number\">8</span> + <span class=\"literal\">undefined</span>); <span class=\"comment\">// NaN NaN</span></span><br></pre></td></tr></table></figure>\n<p><strong>用法: undefined 表示”缺少值”, 就是此处应该有一个值, 但是还没有定义.</strong></p>\n<ol>\n<li>变量被声明过, 但是没有赋值, 等于 undefined</li>\n<li>调用函数时, 应该提供的参数没有提供, 则该参数为 undefined</li>\n<li>对象没有赋值的属性, 该属性值为 undefined</li>\n<li>函数没有返回值时, 默认返回 undefined.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用法 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b); <span class=\"comment\">// undefined undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法 3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法 4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"undefined-与-null-区别\"><a href=\"#undefined-与-null-区别\" class=\"headerlink\" title=\"undefined 与 null 区别\"></a>undefined 与 null 区别</h4><p>两者使用 == 时为true, === 时为false.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span> == <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span> === <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// true false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在if语句中, 两者都被转成 false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"literal\">undefined</span>) <span class=\"built_in\">console</span>.log(<span class=\"string\">'undefined if false'</span>); <span class=\"comment\">// undefined if false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"literal\">null</span>) <span class=\"built_in\">console</span>.log(<span class=\"string\">'null if false'</span>); <span class=\"comment\">// null if false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><h3 id=\"数组-Array\"><a href=\"#数组-Array\" class=\"headerlink\" title=\"* 数组 Array\"></a>* 数组 Array</h3><h4 id=\"创建-2\"><a href=\"#创建-2\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = []; <span class=\"comment\">// 字面</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(); <span class=\"comment\">// 不固定长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">5</span>); <span class=\"comment\">// 固定长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0, arr1, arr2, arr3); <span class=\"comment\">// [] [] [ &lt;5 empty items&gt; ] [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"其他数据类型转数组\"><a href=\"#其他数据类型转数组\" class=\"headerlink\" title=\"其他数据类型转数组\"></a>其他数据类型转数组</h4><p>set-&gt;Array</p>\n<p>Array.from(set)</p>\n<p>string-&gt;Array</p>\n<h4 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p><code>length</code></p>\n<blockquote>\n<p>计算并返回数组长度</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]; <span class=\"comment\">// 字面</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.length); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p><code>constructor</code></p>\n<blockquote>\n<p>返回创建该对象的函数的引用, 因为js的一切变量都是对象, 是对象就有其构造函数.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (test.constructor==<span class=\"built_in\">Array</span>)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.write(test.constructor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output: function Array() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"改变原数组\"><a href=\"#改变原数组\" class=\"headerlink\" title=\"改变原数组\"></a>改变原数组</h5><p><strong>Array.sort()</strong></p>\n<blockquote>\n<p>对数组元素进行排序, 默认是字符串顺序.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照字母顺序排序 默认</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'good'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 'Bob', 'are', 'good', 'google', 'hi', 'you' ]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>添加比值函数, 使得能对<strong>数字进行排序</strong>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不使用比值函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">76</span>, <span class=\"number\">91</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\">  0,  1, 12,  3, 34,</span></span><br><span class=\"line\"><span class=\"comment\">  7, 76,  9, 91</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用比值函数 倒序</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">76</span>, <span class=\"number\">91</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b - a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\">  91, 76, 34, 12, 9,</span></span><br><span class=\"line\"><span class=\"comment\">   7,  3,  1,  0</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用比值函数 正序</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">76</span>, <span class=\"number\">91</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\">   0,  1,  3,  7, 9,</span></span><br><span class=\"line\"><span class=\"comment\">  12, 34, 76, 91</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.pop()</strong></p>\n<blockquote>\n<p>删除数组的最后一个元素并返回该元素. 空数组返回<code>undefined</code>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.pop(), arr0);</span><br><span class=\"line\"><span class=\"comment\">// output: 4 [ 1, 2, 3 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.pop(), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: undefined []</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.shift()</strong></p>\n<blockquote>\n<p>删除并返回数组的第一个元素</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.shift(), arr1);</span><br><span class=\"line\"><span class=\"comment\">// 1 [ 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.unshift()</strong></p>\n<blockquote>\n<p>向数组的开头添加元素并返回现有长度</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.unshift(<span class=\"number\">9</span>), arr1);</span><br><span class=\"line\"><span class=\"comment\">// 6 [ 9, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.push()</strong></p>\n<blockquote>\n<p>向数组末尾添加元素并返回数组现有长度</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.push(<span class=\"number\">4</span>), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: 4 [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.reverse()</strong></p>\n<blockquote>\n<p>颠倒数组中元素顺序</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.reverse(), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: [ 3, 2, 1 ] [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.splice()</strong> </p>\n<blockquote>\n<p>推荐使用该方法删除数组元素</p>\n<p>注意: 删除的元素以数组形式返回.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>); <span class=\"comment\">// 从数组下标为2的位置开始删除1个元素,再插入2个元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 1, 2, 'ok', 'fine', 4, 5 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不留空洞地删除元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"comment\">// 从下标为3的位置开始, 删除2个元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">3</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// ['fine', 'you'] 注意这里是数组形式!</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 1, 2, 'ok', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>delete</strong>  </p>\n<p>JS运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">delete</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>], arr); <span class=\"comment\">// 留下了空洞</span></span><br><span class=\"line\"><span class=\"comment\">// undefined [ &lt;1 empty item&gt;, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"不改变原数组\"><a href=\"#不改变原数组\" class=\"headerlink\" title=\"不改变原数组\"></a>不改变原数组</h5><p><strong>Array.slice()</strong></p>\n<blockquote>\n<p>根据下标获取数组的一部分, 返回新数组.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.slice(<span class=\"number\">3</span>), arr1.slice(<span class=\"number\">2</span>,<span class=\"number\">4</span>), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: [ 4, 5 ] [ 3, 4 ] [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.concat()</strong></p>\n<blockquote>\n<p>拼接数组成一个新数组</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.concat(arr1), arr0, arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: [ 1, 2, 3, 4, 5, 6 ] [ 1, 2, 3, 4 ] [ 5, 6 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.flat()</strong></p>\n<blockquote>\n<p>按照指定的深度递归遍历数组, 将所有元素与遍历到的子数组中的元素合并为一个<strong>新数组</strong>返回.</p>\n<p>将数组扁平化</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 默认递归深度为1 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = arr.flat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1, arr);</span><br><span class=\"line\"><span class=\"comment\">// [ 1, 2, 'ok', 'fine' ] [ 1, 2, [ 'ok', 'fine' ] ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 移除数组空项</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>, , , <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.flat());</span><br><span class=\"line\"><span class=\"comment\">// [ 1, 2, null, undefined, 5 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 指定递归深度 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [[[<span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.flat(<span class=\"number\">2</span>), arr.flat(<span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">// [ 1, 2, [ 'ok', 'fine' ] ] [ 1, 2, 'ok', 'fine' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.join()</strong>  默认使用 <code>,</code> 为分隔符</p>\n<blockquote>\n<p><code>toString</code> 所有 JavaScript 对象都拥有<code>toString()</code>方法</p>\n<p>数组所有元素组成字符串, 可以指定分隔符.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.join(), arr0.toString()); <span class=\"comment\">// 1,2,3,4  1,2,3,4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.join(<span class=\"string\">'*'</span>)); <span class=\"comment\">// 1*2*3*4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0); <span class=\"comment\">// [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.map()</strong></p>\n<blockquote>\n<p>对数组的每个元素均执行函数, 对其做一些处理, 来生成新数组. <strong>不改变原数组</strong>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = arr.map(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val + <span class=\"string\">'*'</span> + index;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 原数组不变</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2, arr);</span><br><span class=\"line\"><span class=\"comment\">// [ '1*0', '2*1', 'ok*2', 'fine*3', 'you*4', 'bye*5' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = arr.map(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [ 0, 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.filter()</strong></p>\n<blockquote>\n<p>对数组的每个元素均执行函数, 筛选符合条件的元素来生成新数组.<strong>不改变原数组</strong>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = arr.filter(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2, arr);</span><br><span class=\"line\"><span class=\"comment\">// [ 'ok', 'fine', 'you', 'bye' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.forEach()</strong></p>\n<blockquote>\n<p>对数组的每个元素均执行一次函数(回调函数)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// 该函数的参数1为数组元素,参数2为数组元素下标,参数3为该数组本身</span></span><br><span class=\"line\">arr.forEach(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  s += (val + <span class=\"string\">'/'</span> + index + <span class=\"string\">' '</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s); <span class=\"comment\">// 1/0 2/1 ok/2 fine/3 you/4 bye/5</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.reduce()</strong></p>\n<blockquote>\n<p>参数<code>total</code> 默认是数组的第一个元素, 可以设置初始值.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'bye'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.reduce(<span class=\"function\">(<span class=\"params\">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"total=\"</span>, total, val, index); <span class=\"comment\">// 从index=1开始打印</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + <span class=\"string\">'*'</span> + val;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">total= bye hi 1</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi ok 2</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi*ok fine 3</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi*ok*fine you 4</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi*ok*fine*you bye 5</span></span><br><span class=\"line\"><span class=\"comment\">bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置total初始值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'bye'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.reduce(<span class=\"function\">(<span class=\"params\">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + <span class=\"string\">'*'</span> + val;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"this is :\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// this is :*bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.reduceRight()</strong></p>\n<blockquote>\n<p>类似于<code>Array.reduce()</code>, 只不过是从右往左遍历元素.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'bye1'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye2'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.reduceRight(<span class=\"function\">(<span class=\"params\">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + <span class=\"string\">'*'</span> + val;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"this is res:\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// this is res:*bye2*you*fine*ok*hi*bye1 [ 'bye1', 'hi', 'ok', 'fine', 'you', 'bye2' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.every()</strong></p>\n<blockquote>\n<p>检查数组中的元素是否<strong>都符合条件</strong>, 都符合才返回true, 否则返回false.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有元素不符合条件 false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.every(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// false [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有元素均符合条件 true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.every(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'number'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// true [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.some()</strong></p>\n<blockquote>\n<p>检查是否<strong>有元素符合条件</strong>, 有则返回true, 没有则返回false.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有元素符合条件 true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.some(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// true [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有元素均不符合条件 false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.some(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// false [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.indexOf()</strong></p>\n<blockquote>\n<p>找到给定元素在数组中第一次出现的位置, 没有则返回-1, 找到则返回元素下标.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找不到 -1, 找到就下标</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.indexOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2 = arr.indexOf(<span class=\"string\">'how'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1, res2); <span class=\"comment\">// -1 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素多次出现 返回第一次出现的位置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2 = arr.indexOf(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res2); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定搜索位置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2 = arr.indexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res2); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 搜索起始位置可以是负值</span></span><br><span class=\"line\"><span class=\"comment\">// 负值是从数组末尾给定位置开始搜索, 直至末尾.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.indexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">-1</span>), <span class=\"comment\">// 从倒数第一个位置开始, 搜索不到</span></span><br><span class=\"line\">    res2 = arr.indexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">-2</span>); <span class=\"comment\">// 从倒数第二个位置开始搜索, 是可以检索到的, 返回正数下标</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1, res2); <span class=\"comment\">// -1 5</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.lastIndexOf()</strong></p>\n<blockquote>\n<p>与上一个类似, 只是从数组末尾开始检索.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 出现两次Bob, 但是返回了从右往左的第一个.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.lastIndexOf(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设定搜索起始位置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.lastIndexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">-3</span>); <span class=\"comment\">// 从倒数第三个元素开始往左搜索, 返回匹配的第一个元素的下标</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.find()</strong></p>\n<blockquote>\n<p>返回符合条件的第一个元素</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'good'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.find(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val.length &gt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// good</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.findIndex()</strong></p>\n<blockquote>\n<p>返回符合条件的第一个元素<strong>下标</strong></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'good'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.findIndex(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val.length &gt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h4><h5 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h5><p>利用键本身的不可重复性</p>\n<blockquote>\n<p>利用ES6 Set 去重 (ES6中最常用)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res); <span class=\"comment\">// [ 1, 2, 3 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简易写法</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>(arr)]</span><br></pre></td></tr></table></figure>\n<p>双层循环法 </p>\n<blockquote>\n<p>splice去重(ES5 常用)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 每一个元素都向后检查有没有与自己相同的元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有 则删除第二个元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于splice的特性 删除后 需要j-- 保证j指向被删除元素的下一个元素而不会遗漏元素</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] === arr[j]) &#123; <span class=\"comment\">// 注意使用===, 因为 null === undefined 为true</span></span><br><span class=\"line\">        arr.splice(j, <span class=\"number\">1</span>);</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">unique(arr1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'arr1:'</span>, arr1); <span class=\"comment\">// arr1: [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用 fliter+indexOf</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.filter(<span class=\"function\">(<span class=\"params\">val, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回符合条件的元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回所有第一次出现的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.indexOf(val, <span class=\"number\">0</span>) == index;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = unique(arr1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'res:'</span>, res);</span><br><span class=\"line\"><span class=\"comment\">// res: [ 1, 2, 3, null, undefined ]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Map-ES6\"><a href=\"#Map-ES6\" class=\"headerlink\" title=\"* Map (ES6)\"></a>* Map (ES6)</h3><p>解决js对象的键只能是字符串的问题, <strong>ES6标准新增</strong>的数据类型.</p>\n<h4 id=\"创建-添加-删除-是否包含\"><a href=\"#创建-添加-删除-是否包含\" class=\"headerlink\" title=\"创建/添加/删除/是否包含\"></a>创建/添加/删除/是否包含</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Michael'</span>, <span class=\"number\">90</span>], [<span class=\"string\">'Bob'</span>, <span class=\"number\">80</span>], [<span class=\"string\">'Lily'</span>, <span class=\"number\">95</span>]]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'Lily'</span>)); <span class=\"comment\">// 95</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map); <span class=\"comment\">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80, 'Lily' =&gt; 95 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个空map, 然后添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">'Michael'</span>, <span class=\"number\">90</span>); <span class=\"comment\">// 添加Key</span></span><br><span class=\"line\">map.set(<span class=\"string\">'Bob'</span>, <span class=\"number\">80</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">'Lily'</span>, <span class=\"number\">95</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map); <span class=\"comment\">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80, 'Lily' =&gt; 95 &#125;</span></span><br><span class=\"line\">map.delete(<span class=\"string\">'Lily'</span>); <span class=\"comment\">// 删除 key</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map); <span class=\"comment\">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 判断是否包含某key</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(<span class=\"string\">'hello'</span>), map.has(<span class=\"string\">'Bob'</span>)); <span class=\"comment\">// false true</span></span><br><span class=\"line\"><span class=\"comment\">// 获取值</span></span><br><span class=\"line\"><span class=\"comment\">// 一个key只对应一个value, 重复设置会覆盖之前的值</span></span><br><span class=\"line\">map.set(<span class=\"string\">'Bob'</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'Bob'</span>)); <span class=\"comment\">// 100</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Set-ES6\"><a href=\"#Set-ES6\" class=\"headerlink\" title=\"* Set (ES6)\"></a>* Set (ES6)</h3><p>一组不重复key的集合.ES6标准新增的数据类型.</p>\n<h4 id=\"创建-添加-删除-是否包含-1\"><a href=\"#创建-添加-删除-是否包含-1\" class=\"headerlink\" title=\"创建/添加/删除/是否包含\"></a>创建/添加/删除/是否包含</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组作为输入</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set1 = <span class=\"keyword\">let</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1); <span class=\"comment\">// Set &#123; 5, 6, 7, 8 &#125; 重复元素被自动过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化空Set, 再添加值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set();</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(1); // 添加元素</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(2);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(3);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(4);</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>); //Set &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">set</span>.delete(3); // 删除元素</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>); // Set &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(4); // 可以添加重复元素 但是无效</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>); // Set &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// '4' 与 4 不同</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">set</span>.has('4'), <span class=\"keyword\">set</span>.has(4)); // false true</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"* 函数\"></a>* 函数</h3><p>函数定义是一个常规的绑定,  其中绑定的值是函数. </p>\n<p>函数的第一种表示法.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 大括号必要, 末尾建议带分号</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>函数也是值的一种, 可以被赋值给多个变量/作为参数传递给函数等.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'1111'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1(); <span class=\"comment\">// 1111</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// func1 可以被绑定为其他函数</span></span><br><span class=\"line\">func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'2222'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1 <span class=\"comment\">// 2222</span></span><br></pre></td></tr></table></figure>\n<p>没有 <code>return</code> 语句或 <code>return</code> 后面没有返回值, 函数将返回 <code>undefined</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func1()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> func2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func2()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>每个局部作用域可以查看包含它的局部作用域, 所有局部作用域都能看见全局作用域.</p>\n<h4 id=\"声明表示法\"><a href=\"#声明表示法\" class=\"headerlink\" title=\"声明表示法\"></a>声明表示法</h4><p>函数的第二种表示法.</p>\n<p>声明在调用之后也能够工作, 声明在概念上被移到了作用域的顶部.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 不需要分号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><p>函数的第三种表示法. 以较简明的方式编写小型函数表达式.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两种写法相同</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> square1 = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square2 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h4><p>函数返回时必须跳回到调用它的位置, 所以计算机必须记住调用发生的上下文. 存储此上下文的位置是调用栈, 每次调用函数时, 当前上下文都存储在此栈的顶部.</p>\n<h4 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h4><p>多余参数自动忽略, 不足参数为 <code>undefined</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> square1 = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square1(<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"string\">'helloo'</span>[<span class=\"number\">2</span>, <span class=\"number\">3</span>]), square1(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2 7</span></span><br><span class=\"line\"><span class=\"comment\">// 2 undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 14 NaN</span></span><br></pre></td></tr></table></figure>\n<p>参数设定默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> square1 = <span class=\"function\">(<span class=\"params\">x, y = <span class=\"number\">3</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square1(<span class=\"number\">2</span>, <span class=\"number\">7</span>), square1(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2 7</span></span><br><span class=\"line\"><span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"comment\">// 14 6</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><p>定义了一个函数激活执行的时候, 去哪里找变量的值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunc</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> desc = <span class=\"string\">' is eating'</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eat</span> (<span class=\"params\">animal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(animal.name + desc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> eat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'dog'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> eat = createFunc();</span><br><span class=\"line\"><span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> desc = <span class=\"string\">'吃东西'</span>;</span><br><span class=\"line\">eat(dog); <span class=\"comment\">// dog is eating</span></span><br></pre></td></tr></table></figure>\n<p><code>eat</code> 函数的作用域链如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eat函数作用域[parent作用域-A]</span><br><span class=\"line\"></span><br><span class=\"line\">A = createFunc作用域[desc: <span class=\"string\">' is eating'</span>, <span class=\"attr\">eat</span>: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">func</span> 定义&gt;</span>, parent作用域-B]</span></span><br><span class=\"line\"></span><br><span class=\"line\">B = Global作用域[desc: '吃东西', createFunc: &lt;func 定义&gt;, parent作用域-null]</span><br></pre></td></tr></table></figure>\n<p>eat 函数中没有定义 <code>desc</code> 这个变量值, 就沿着作用域链去找, 在 <code>createFunc</code> 作用域中找到了 <code>desc</code> 变量的值, 于是就使用了.如果还没有找到, 就接着往上找.</p>\n<p>当执行 <code>createFunc</code> 的时候, <code>eat</code> 函数被创建, 此时 eat 函数会把外部函数的作用域链记录下来, 留到执行时使用. </p>\n<p>注意: 作用域链是<strong>函数创建时刻</strong>发生关联的, 不是运行时刻. Called <strong>静态作用域/词法作用域</strong>. 函数被创建即函数被定义.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 此处 foo 函数被创建, 与全局作用域相关联</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  func();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// foo 函数执行时直接去全局作用域找 x 变量</span></span><br><span class=\"line\">bar(foo); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>静态作用域是实现闭包的必需条件.</p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包在 JS 中就是一个以函数和以静态方式存储的父作用域的一个集合体.</p>\n<p>能够<strong>读取函数局部变量的函数</strong>就是闭包. 下面例子中, <code>func2</code>函数就是闭包.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> func2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> func = func1();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func()); <span class=\"comment\">// 999</span></span><br></pre></td></tr></table></figure>\n<p>用途: 读取函数内部变量 / 让这些变量的值始终保持在内存中.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nAdd;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">999</span>;</span><br><span class=\"line\">  nAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>,a);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> func2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> func = func1(); <span class=\"comment\">// 闭包函数</span></span><br><span class=\"line\">func(); <span class=\"comment\">// a 999</span></span><br><span class=\"line\">nAdd();</span><br><span class=\"line\">func(); <span class=\"comment\">// a 1000</span></span><br></pre></td></tr></table></figure>\n<p>证明了<code>func1</code>的局部变量<code>a</code>一直在内存中, 并没有在func1被调用后被自动清除. </p>\n<p>因为<code>func1</code>是<code>func2</code>的父函数, 而<code>func2</code>被赋予了局部变量<code>func</code>, 导致<code>func2</code>一直在内存中, 则<code>func2</code>依赖的<code>func1</code>也一直在内存中, 不会在调用结束后, 被垃圾回收机制回收.</p>\n<p>这里<code>nAdd</code>也是一个匿名函数, 也是一个闭包, 相当于一个setter, 可以在函数外部对函数内部局部变量进行操作.</p>\n<p>使用闭包的注意点:</p>\n<ol>\n<li>闭包会使函数中的局部变量在内存中, 因此会使得内存占用过多, 不能滥用. 在退出函数前, 将不使用的局部变量全部删除.</li>\n<li>闭包会在函数外部, 改变父函数内部变量的值, 注意不要随便改变.</li>\n</ol>\n<p>思考题:</p>\n<ol>\n<li><code>this</code> 在函数中而不是方法中使用时, 指向全局对象</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> object = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"My Object\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  getNameFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里直接在 vscode 中执行, 所以打出来是 undefined, 可能原本是 The Window</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(object.getNameFunc()()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this 打印出来如下</span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">Object [global] &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  global: [Circular],</span></span><br><span class=\"line\"><span class=\"comment\">  clearInterval: [Function: clearInterval],</span></span><br><span class=\"line\"><span class=\"comment\">  clearTimeout: [Function: clearTimeout],</span></span><br><span class=\"line\"><span class=\"comment\">  setInterval: [Function: setInterval],</span></span><br><span class=\"line\"><span class=\"comment\">  setTimeout: [Function: setTimeout] &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    [Symbol(nodejs.util.promisify.custom)]: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  queueMicrotask: [Function: queueMicrotask],</span></span><br><span class=\"line\"><span class=\"comment\">  clearImmediate: [Function: clearImmediate],</span></span><br><span class=\"line\"><span class=\"comment\">  setImmediate: [Function: setImmediate] &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    [Symbol(nodejs.util.promisify.custom)]: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>这里 <code>that</code> 指向整个 object.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> object = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"My Object\"</span>,</span><br><span class=\"line\">  getNameFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> that.name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(object.getNameFunc()()); <span class=\"comment\">// My Object</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h4><p>对应于传递给函数的参数的类数组对象, 是所有非箭头函数中可用的局部变量, 可以使用它来引用函数的参数.</p>\n<ol>\n<li>arguments参数可以被设置</li>\n<li>不是一个Array, 只是类似, 类型是 object</li>\n<li>只有length和索引元素功能</li>\n<li>可以被转换为真正的数组</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">a, b, c, d, e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]); <span class=\"comment\">// 2</span></span><br><span class=\"line\">  <span class=\"comment\">// 参数被设置</span></span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">4</span>][<span class=\"number\">0</span>] = <span class=\"string\">'Mary'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>], <span class=\"built_in\">arguments</span>[<span class=\"number\">4</span>]); <span class=\"comment\">// 3 [ 'Mary', 'hi', 'go' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// arguments转换为数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> args0 = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> args1 = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)</span></span><br><span class=\"line\">  <span class=\"comment\">// 注重性能 使用被忽视的Array构造函数作为一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> args = (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">1</span> ? [<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]] : <span class=\"built_in\">Array</span>.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'ES6'</span>, args0, args1, <span class=\"string\">'遍历对象构造数组'</span>, args);</span><br><span class=\"line\">  <span class=\"comment\">// ES6 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] 遍历对象构造数组 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ES2015</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> args3 = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> args4 = [...arguments];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'ES5'</span>, args3, args4);</span><br><span class=\"line\">  <span class=\"comment\">// ES5 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>); <span class=\"comment\">// object</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unique(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'hello'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'go'</span>]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"eval-函数\"><a href=\"#eval-函数\" class=\"headerlink\" title=\"eval 函数\"></a>eval 函数</h4><p>计算某个<strong>原始字符串</strong>(不是String对象), 并执行其中的JS代码, 并返回结果(如果不存在, 则返回undefined). 是全局对象的一个函数属性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"built_in\">eval</span>(<span class=\"string\">'x+2'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, <span class=\"built_in\">eval</span>(<span class=\"string\">'4+8'</span>)); <span class=\"comment\">// 10 12</span></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">'let a = 10, b = 9; console.log(a*b)'</span>); <span class=\"comment\">// 90</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 不是字符串的话, 原封不动返回</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>(<span class=\"number\">67</span>)); <span class=\"comment\">// 67</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"number\">777</span>))); <span class=\"comment\">// [String: '777']</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"操作符-typeof\"><a href=\"#操作符-typeof\" class=\"headerlink\" title=\"操作符 typeof\"></a>操作符 typeof</h2><h3 id=\"判断变量数据类型\"><a href=\"#判断变量数据类型\" class=\"headerlink\" title=\"判断变量数据类型\"></a>判断变量数据类型</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"comment\">// 通用数据类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"string\">'jinling'</span> + <span class=\"string\">'\\n'</span> +  <span class=\"comment\">// string</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"number\">23</span> + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// number</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> + <span class=\"string\">'\\n'</span> +  <span class=\"comment\">// boolean</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// object</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> &#123;<span class=\"attr\">k1</span>:<span class=\"string\">'v1'</span>, <span class=\"attr\">k2</span>:<span class=\"string\">'v2'</span>&#125; + <span class=\"string\">'\\n'</span> <span class=\"comment\">// object</span></span><br><span class=\"line\">  <span class=\"comment\">// 特殊字符类型</span></span><br><span class=\"line\">  <span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// object</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// undefined</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"literal\">NaN</span> + <span class=\"string\">'\\n'</span> <span class=\"comment\">// number</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined与null值相同,但类型不同</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>===<span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>==<span class=\"literal\">null</span>); <span class=\"comment\">// false true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断数组可以用 Array.isArray</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(&#123;<span class=\"attr\">k1</span>:<span class=\"string\">'v1'</span>, <span class=\"attr\">k2</span>:<span class=\"string\">'v2'</span>&#125;)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"对象-Object\"><a href=\"#对象-Object\" class=\"headerlink\" title=\"对象 Object\"></a>对象 Object</h1><p>使用{}表示, 键必须是字符串.</p>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>接口与实现分离, 常称为封装. 常见在属性开头加上_表示是私有属性.</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><p>创建一个对象, 定义属性和方法, 不需要 Class.</p>\n<p>对象中的方法就是保存函数的属性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> animal = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'dog'</span>,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> eat meat`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">animal.eat(); <span class=\"comment\">// dog eat meat</span></span><br><span class=\"line\">animal.color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(animal.color); <span class=\"comment\">// red</span></span><br></pre></td></tr></table></figure>\n<p>显式修改方法的调用对象. 使用函数的 <code>call</code> 方法, 该方法将 <code>this</code> 值作为第一个参数, 其他参数为普通参数. 则此时 <code>obj</code> 是 <code>eat</code> 方法的调用者, 通过 <code>call</code> 进行了显式的调用对象的修改.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> animal = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'dog'</span>,</span><br><span class=\"line\">  eat (thing) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> eat <span class=\"subst\">$&#123;thing&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'monkey'</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// obj 成为 eat 方法的调用者</span></span><br><span class=\"line\">animal.eat.call(obj, <span class=\"string\">'carrot'</span>); <span class=\"comment\">// monkey eat carrot</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><p>对象有自己的默认属性集. <code>Object.getPrototypeOf</code> 方法返回一个对象的原型.</p>\n<p><code>Object.prototype</code> 提供在所有对象中显示的方法, 是最根部的原型.</p>\n<p>函数派生自 <code>Function.prototype</code>, 数组派生自 <code>Array.prototype</code>, 他们具有不同的默认属性集.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString); <span class=\"comment\">// [Function: toString]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString()); <span class=\"comment\">// [object Object]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__); <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空对象的原型是 Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(&#123;&#125;) == <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.prototype 原型为 null</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h3><p>使用 <code>Object.create</code> 创建具有特定原型的对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> protoDog = &#123;</span><br><span class=\"line\">  speak(word)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking '</span> + word);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"built_in\">Object</span>.create(protoDog);</span><br><span class=\"line\">dog.name = <span class=\"string\">'doggi'</span>; <span class=\"comment\">// dog 对象此时仅包含自身属性 name</span></span><br><span class=\"line\"><span class=\"comment\">// speak 方法来自原型</span></span><br><span class=\"line\">dog.speak(<span class=\"string\">'hello'</span>); <span class=\"comment\">// doggi is speaking hello</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__ 属性\"></a>__proto__ 属性</h3><p>继承是让两个对象产生关联, 使用 __proto__, 这个属性每个对象都有. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> animal = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'animal'</span>,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> eat meat`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 属性覆盖 方法不覆盖</span></span><br><span class=\"line\"><span class=\"comment\">// 对象 dog 的原型是 animal</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'dog'</span>,</span><br><span class=\"line\">  __proto__: animal <span class=\"comment\">// 指向animal对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象 cat 的原型是 animal</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cat'</span>,</span><br><span class=\"line\">  __proto__: animal <span class=\"comment\">// 指向animal对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dog.eat(); <span class=\"comment\">// dog eat meat</span></span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// cat eat meat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单纯关联 不做属性或者方法覆盖</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  __proto__: animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = &#123;</span><br><span class=\"line\">  __proto__: animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.name, cat.name); <span class=\"comment\">// animal animal</span></span><br><span class=\"line\">dog.eat(); <span class=\"comment\">// animal eat meat</span></span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// animal eat meat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法覆盖 属性不覆盖</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  __proto__: animal,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'dog is eating'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = &#123;</span><br><span class=\"line\">  __proto__: animal,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'cat is eating'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.name, cat.name); <span class=\"comment\">// animal animal</span></span><br><span class=\"line\">dog.eat(); <span class=\"comment\">// dog is eating</span></span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// cat is eating</span></span><br></pre></td></tr></table></figure>\n<p>如下所示, 对象 <code>dog</code> 和 <code>cat</code> 的原型均是 <code>animal</code>, 但是均没有定义 <code>eat</code> 方法. 在执行 <code>eat</code> 方法时, 会到其原型中去寻找, 如果找到则执行, 没有则继续去原型的原型中去寻找, 直至找到或者为<code>null</code>. 不断寻找原型的过程依赖于__proto__建立的原型链.</p>\n<p>可以看出, 尽管执行的是原型中的方法, 但是方法中的<code>this</code>仍然指的是调用该方法的上级对象, 由于是<code>dog</code>和<code>cat</code>这两个对象进行调用的, 所以 this 指向的就是这两个对象而不是 animal.</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>但是 JS 也可以通过 <code>new</code> 关键字来创建对象, 是给不理解原型链又需要创建对象的程序员使用的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模仿 java 中的 Class 而提供的构造函数</span></span><br><span class=\"line\"><span class=\"comment\">// Student 的首字母大写</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> lily = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"lily\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> mary = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"mary\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">lily.sayHello(); <span class=\"comment\">// hello lily</span></span><br><span class=\"line\">mary.sayHello(); <span class=\"comment\">// hello mary</span></span><br></pre></td></tr></table></figure>\n<p>这样有个问题就是, 每个对象都会有一个 <code>sayHello</code> 函数, 太重复, 而 java 中函数是定义在 <code>class</code> 中的.</p>\n<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><p>JS  使用更加高效的方式, 创建一个原型对象 A, 将方法都放在这个原型对象 A 中, 而通过同一个构造函数创建的对象的原型, 都是这个原型对象 A, 这样对象找不到方法时, 就会去其原型即 A 中寻找.</p>\n<p>达到这样的效果,  则需要将构造函数与原型对象 A 关联起来, 将 A 赋值给构造函数的 <code>prototype</code> 属性, 则 A 就会成为这个构造函数创建的对象的原型.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原型对象</span></span><br><span class=\"line\">Student.prototype = &#123;</span><br><span class=\"line\">  sayHello () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> lily = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"lily\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> mary = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"mary\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">lily.sayHello(); <span class=\"comment\">// hello lily</span></span><br><span class=\"line\">mary.sayHello(); <span class=\"comment\">// hello mary</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"语法糖-Class\"><a href=\"#语法糖-Class\" class=\"headerlink\" title=\"语法糖 Class\"></a>语法糖 Class</h3><p>上述语法有点复杂, JS 推出语法糖, 将构造函数与原型对象的函数写在一个 <code>class</code> 中.</p>\n<p>上述写法等同于下面这种.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造函数的 prototype</span></span><br><span class=\"line\">  <span class=\"comment\">// 原型对象</span></span><br><span class=\"line\">  <span class=\"comment\">// 作为对象的方法, this 指向的是 调用该方法的对象</span></span><br><span class=\"line\">  sayHello = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mary = <span class=\"keyword\">new</span> Student(<span class=\"string\">'mary'</span>);</span><br><span class=\"line\"><span class=\"comment\">// mary 对象调用其原型(__proto__)的方法 sayHello</span></span><br><span class=\"line\"><span class=\"comment\">// 此时方法中的 this 指向 mary 对象</span></span><br><span class=\"line\">mary.sayHello(); <span class=\"comment\">// hello mary</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"类-Class\"><a href=\"#类-Class\" class=\"headerlink\" title=\"类 Class\"></a>类 Class</h2><p>一种语法糖, 特殊的函数, 由<strong>类表达式</strong>和<strong>类声明</strong>组成. 类定义了一种对象的形状, 具有哪些属性与方法. 而这种对象称之为类的实例.</p>\n<p>JS 类就是带有 prototype 属性的构造函数. 类中的方法, 都是构造函数原型对象中的方法. 类中的<code>constructor</code>方法是实际的构造函数, 并被绑定名称 <code>Animal</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 目前只支持将函数添加进构造函数原型中 </span></span><br><span class=\"line\">  <span class=\"comment\">// 不支持其他类型</span></span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h3><ol>\n<li><p>类声明 带有<code>class</code>关键字</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类需要先声明 再使用 不像函数声明会提升</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hello</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类表达式 可以具名或者匿名</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匿名类</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello.name); <span class=\"comment\">// hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具名类</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hello2</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello.name); <span class=\"comment\">// hello2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传统的基于函数的类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.speak = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' makes a noise.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.speak();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' barks.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Dog(<span class=\"string\">'cookie'</span>)</span><br><span class=\"line\">d.speak(); </span><br><span class=\"line\"><span class=\"comment\">// cookie makes a noise.</span></span><br><span class=\"line\"><span class=\"comment\">// cookie barks.</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类体和方法定义\"><a href=\"#类体和方法定义\" class=\"headerlink\" title=\"类体和方法定义\"></a>类体和方法定义</h3><p><code>constructor</code> </p>\n<p>构造函数, 一种特殊方法, 创建和初始化一个由 <code>class</code> 创建的对象. </p>\n<p>构造函数可以使用<code>super</code>调用父类的构造函数.</p>\n<h3 id=\"覆盖派生属性\"><a href=\"#覆盖派生属性\" class=\"headerlink\" title=\"覆盖派生属性\"></a>覆盖派生属性</h3><p>向对象中添加属性, 属性被添加到对象本身, 原型中的此属性将不再影响该对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给构造函数的原型对象添加属性</span></span><br><span class=\"line\">Animal.prototype.age = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\">dog.age = <span class=\"number\">10</span>; <span class=\"comment\">// 覆盖原型属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.age); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.age); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(dog).age); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>数组原型提供的 <code>toString</code> 方法与基本原型对象提供的有所差别, 这样对原型属性的覆盖有利于更通用的对象类中表达异常属性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.toString == <span class=\"built_in\">Object</span>.prototype.toString); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].toString()); <span class=\"comment\">// 1,2,3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.prototype.toString 并不知道数组的信息, 只是将 object 与调用对象的类型名称放在[]中</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString.call([<span class=\"number\">1</span>, <span class=\"number\">2</span>]), <span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">4</span>)); </span><br><span class=\"line\"><span class=\"comment\">// [object Array] [object Number]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>对原型方法的覆盖, 以实现实例的特殊化需求. <code>String</code> 实际调用的仍然是 <code>toString</code> 方法.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(dog)); <span class=\"comment\">// [object Object]</span></span><br><span class=\"line\">Animal.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'This is '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(dog)); <span class=\"comment\">// This is dog</span></span><br></pre></td></tr></table></figure>\n<p>任何支持 <code>toString</code> 方法的对象都可以使用它.</p>\n<p><strong>多态</strong>: 多态代码可以支持不同类型的值, 只要这些值支持它指定的接口. 比如 toString 方法, 所有值都支持该接口, 则所有值都能使用该方法.</p>\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>普通对象派生自 <code>Object.prototype</code> , 含有祖先原型的所有属性, 在一些实际场景下, 这些属性可能显得多余. </p>\n<p>→ 可以创建没有原型的对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传递 null 生成的对象不会从 Object.prototype 派生</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> &#123;&#125;); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>而且普通对象要求键值必须为字符串.</p>\n<p>→ 使用 Map 类, 存储映射并可以使用任何类型的 key.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ages = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">ages.set(<span class=\"string\">'Bob'</span>, <span class=\"number\">23</span>);</span><br><span class=\"line\">ages.set(<span class=\"string\">'Mary'</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ages.get(<span class=\"string\">'Bob'</span>)); <span class=\"comment\">// 23</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ages.has(<span class=\"string\">'Mary'</span>), ages.has(<span class=\"string\">'toString'</span>)); <span class=\"comment\">// true false</span></span><br></pre></td></tr></table></figure>\n<p>set get has 是 Map 对象接口的一部分.</p>\n<p>某种情况下,  如果确实需要使用普通对象来作为映射, 则 <code>Object.keys</code> 只返回一个<strong>对象自己的键,</strong> 而不包括其原型中的那些属性. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'is speaking'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(dog)); <span class=\"comment\">// [ 'name', 'age' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给原型添加属性</span></span><br><span class=\"line\">dog.__proto__.type = <span class=\"string\">'animal'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Object.keys(dog) 仍然只显示自己的属性, 不包括原型中的属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(dog), <span class=\"built_in\">Object</span>.keys(dog.__proto__)); <span class=\"comment\">// [ 'name', 'age' ] [ 'type' ]</span></span><br></pre></td></tr></table></figure>\n<p><code>hasOwnProperty</code> 方法也只判断某键<strong>是不是该对象自己的</strong>, 没找到也不会去搜索其原型对象. 与关键字 <code>in</code> 不同.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.hasOwnProperty(<span class=\"string\">'name'</span>), dog.hasOwnProperty(<span class=\"string\">'speak'</span>)); <span class=\"comment\">// true false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'name'</span> <span class=\"keyword\">in</span> dog, <span class=\"string\">'speak'</span> <span class=\"keyword\">in</span> dog); <span class=\"comment\">// true true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"extends-创建子类\"><a href=\"#extends-创建子类\" class=\"headerlink\" title=\"extends 创建子类\"></a>extends 创建子类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, sex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用超类构造函数并传入name参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 必须先super 然后才能使用this</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.sex&#125;</span> and barks`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Dog1(<span class=\"string\">'cookie'</span>, <span class=\"string\">'girl'</span>);</span><br><span class=\"line\">d.speak(); <span class=\"comment\">// cookie is girl and barks</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"instanceof-运算符\"><a href=\"#instanceof-运算符\" class=\"headerlink\" title=\"instanceof 运算符\"></a>instanceof 运算符</h3><p>判断一个对象是否来自某一个类.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 目前只支持将函数添加进构造函数原型中 </span></span><br><span class=\"line\">  <span class=\"comment\">// 不支持其他类型</span></span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog <span class=\"keyword\">instanceof</span> Animal, dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">// true true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TO DO </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// TypeError: Right-hand side of 'instanceof' is not callable</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><blockquote>\n<p>部署在object对象自身的方法</p>\n</blockquote>\n<p><code>Object.values</code> 获取对象的所有key, 输出类型为数组</p>\n<p><code>Object.keys</code> 获取对象的所有value, 输出类型为数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">key1</span>:<span class=\"string\">'val1'</span>, <span class=\"attr\">key2</span>:<span class=\"string\">'val2'</span>, <span class=\"attr\">key3</span>:<span class=\"string\">'val3'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.values(obj)); <span class=\"comment\">// [ 'val1', 'val2', 'val3' ]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.getOwnPropertyNames</code> 也是返回对象的所有属性名, 但是还会返回不可枚举的属性; 可枚举属性方面, 与<code>Object.keys</code>相同</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不可枚举属性 二者不同</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = [<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>, <span class=\"string\">'jinling'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj1)); <span class=\"comment\">// [ '0', '1', '2' ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj1)); <span class=\"comment\">// [ '0', '1', '2', 'length' ] 包含不可枚举属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可枚举属性 二者相同</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">key1</span>:<span class=\"string\">'val1'</span>, <span class=\"attr\">key2</span>:<span class=\"string\">'val2'</span>, <span class=\"attr\">key3</span>:<span class=\"string\">'val3'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj)); <span class=\"comment\">// [ 'key1', 'key2', 'key3' ]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><p><code>Object.hasOwnProperty</code>判断对象是否拥有某项属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">key1</span>:<span class=\"string\">'val1'</span>, <span class=\"attr\">key2</span>:<span class=\"string\">'val2'</span>, <span class=\"attr\">key3</span>:<span class=\"string\">'val3'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.hasOwnProperty(<span class=\"string\">'key2'</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><p>摩尔定律失效, 多核时代来临, 函数式编程能够很好地为并发编程服务, 具有 没有 side effect/ 不共享变量/安全调度到任何一个CPU core 上运行/没有加锁问题…等诸多优点.</p>\n<h2 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h2><ol>\n<li>对于相同的输入, 永远有相同的输出. 没有可观察的副作用, 不依赖外部条件.</li>\n<li>不能修改传递给函数的参数</li>\n<li>不能修改全局变量</li>\n</ol>\n<p>比如数组操作中, 对于给定的数组, slice就是纯的, splice就是不纯的.</p>\n<p>纯函数可以有效降低系统复杂性, 还有很多其他的优秀特性, 例如可缓存性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> _ <span class=\"keyword\">from</span> <span class=\"string\">'lodash'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sin = _.memorize(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">Math</span>.sin(x));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一次计算的时候会稍慢一点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = sin(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二次有了缓存，速度极快</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = sin(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用递归而非迭代\"><a href=\"#使用递归而非迭代\" class=\"headerlink\" title=\"使用递归而非迭代\"></a>使用递归而非迭代</h2><p>使用尾递归, 保证不溢出.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代不被允许</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"number\">0</span>; <span class=\"comment\">// result 不能改变</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr)&#123;</span><br><span class=\"line\">  result += i; <span class=\"comment\">// i 不能改变</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> rest = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">arr, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> sum(rest(arr), res + first(arr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr, <span class=\"number\">0</span>)); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>很多函数大体相同, 重复代码很多, 只有一些细节不一样, 于是产生高阶函数.</p>\n<p>高阶函数: 让函数来产生函数, 共用的部分抽取出来, 不共用的部分与共用的部分能组合起来.</p>\n<p>比如 JS 中的 <code>map/filter/forEach/...</code> 函数都是高阶函数, 能快速操作集合数据.</p>\n<h3 id=\"函数的柯里化\"><a href=\"#函数的柯里化\" class=\"headerlink\" title=\"函数的柯里化\"></a>函数的柯里化</h3><p>curry: 传递给函数一部分的参数来调用它, 让他返回一个函数去处理剩下的参数.</p>\n<p>就是传递一部分的参数, 形成固定模式的函数(部分参数数值已经固定), 得到已经记住参数的新函数. 这样对应固定的输入, 就得到固定的输出.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> check = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> y &gt; x);</span><br><span class=\"line\"><span class=\"keyword\">let</span> check7 = check(<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(check7(<span class=\"number\">10</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数组合\"><a href=\"#函数组合\" class=\"headerlink\" title=\"函数组合\"></a>函数组合</h3><p>包菜式代码  <code>h(g(f(x)))</code> =&gt; 更优雅 函数组合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传的是g函数需要的参数</span></span><br><span class=\"line\"><span class=\"comment\">// 将任何两个纯函数结合在一起, 组合函数式的代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> (<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add1 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> mul5 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> res = compose(add1, mul5);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res(<span class=\"number\">2</span>)); <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> reverse = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr.reverse();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(first, reverse);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(last([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"惰性求值\"><a href=\"#惰性求值\" class=\"headerlink\" title=\"惰性求值\"></a>惰性求值</h2><p>待补充</p>\n<h2 id=\"宏-macro\"><a href=\"#宏-macro\" class=\"headerlink\" title=\"宏(macro)\"></a>宏(macro)</h2><p>待补充</p>\n<h2 id=\"Point-Free\"><a href=\"#Point-Free\" class=\"headerlink\" title=\"Point Free\"></a>Point Free</h2><p>减少对不必要的中间变量的命名</p>\n<h2 id=\"声明式与命令式代码\"><a href=\"#声明式与命令式代码\" class=\"headerlink\" title=\"声明式与命令式代码\"></a>声明式与命令式代码</h2><p><strong>命令式</strong>: 写出一条一条指令让计算机执行, 一般会涉及到很多繁琐的细节. <strong>既说做什么, 也说怎么做</strong>.</p>\n<p><strong>声明式</strong>: 写表达式表明自己想做的事情, 而不是一步一步的指示. 隐藏细节.  <strong>只说做什么, 不说怎么做</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//命令式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CEOs = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; companies.length; i++)&#123;</span><br><span class=\"line\">    CEOs.push(companies[i].CEO)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CEOs = companies.map(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c.CEO);</span><br></pre></td></tr></table></figure>\n<p>函数式编程一个优点就是声明式代码以及纯函数. 工作时专注于业务代码, 优化时专注于函数内部. 还有其他的特点, 比如高阶函数/函数没有side effect/只有值没有变量/用递归而不是用迭代等.</p>\n<h1 id=\"遍历器与-for…of\"><a href=\"#遍历器与-for…of\" class=\"headerlink\" title=\"遍历器与 for…of\"></a>遍历器与 for…of</h1><h2 id=\"遍历器概念\"><a href=\"#遍历器概念\" class=\"headerlink\" title=\"遍历器概念\"></a>遍历器概念</h2><p>是用来处理可遍历数据结构的统一接口, 只要部署 <code>iterator</code> 接口, 就可以进行遍历操作.</p>\n<p>作用: 提供统一的访问接口/数据结构的成员按照某种顺序排列/为ES6新增的<code>for...of</code>服务</p>\n<p>数据结构有遍历器接口, 就称为该数据结构是可遍历的/可迭代的.</p>\n<h2 id=\"JS-默认遍历器接口\"><a href=\"#JS-默认遍历器接口\" class=\"headerlink\" title=\"JS 默认遍历器接口\"></a>JS 默认遍历器接口</h2><p>JS中默认的遍历器接口, 即数据结构的原型对象有 <code>Symbol.iterator</code> 属性, 该属性对应的函数返回一个遍历器对象, 调用对象的<code>next</code>方法, 即可返回数据结构的下一个数据..</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> it = arr[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next(), it.next(), it.next(), it.next());</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 3, done: false &#125; &#123; value: 4, done: false &#125; &#123; value: 5, done: false &#125; &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// done 表示是否遍历结束</span></span><br></pre></td></tr></table></figure>\n<p>原生具备 Iterator 接口的数据结构如下。</p>\n<ul>\n<li><p>Array</p>\n</li>\n<li><p>Map</p>\n</li>\n<li><p>Set</p>\n</li>\n<li><p>String</p>\n</li>\n<li><p>TypedArray</p>\n</li>\n<li><p>函数的 arguments 对象</p>\n</li>\n<li><p>NodeList 对象</p>\n</li>\n</ul>\n<p>上述数据结构不用自己写遍历器函数, <code>for...of</code>循环会自动进行遍历.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>没有遍历器函数的数据结构, 可以根据实际需求进行手动部署, 即在<code>Symbol.iterator</code>属性上手写遍历器对象生成函数.</p>\n<h1 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h1><p>针对数组或者对象进行模式匹配, 然后对其中的变量进行赋值. 解构目标 = 解构源.</p>\n<h2 id=\"数组的解构\"><a href=\"#数组的解构\" class=\"headerlink\" title=\"数组的解构\"></a>数组的解构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 嵌套</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, [[b], c]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可忽略</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, , c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, c); <span class=\"comment\">// 1 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 剩余运算符</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, ...b] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 1 [2, 3]</span></span><br></pre></td></tr></table></figure>\n<p>数组解构中, 若解构目标为可遍历对象(实现iterator接口的数据), 都可以进行解构赋值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c, ...d] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c, d); <span class=\"comment\">// h e l [ 'l', 'o' ]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"解构默认值\"><a href=\"#解构默认值\" class=\"headerlink\" title=\"解构默认值\"></a>解构默认值</h3><p>解构匹配到<code>undefined</code>, 触发默认值作为返回结果.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 均匹配到 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">2</span>] = [<span class=\"literal\">undefined</span>]; <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">3</span>, b = a] = []; <span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 3 3</span></span><br><span class=\"line\"><span class=\"comment\">// b 匹配到 undefined, 触发默认值 b=a=1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">3</span>, b = a] = [<span class=\"number\">1</span>]; <span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 1 1</span></span><br><span class=\"line\"><span class=\"comment\">// 正常解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">3</span>, b = a] = [<span class=\"number\">1</span>, <span class=\"number\">9</span>]; <span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 1 9</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"对象的解构\"><a href=\"#对象的解构\" class=\"headerlink\" title=\"对象的解构\"></a>对象的解构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// undefined undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">a</span>: b &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 正确使用 解构目标必须与key一致 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello, apple &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello, apple); <span class=\"comment\">// aaa bbb</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">hello</span>: b &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// aaa</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello); <span class=\"comment\">// aaa</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 剩余运算符 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b, ...rest &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">30</span>, <span class=\"attr\">d</span>: <span class=\"number\">40</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, rest); <span class=\"comment\">// 10 20 &#123; c: 30, d: 40 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 解构默认值 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello = <span class=\"number\">3</span>, apple = <span class=\"number\">5</span> &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello, apple); <span class=\"comment\">// aaa bbb</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apple 匹配到 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello = <span class=\"number\">3</span>, apple = <span class=\"number\">5</span> &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello, apple); <span class=\"comment\">// aaa 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">hello</span>: aa = <span class=\"number\">3</span>, <span class=\"attr\">apple</span>: bb = <span class=\"number\">5</span> &#125; = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(aa, bb); <span class=\"comment\">// 3 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">hello</span>: aa = <span class=\"number\">3</span>, <span class=\"attr\">apple</span>: bb = <span class=\"number\">5</span> &#125; = &#123; <span class=\"attr\">apple</span>: <span class=\"string\">'aaa'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(aa, bb); <span class=\"comment\">// 3 aaa</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"关键字-this\"><a href=\"#关键字-this\" class=\"headerlink\" title=\"关键字 this\"></a>关键字 this</h1><p>js中<code>this</code>随着执行环境的变化而变化, 是函数运行时, 在函数体内部自动生成的一个对象, 只能在函数体内部使用. 即, <strong>this 是函数运行时所在的环境对象</strong>. 箭头函数不绑定自己的 <code>this</code> .</p>\n<h2 id=\"单独使用\"><a href=\"#单独使用\" class=\"headerlink\" title=\"单独使用\"></a>单独使用</h2><p>无论有无严格模式, <code>this</code>始终指向全局对象. 浏览器中, 全局对象为<code>[object Window]</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 'use strict'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"纯粹的函数调用\"><a href=\"#纯粹的函数调用\" class=\"headerlink\" title=\"纯粹的函数调用\"></a>纯粹的函数调用</h2><p>函数中, 默认<code>this</code>指向全局对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(); <span class=\"comment\">// ok</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fun()); <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>严格模式下不允许默认绑定, 所以函数中的<code>this</code>为<code>undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 严格模式</span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myFunction()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数作为对象方法\"><a href=\"#函数作为对象方法\" class=\"headerlink\" title=\"函数作为对象方法\"></a>函数作为对象方法</h2><p>指向上级对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\tsize : <span class=\"number\">14</span>,</span><br><span class=\"line\">\tcolor: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">\tgetColor: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">'颜色是'</span> + <span class=\"keyword\">this</span>.color</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 该实例中, this指向getColor方法所在的对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getColor) <span class=\"comment\">// [Function: getColor]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getColor()) <span class=\"comment\">// 颜色是red (加括号表示调用方法)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法中的this单独打印, 会打印出所属对象的内容</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  firstName  : <span class=\"string\">\"John\"</span>,</span><br><span class=\"line\">  lastName   : <span class=\"string\">\"Doe\"</span>,</span><br><span class=\"line\">  id         : <span class=\"number\">5566</span>,</span><br><span class=\"line\">  myFunction : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.myFunction()); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  firstName: 'John',</span></span><br><span class=\"line\"><span class=\"comment\">  lastName: 'Doe',</span></span><br><span class=\"line\"><span class=\"comment\">  id: 5566,</span></span><br><span class=\"line\"><span class=\"comment\">  myFunction: [Function: myFunction]</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类方法中的-this-指向\"><a href=\"#类方法中的-this-指向\" class=\"headerlink\" title=\"类方法中的 this 指向\"></a>类方法中的 <code>this</code> 指向</h3><p><code>speak</code> 方法中的 <code>this</code> 从打印结果来看, 指的是<strong>构造函数生成的新对象</strong>, 并未打印<code>speak</code>方法.</p>\n<p>但是 <code>this.speak</code> 却能够调用, 说明<code>this</code>不仅指向的是构造函数对应的对象, 而且在行为上也与构造函数的对象一致, 就是对象中找不到方法, 就去对象的原型中去找.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.speak, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"comment\">// 此时 speak 中的this指的是它的调用对象, 也就是 dog</span></span><br><span class=\"line\"><span class=\"comment\">// speak 在打印 this.speak 时, 相当于打印 dog.speak, 但是 dog 本身是没有 speak 函数的</span></span><br><span class=\"line\"><span class=\"comment\">// 只能去 dog 原型对象里去找, 最后找到了 speak 函数, 其实打印的是 dog 原型的 speak 函数</span></span><br><span class=\"line\">dog.speak();</span><br><span class=\"line\"><span class=\"comment\">// [Function: speak] Animal &#123; name: undefined &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eat 中的 this 与 speak 中的 this 一样</span></span><br><span class=\"line\"><span class=\"comment\">// 均是指构造函数对应的对象</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面 eat 在执行时, 均是指向调用 eat 方法的类的实例</span></span><br><span class=\"line\"><span class=\"comment\">// 即 panda 和 cat</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> panda = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'panda'</span>);</span><br><span class=\"line\">panda.eat(); <span class=\"comment\">// Animal &#123; name: 'panda' &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);</span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// Animal &#123; name: 'cat' &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数作为构造函数\"><a href=\"#函数作为构造函数\" class=\"headerlink\" title=\"函数作为构造函数\"></a>函数作为构造函数</h2><p>构造函数就是, 通过这个函数, 能够生成一个新对象. 此时, <code>this</code> 指向这个新对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.x); <span class=\"comment\">// hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// ok 此时全局变量x的值没有变化, 说明 this 不是全局对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"apply-调用\"><a href=\"#apply-调用\" class=\"headerlink\" title=\"apply 调用\"></a>apply 调用</h2><p><code>apply()</code>是函数的一个方法, 作用是改变函数的调用对象. 第一个参数表示改变后的调用这个函数的对象, 此时 <code>this</code> 指向这个参数.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.x = <span class=\"string\">'hi'</span>;</span><br><span class=\"line\">obj.method= test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数为空时, 默认 obj.method 这个方法的调用者修改为 全局对象.</span></span><br><span class=\"line\">obj.method.apply(); <span class=\"comment\">// o.apply(); // ok</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改 obj.method 这个方法的调用者为 obj, 则此时 obj.method 作为对象方法被调用</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向 obj</span></span><br><span class=\"line\">obj.method.apply(obj); <span class=\"comment\">// hi</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>ES6之前使用 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。</p>\n<p>ES6 引入了模块化，在编译时就能确定模块的依赖关系 + 输入和输出的变量。</p>\n<p>ES6 的模块化 = 导出（export） 与导入（import）两个模块。</p>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>自动开启严格模式</p>\n<p>模块中可以导入导出各种类型的变量, 如函数/对象/字符串/布尔值/类等.</p>\n<p>每个模块都有自己的上下文, 模块内声明的变量都是局部变量.</p>\n<p>每个模块只加载一次, 再去加载该模块, 则直接从内存中读取.</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 </p>\n<p>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</p>\n<p>import 命令会提升到整个模块的头部，首先执行。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----export [test.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myAge = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myfn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"My name is\"</span> + myName + <span class=\"string\">\"! I'm '\"</span> + myAge + <span class=\"string\">\"years old.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myClass =  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> a = <span class=\"string\">\"yeah!\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class=\"line\"><span class=\"comment\">// 建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口</span></span><br><span class=\"line\"><span class=\"comment\">// 函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----import [xxx.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myfn());<span class=\"comment\">// My name is Tom! I'm 20 years old.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myAge);<span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myName);<span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myClass.a );<span class=\"comment\">// yeah!</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"as-的用法\"><a href=\"#as-的用法\" class=\"headerlink\" title=\"as 的用法\"></a>as 的用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----export [test.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName <span class=\"keyword\">as</span> exportName &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/*-----import [xxx.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; exportName &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(exportName);<span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"comment\">// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----export [test1.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----export [test2.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Jerry\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----import [xxx.js]-----*/</span></span><br><span class=\"line\"><span class=\"comment\">// 不同模块导出接口名称命名重复， 使用 as 重新定义变量名。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; myName <span class=\"keyword\">as</span> name1 &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test1.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; myName <span class=\"keyword\">as</span> name2 &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test2.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name1);<span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name2);<span class=\"comment\">// Jerry</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"import-命令的特点\"><a href=\"#import-命令的特点\" class=\"headerlink\" title=\"import 命令的特点\"></a>import 命令的特点</h3><h4 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h4><h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于 import &#123; a &#125; \"./xxx.js\"; 只执行一次</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; b &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于 import &#123; a, b &#125; from \"./xxx.js\"; 只执行一次</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"静态执行特性\"><a href=\"#静态执行特性\" class=\"headerlink\" title=\"静态执行特性\"></a>静态执行特性</h4><p><code>import</code> 静态执行, 不能使用表达式和变量.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"string\">\"f\"</span> + <span class=\"string\">\"oo\"</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"methods\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 表达式 error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">module</span> = <span class=\"string\">\"methods\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"built_in\">module</span>;</span><br><span class=\"line\"><span class=\"comment\">// 变量 error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"method1\"</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"method2\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"export-default-命令\"><a href=\"#export-default-命令\" class=\"headerlink\" title=\"export default 命令\"></a>export default 命令</h3><p>在一个文件或者模块中, export/import可以有多个, export default 仅有一个。</p>\n<p>导出时不需要加{}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"My name is Tom!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> a; <span class=\"comment\">// 仅有一个 不需要加&#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">var</span> c = <span class=\"string\">\"error\"</span>; </span><br><span class=\"line\"><span class=\"comment\">// error，default 已经是对应的导出变量，不能跟着变量声明语句</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> b <span class=\"keyword\">from</span> <span class=\"string\">\"./xxx.js\"</span>; <span class=\"comment\">// 不需要加&#123;&#125;， 使用任意变量接收</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><ol>\n<li><p>避免使用 全局变量 <code>new</code> <code>===</code> <code>eval()</code></p>\n</li>\n<li><p>所有声明放在脚本或者函数的顶部, <strong>顶部声明, 稍后使用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在顶部声明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstName, lastName, price, discount, fullPrice;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 稍后使用</span></span><br><span class=\"line\">firstName = <span class=\"string\">\"Bill\"</span>;</span><br><span class=\"line\">lastName = <span class=\"string\">\"Gates\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">price = <span class=\"number\">19.90</span>;</span><br><span class=\"line\">discount = <span class=\"number\">0.10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">fullPrice = price * <span class=\"number\">100</span> / discount;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>声明变量时同时初始化</p>\n</li>\n<li><p>将数值/字符串/布尔值声明为原始值而非对象, 否则会拖慢速度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"string\">'bill'</span> <span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'bill'</span>) <span class=\"comment\">// 对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x===y); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请勿使用 new Object()</p>\n</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">推荐使用</th>\n<th style=\"text-align:center\">不建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">{}</td>\n<td style=\"text-align:center\">new Object()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[]</td>\n<td style=\"text-align:center\">new Array()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">function (){}</td>\n<td style=\"text-align:center\">new Function()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">“”</td>\n<td style=\"text-align:center\">new String()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">new Number()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">new Boolean()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/()/</td>\n<td style=\"text-align:center\">new RegExp()</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li><p>意识到自动类型转换, 变量可以通过赋值改变其数据类型, 变量可包含不同的数据类型.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"string\">'hello'</span></span><br><span class=\"line\">a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">// number</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为函数中的参数设置默认值, <code>undefined</code> 会破坏代码</p>\n</li>\n<li><p>用<code>default</code>来结束<code>switch</code>.</p>\n</li>\n</ol>\n<h1 id=\"缺陷与错误\"><a href=\"#缺陷与错误\" class=\"headerlink\" title=\"缺陷与错误\"></a>缺陷与错误</h1><h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><blockquote>\n<p>原因</p>\n</blockquote>\n<p>js代码中会出现错误, 由于编写代码/编译/用户输入等各种各样的原因.</p>\n<blockquote>\n<p>处理</p>\n</blockquote>\n<p>发生错误时, js引擎会停止并生成一个错误消息.</p>\n<p>try与catch成对出现, finally是最后一定会执行的语句(可以没有).</p>\n<p>throw抛出错误, 实际上就是抛出一个表示错误信息的字符串s, 因此可以自定义错误.</p>\n<p>在catch中可以捕获s,实际上就是可以获得s的值并打印出来.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"string\">''</span>) <span class=\"keyword\">throw</span> <span class=\"string\">'is kong'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"string\">'1'</span>) <span class=\"keyword\">throw</span> <span class=\"string\">'is 1'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"string\">'2'</span>) <span class=\"keyword\">throw</span> <span class=\"string\">'is 2'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"string\">'1'</span>); <span class=\"comment\">// is 1</span></span><br><span class=\"line\">test(<span class=\"string\">''</span>); <span class=\"comment\">// is kong</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><blockquote>\n<p>操作</p>\n</blockquote>\n<p>设置断点, 检查变量值, 浏览器内置调试器(按下F12, 选择<code>console</code>)</p>\n<blockquote>\n<p><code>debugger</code>关键字</p>\n</blockquote>\n<p>代码会在<code>debugger</code>行停下, 并执行调试函数. 没有调试函数则不起作用.</p>\n<p>与在调试工具中设置断点效果一样.</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><blockquote>\n<p>原因</p>\n</blockquote>\n<p><code>use strict</code> </p>\n<p>消除js语法的不合理之处, 保证代码安全; 增加编译效率;</p>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<p>只能放在脚本或者函数的开头</p>\n<blockquote>\n<p>具体内容</p>\n</blockquote>\n<ul>\n<li>禁止使用未定义/声明的变量</li>\n<li>禁止删除变量/函数</li>\n<li>禁止变量重名</li>\n<li>禁止使用八进制/转义字符</li>\n<li>禁止对只读属性赋值</li>\n<li>禁止删除不能删除的属性, 比如prototype</li>\n<li>禁止变量名为eval/arguments</li>\n<li>禁止使用右侧类似语句 with (Math){x = cos(2)};</li>\n<li>禁止在作用域eval创建的变量被使用</li>\n<li>禁止this指向全局对象</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"JavaScript-简介\"><a href=\"#JavaScript-简介\" class=\"headerlink\" title=\"JavaScript 简介\"></a>JavaScript 简介</h1><h2 id=\"诞生\"><a href=\"#诞生\" class=\"headerlink\" title=\"诞生\"></a>诞生</h2><p>本名 ECMAScript, 被创建的原因是, 在浏览器输入数据时需要进行验证, 而不是传到服务器才告知客户数据错误或者空白等, 于是被创建时诞生在 NetScape 浏览器中.  </p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>只能在浏览器中运行, 不能单独运行, 不能读取文件</p>\n<p>由浏览器中的执行模块(JS引擎)执行, 考虑到页面打开的速度, 不编译执行.</p>\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><h3 id=\"操作HTML的DOM\"><a href=\"#操作HTML的DOM\" class=\"headerlink\" title=\"操作HTML的DOM\"></a>操作HTML的DOM</h3><p>浏览器从服务器取到HTML页面之后, 会展示页面出来, 但是浏览器内部将HTML组织成一个树给JS, 这个树称为 DOM.</p>\n<img src=\"/2020/09/01/JavaScript-Notes/htmltree.jpg\" class=\"\" title=\"htmltree\">\n<p>JS可以定位并操作DOM中的任意一个节点, 且不用刷新页面, 操作就可以立刻显示出效果. 而且操作是内部进行, 并没有改变 html的源码.</p>\n<h3 id=\"控制浏览器\"><a href=\"#控制浏览器\" class=\"headerlink\" title=\"控制浏览器\"></a>控制浏览器</h3><p>打开窗口/在一个窗口内前进后退/获得浏览器名称+版本(判断是什么浏览器, 才能做这个浏览器支持的特殊操作)…</p>\n<h3 id=\"异步调用\"><a href=\"#异步调用\" class=\"headerlink\" title=\"异步调用\"></a>异步调用</h3><p>不能像java一样访问网络, 就不能调用服务器的接口去获取数据. 用户只能get或者post向服务器发送请求, 服务器返回整个页面, 而不是一个片段, 整个页面得重新刷新.</p>\n<p><code>XMLHttpRequest</code> 使得 JS 可以直接向服务器发起接口调用, 等获得服务器返回的数据(此时为<code>XML</code>)后执行浏览器提供的回调函数. Called 异步调用. 回调函数基本就是更新DOM树的某个节点, 实现网页的局部刷新. 后来上述的异步调用被称为 <code>AJAX</code> (Asynchronous JavaScript And XML).</p>\n<p>由于<code>XML</code>的标签太多, 真正数据很少, 而且需要XML解析器进行解析, 后来 <code>JS</code> 和服务器之间的数据传输使用 <code>JSON</code> 这种更简洁的格式.</p>\n<p>HTML 结构, CSS 展示, JS(AJAX JSON) 逻辑 = 前端. 可以在浏览器实现 <code>MVC</code>.</p>\n<p> 后来出现了多种框架, ExtJS/prototype/JQuery/AngularJS将前端推向另一个高峰. </p>\n<h2 id=\"JS-移动到服务器端\"><a href=\"#JS-移动到服务器端\" class=\"headerlink\" title=\"JS 移动到服务器端\"></a>JS 移动到服务器端</h2><p>需要满足下述两个要求:</p>\n<ol>\n<li><p>引擎移动到服务器端, 需要执行地足够快. Chrome V8</p>\n</li>\n<li><p>绕开 JAVA 服务器的问题, 即线程遇到IO/数据库/网络这样的耗时操作, 不能等待, 换成异步处理.</p>\n</li>\n</ol>\n<p>即后来出现的 node.js, 巨大优势就是: 前后端均使用JS开发.</p>\n<h3 id=\"Node-js-工作特点\"><a href=\"#Node-js-工作特点\" class=\"headerlink\" title=\"Node.js 工作特点\"></a>Node.js 工作特点</h3><p><strong>只用一个线程来处理所有请求, 事件驱动编程.</strong></p>\n<p>需要等待的操作, 会有一个回调函数在那, 线程不会等待. 操作一完成则发出事件通知线程, 线程立马回来执行对应的回调函数, 执行完回调函数再去接着执行那些不需要等待的操作.</p>\n<p>即: 需要等待的操作先跳过, 先去执行那些不需要等待的操作, 耗时操作完成后事件通知线程后, 线程再立即回来执行其对应的回调函数. 事件驱动编程, 有需要处理的事件才去处理, 耗时操作先跳过.</p>","more":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><h2 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h2><h3 id=\"布尔值-Boolean\"><a href=\"#布尔值-Boolean\" class=\"headerlink\" title=\"* 布尔值 Boolean\"></a>* 布尔值 Boolean</h3><p>true/false</p>\n<h3 id=\"字符串-String\"><a href=\"#字符串-String\" class=\"headerlink\" title=\"* 字符串 String\"></a>* 字符串 String</h3><h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"string\">'hello'</span>; <span class=\"comment\">// 字面量创建</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> thing = <span class=\"number\">98</span>; <span class=\"comment\">// 任何可以转换成字符串的值</span></span><br><span class=\"line\"><span class=\"comment\">/* String 函数 生成或者将值转换为字符串 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">String</span>(thing); <span class=\"comment\">// 将thing转换为原始字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s3 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(thing); <span class=\"comment\">// 新建String对象, 并存储thing的字符串表示</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1, <span class=\"keyword\">typeof</span> s1); <span class=\"comment\">// hello string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s2, <span class=\"keyword\">typeof</span> s2); <span class=\"comment\">// 98 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s3, <span class=\"keyword\">typeof</span> s3); <span class=\"comment\">// [String: '98'] object</span></span><br></pre></td></tr></table></figure>\n<p>字符串一旦创建, 其内容不可被修改, 只能重新被赋值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">str[<span class=\"number\">1</span>] = <span class=\"string\">'*'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str, str[<span class=\"number\">1</span>]); <span class=\"comment\">// hello e</span></span><br><span class=\"line\">str = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// world</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p><code>length</code></p>\n<p>字符串长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.length); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p><code>constructor</code></p>\n<p>对创建该对象的函数的引用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.constructor); <span class=\"comment\">// [Function: String]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"处理\"><a href=\"#处理\" class=\"headerlink\" title=\"处理\"></a>处理</h5><p><code>toUpperCase</code>  </p>\n<p>字符串变大写</p>\n<p><code>toLowerCase</code>  </p>\n<p>字符串变小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hello'</span>, t = <span class=\"string\">'JINLING'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.toUpperCase(), s); <span class=\"comment\">// HELLO hello</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(t.toLowerCase(), t); <span class=\"comment\">// jinling JINLING</span></span><br></pre></td></tr></table></figure>\n<p><code>trim</code></p>\n<p>去除字符串两边的空白. 原字符串未改变.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"   hello   *   \"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.trim(), <span class=\"string\">', |'</span> + str + <span class=\"string\">'|'</span>); <span class=\"comment\">// hello   * , |   hello   *   |</span></span><br></pre></td></tr></table></figure>\n<p><code>split</code> </p>\n<p>根据分隔符将字符串分割为数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'hel,l,o'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 不切割 整个字符串视作数组的一个元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.split());  <span class=\"comment\">// [ 'hel,l,o' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 每个字符都是数组中的元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.split(<span class=\"string\">''</span>));</span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\"> 'h', 'e', 'l',</span></span><br><span class=\"line\"><span class=\"comment\"> ',', 'l', ',',</span></span><br><span class=\"line\"><span class=\"comment\"> 'o'</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 以逗号分割</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.split(<span class=\"string\">','</span>), s); <span class=\"comment\">// [ 'hel', 'l', 'o' ] hel,l,o</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h5><p><code>indexOf</code></p>\n<p>查找字符串中有无指定字符串, 有则返回下标, 没有则返回-1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"hello jinling!\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> res1  = s.indexOf(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2  = s.indexOf(<span class=\"string\">\"jin\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1, res2); <span class=\"comment\">// -1 6</span></span><br></pre></td></tr></table></figure>\n<p><code>includes</code></p>\n<p>查找字符串是否包含指定子串, 有则返回<code>true</code>, 反之<code>false</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"hello jinling good\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.includes(<span class=\"string\">\"hello\"</span>), str.includes(<span class=\"string\">\"world\"</span>)); <span class=\"comment\">// true false</span></span><br></pre></td></tr></table></figure>\n<p><code>charAt</code></p>\n<p>返回字符串中对应下标的字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"hello*jinling!\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ch = s.charAt(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ch); <span class=\"comment\">// *</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"拼接-截取\"><a href=\"#拼接-截取\" class=\"headerlink\" title=\"拼接/截取\"></a>拼接/截取</h5><p><code>concat</code></p>\n<p>拼接两个或者更多字符串, 返回新字符串, 不改变原字符串.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"string\">\"hello\"</span>, s2 = <span class=\"string\">\"*go\"</span>, s3 = <span class=\"string\">\"*hhh\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = s1.concat(s2, s3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s, s1, s2, s3) <span class=\"comment\">// hello*go*hhh hello *go *hhh</span></span><br></pre></td></tr></table></figure>\n<p><code>slice</code></p>\n<p>截取字符串的片段, 不改变原字符串.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"helloWorld\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = str.slice(<span class=\"number\">3</span>, <span class=\"number\">7</span>); <span class=\"comment\">// [起始位置, 结束位置)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s, str); <span class=\"comment\">// loWo helloWorld</span></span><br></pre></td></tr></table></figure>\n<p><code>substring</code></p>\n<p>截取字符串的片段, 不改变原字符串.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'helloWorld'</span>;</span><br><span class=\"line\"> <span class=\"comment\">// [起始位置, 结束位置)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.substring(<span class=\"number\">1</span>, <span class=\"number\">8</span>), s); <span class=\"comment\">// elloWor helloWorld</span></span><br></pre></td></tr></table></figure>\n<p><code>substr</code></p>\n<p>截取指定长度的子串. (ps. ECMAscript 没有对该方法进行标准化，因此反对使用它。)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'helloWorld'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 起始位置 截取长度</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.substr(<span class=\"number\">1</span>, <span class=\"number\">4</span>), s); <span class=\"comment\">// ello helloWorld</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数字-Number\"><a href=\"#数字-Number\" class=\"headerlink\" title=\"* 数字 Number\"></a>* 数字 Number</h3><p>数字可以是数字或者对象, Number 对象是原始数值的包装对象. JS只有一种数字类型.</p>\n<h4 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 基础类型创建 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> k = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> k); <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"comment\">// 科学计数法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"number\">123e5</span>, k = <span class=\"number\">123e-5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> t, t, <span class=\"keyword\">typeof</span> k, k); <span class=\"comment\">// number 12300000 number 0.00123</span></span><br><span class=\"line\"><span class=\"comment\">// 八进制以0开头</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">0122</span>; <span class=\"comment\">// 数字以 0 开头, 且后面的数字都比8小, 则js解释为八进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 82</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">0888</span>; <span class=\"comment\">// 后面数字&gt;=8, 则依然解释为十进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 888</span></span><br><span class=\"line\"><span class=\"comment\">// 十六进制以0x开头</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">0x11</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 对象形式创建 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"99\"</span>), n = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> m, m, <span class=\"keyword\">typeof</span> n, n); </span><br><span class=\"line\"><span class=\"comment\">// object [Number: 99] object [Number: 10]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"kill\"</span>); <span class=\"comment\">// 不能转换为数字时</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> t, t); <span class=\"comment\">// object [Number: NaN]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>返回对创建此对象的 Number 函数的引用.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.constructor); <span class=\"comment\">// [Function: Number]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p><code>toString</code></p>\n<p>将数字转变为字符串, 使用指定的基数.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"99\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = t.toString();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// string 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用指定的基数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"10\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = t.toString(<span class=\"number\">2</span>); <span class=\"comment\">// 十进制转变为二进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// 1010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"10\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = t.toString(<span class=\"number\">8</span>); <span class=\"comment\">// 十进制转变为八进制</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str, str); string <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<p><code>valueOf</code></p>\n<p>返回一个 Number 对象的基本数字值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"99\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(t.valueOf()); <span class=\"comment\">// 99</span></span><br></pre></td></tr></table></figure>\n<p><code>isFinite</code></p>\n<p>判断参数是否为无穷大</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">123</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">-1.23</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">5</span><span class=\"number\">-2</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'123'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'2005/12/12'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(-<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0</span> / <span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">NaN</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>isNaN</code></p>\n<p>使用全局函数判断<code>NaN</code>(教程推荐).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(a), <span class=\"built_in\">isNaN</span>(<span class=\"number\">8</span>), <span class=\"built_in\">isNaN</span>(<span class=\"string\">\"11\"</span>)); <span class=\"comment\">// true false false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Symbol-ES6\"><a href=\"#Symbol-ES6\" class=\"headerlink\" title=\"* Symbol (ES6)\"></a>* Symbol (ES6)</h3><p>基本数据类型, ES6新增, 表示独一无二的值. 由于 ES5 对象的属性名只能是字符串, 容易造成属性名的冲突, 需要独一无二的值.</p>\n<p>具有静态属性与静态方法. 模拟对象私有属性.</p>\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>通过<code>Symbol</code>函数产生.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受字符串作为参数, 表示对Synbol实例的描述, 主要为了在控制台显示或者转为字符串时容易被区分.</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(**description?: string | number**): symbol</span><br><span class=\"line\"></span><br><span class=\"line\">Description <span class=\"keyword\">of</span> the <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span> object.</span><br><span class=\"line\"></span><br><span class=\"line\">Returns a <span class=\"keyword\">new</span> unique <span class=\"built_in\">Symbol</span> value.</span><br></pre></td></tr></table></figure>\n<p>每个从 Symbol 返回的symbol值都是唯一的, 尽管参数相同.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>(<span class=\"number\">34</span>); </span><br><span class=\"line\"><span class=\"comment\">// Symbol 不会将'hello'转变为symbol类型, 每次创建一个新的symbol类型.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'hello'</span>); </span><br><span class=\"line\"><span class=\"keyword\">let</span> sym3 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'hello'</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> sym, sym); <span class=\"comment\">// symbol Symbol()</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sym1 == <span class=\"number\">34</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sym2 == <span class=\"string\">'hello'</span>, sym2, sym2.toString()); <span class=\"comment\">// false Symbol(hello) 'Symbol(hello)'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sym2 === sym3); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code>可以转换为<strong>字符串</strong>以及<strong>布尔值</strong>, 但是不能转换为数值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'happy'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1.toString(), <span class=\"built_in\">String</span>(s1)); <span class=\"comment\">// Symbol(happy) Symbol(happy)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'happy'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Boolean</span>(s1)); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'happy'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(s1)); <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure>\n<p>对原始数据类型创建一个显式包装器对象从ES6开始不再被支持, 但是原有的 new Boolean/new String/new Number 由于遗留原因仍然可以被创建.</p>\n<p>如果真的想创建一个Symbol包装器, 可以使用Object()函数.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// symbol 是原始数据类型 不是对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">// TypeError: Symbol is not a constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"number\">34</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> sym); <span class=\"comment\">// symbol</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> symObj = <span class=\"built_in\">Object</span>(sym);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> symObj); <span class=\"comment\">// object</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为属性名\"><a href=\"#作为属性名\" class=\"headerlink\" title=\"作为属性名\"></a>作为属性名</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj[mySymbol] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [mySymbol]: <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将对象的属性名指定为一个 Symbol 值</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, mySymbol, &#123; <span class=\"attr\">value</span>: <span class=\"string\">'hello'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三种写法 同样结果</span></span><br><span class=\"line\">obj[mySymbol] <span class=\"comment\">// 'hello'</span></span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code> 作为对象属性时, 不能使用点运算符, 只能使用方框<code>[]</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj[mySymbol] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">obj.mySymbol = <span class=\"string\">'hi'</span>; <span class=\"comment\">// 相当于属性名为 'mySymbol' 字符串</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.mySymbol); <span class=\"comment\">// hi</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[mySymbol]); <span class=\"comment\">// hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 作为对象属性, 只能使用方框</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增强的对象写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s] (arg) &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"* null\"></a>* null</h3><p><code>null</code> : 表示主动释放指向对象的引用.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">a = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 释放指向数组的引用</span></span><br></pre></td></tr></table></figure>\n<p>设计之初, <code>null</code> 像在java里一样, 被当成一个<strong>对象</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>); <span class=\"comment\">// object</span></span><br></pre></td></tr></table></figure>\n<p>可以自动转为 0 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>), <span class=\"number\">8</span> + <span class=\"literal\">null</span>); <span class=\"comment\">// 0 8</span></span><br></pre></td></tr></table></figure>\n<p><strong>用法: null 表示”没有对象”, 即 该处不应该有值.</strong></p>\n<ol>\n<li>作为函数的参数, 表示该函数的参数不是对象</li>\n<li>作为对象原型链的终点</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"* undefined\"></a>* undefined</h3><p>Brendan Eich 觉得, 表示’无’的值, 最好不是对象. 其次, 由于js初版本没有错误处理机制, null 自动转为 0 不容易发现错误. 于是 Brendan Eich又设计了一个<code>undefined</code>.</p>\n<p>一开始 <code>undefined</code> 被设计为表示’无’的原始值, 转为数字时为 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(<span class=\"literal\">undefined</span>), <span class=\"number\">8</span> + <span class=\"literal\">undefined</span>); <span class=\"comment\">// NaN NaN</span></span><br></pre></td></tr></table></figure>\n<p><strong>用法: undefined 表示”缺少值”, 就是此处应该有一个值, 但是还没有定义.</strong></p>\n<ol>\n<li>变量被声明过, 但是没有赋值, 等于 undefined</li>\n<li>调用函数时, 应该提供的参数没有提供, 则该参数为 undefined</li>\n<li>对象没有赋值的属性, 该属性值为 undefined</li>\n<li>函数没有返回值时, 默认返回 undefined.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用法 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b); <span class=\"comment\">// undefined undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法 3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法 4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"undefined-与-null-区别\"><a href=\"#undefined-与-null-区别\" class=\"headerlink\" title=\"undefined 与 null 区别\"></a>undefined 与 null 区别</h4><p>两者使用 == 时为true, === 时为false.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span> == <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span> === <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// true false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在if语句中, 两者都被转成 false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"literal\">undefined</span>) <span class=\"built_in\">console</span>.log(<span class=\"string\">'undefined if false'</span>); <span class=\"comment\">// undefined if false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"literal\">null</span>) <span class=\"built_in\">console</span>.log(<span class=\"string\">'null if false'</span>); <span class=\"comment\">// null if false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><h3 id=\"数组-Array\"><a href=\"#数组-Array\" class=\"headerlink\" title=\"* 数组 Array\"></a>* 数组 Array</h3><h4 id=\"创建-2\"><a href=\"#创建-2\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = []; <span class=\"comment\">// 字面</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(); <span class=\"comment\">// 不固定长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">5</span>); <span class=\"comment\">// 固定长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0, arr1, arr2, arr3); <span class=\"comment\">// [] [] [ &lt;5 empty items&gt; ] [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"其他数据类型转数组\"><a href=\"#其他数据类型转数组\" class=\"headerlink\" title=\"其他数据类型转数组\"></a>其他数据类型转数组</h4><p>set-&gt;Array</p>\n<p>Array.from(set)</p>\n<p>string-&gt;Array</p>\n<h4 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p><code>length</code></p>\n<blockquote>\n<p>计算并返回数组长度</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]; <span class=\"comment\">// 字面</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.length); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p><code>constructor</code></p>\n<blockquote>\n<p>返回创建该对象的函数的引用, 因为js的一切变量都是对象, 是对象就有其构造函数.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (test.constructor==<span class=\"built_in\">Array</span>)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.write(test.constructor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output: function Array() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"改变原数组\"><a href=\"#改变原数组\" class=\"headerlink\" title=\"改变原数组\"></a>改变原数组</h5><p><strong>Array.sort()</strong></p>\n<blockquote>\n<p>对数组元素进行排序, 默认是字符串顺序.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照字母顺序排序 默认</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'good'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 'Bob', 'are', 'good', 'google', 'hi', 'you' ]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>添加比值函数, 使得能对<strong>数字进行排序</strong>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不使用比值函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">76</span>, <span class=\"number\">91</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\">  0,  1, 12,  3, 34,</span></span><br><span class=\"line\"><span class=\"comment\">  7, 76,  9, 91</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用比值函数 倒序</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">76</span>, <span class=\"number\">91</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b - a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\">  91, 76, 34, 12, 9,</span></span><br><span class=\"line\"><span class=\"comment\">   7,  3,  1,  0</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用比值函数 正序</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">76</span>, <span class=\"number\">91</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">[</span></span><br><span class=\"line\"><span class=\"comment\">   0,  1,  3,  7, 9,</span></span><br><span class=\"line\"><span class=\"comment\">  12, 34, 76, 91</span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.pop()</strong></p>\n<blockquote>\n<p>删除数组的最后一个元素并返回该元素. 空数组返回<code>undefined</code>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.pop(), arr0);</span><br><span class=\"line\"><span class=\"comment\">// output: 4 [ 1, 2, 3 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.pop(), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: undefined []</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.shift()</strong></p>\n<blockquote>\n<p>删除并返回数组的第一个元素</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.shift(), arr1);</span><br><span class=\"line\"><span class=\"comment\">// 1 [ 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.unshift()</strong></p>\n<blockquote>\n<p>向数组的开头添加元素并返回现有长度</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.unshift(<span class=\"number\">9</span>), arr1);</span><br><span class=\"line\"><span class=\"comment\">// 6 [ 9, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.push()</strong></p>\n<blockquote>\n<p>向数组末尾添加元素并返回数组现有长度</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.push(<span class=\"number\">4</span>), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: 4 [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.reverse()</strong></p>\n<blockquote>\n<p>颠倒数组中元素顺序</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.reverse(), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: [ 3, 2, 1 ] [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.splice()</strong> </p>\n<blockquote>\n<p>推荐使用该方法删除数组元素</p>\n<p>注意: 删除的元素以数组形式返回.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>); <span class=\"comment\">// 从数组下标为2的位置开始删除1个元素,再插入2个元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 1, 2, 'ok', 'fine', 4, 5 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不留空洞地删除元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"comment\">// 从下标为3的位置开始, 删除2个元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">3</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// ['fine', 'you'] 注意这里是数组形式!</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 1, 2, 'ok', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>delete</strong>  </p>\n<p>JS运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">delete</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>], arr); <span class=\"comment\">// 留下了空洞</span></span><br><span class=\"line\"><span class=\"comment\">// undefined [ &lt;1 empty item&gt;, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"不改变原数组\"><a href=\"#不改变原数组\" class=\"headerlink\" title=\"不改变原数组\"></a>不改变原数组</h5><p><strong>Array.slice()</strong></p>\n<blockquote>\n<p>根据下标获取数组的一部分, 返回新数组.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.slice(<span class=\"number\">3</span>), arr1.slice(<span class=\"number\">2</span>,<span class=\"number\">4</span>), arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: [ 4, 5 ] [ 3, 4 ] [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.concat()</strong></p>\n<blockquote>\n<p>拼接数组成一个新数组</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.concat(arr1), arr0, arr1);</span><br><span class=\"line\"><span class=\"comment\">// output: [ 1, 2, 3, 4, 5, 6 ] [ 1, 2, 3, 4 ] [ 5, 6 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.flat()</strong></p>\n<blockquote>\n<p>按照指定的深度递归遍历数组, 将所有元素与遍历到的子数组中的元素合并为一个<strong>新数组</strong>返回.</p>\n<p>将数组扁平化</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 默认递归深度为1 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = arr.flat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1, arr);</span><br><span class=\"line\"><span class=\"comment\">// [ 1, 2, 'ok', 'fine' ] [ 1, 2, [ 'ok', 'fine' ] ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 移除数组空项</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>, , , <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.flat());</span><br><span class=\"line\"><span class=\"comment\">// [ 1, 2, null, undefined, 5 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 指定递归深度 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [[[<span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.flat(<span class=\"number\">2</span>), arr.flat(<span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">// [ 1, 2, [ 'ok', 'fine' ] ] [ 1, 2, 'ok', 'fine' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.join()</strong>  默认使用 <code>,</code> 为分隔符</p>\n<blockquote>\n<p><code>toString</code> 所有 JavaScript 对象都拥有<code>toString()</code>方法</p>\n<p>数组所有元素组成字符串, 可以指定分隔符.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr0 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.join(), arr0.toString()); <span class=\"comment\">// 1,2,3,4  1,2,3,4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0.join(<span class=\"string\">'*'</span>)); <span class=\"comment\">// 1*2*3*4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr0); <span class=\"comment\">// [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.map()</strong></p>\n<blockquote>\n<p>对数组的每个元素均执行函数, 对其做一些处理, 来生成新数组. <strong>不改变原数组</strong>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = arr.map(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val + <span class=\"string\">'*'</span> + index;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 原数组不变</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2, arr);</span><br><span class=\"line\"><span class=\"comment\">// [ '1*0', '2*1', 'ok*2', 'fine*3', 'you*4', 'bye*5' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = arr.map(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [ 0, 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.filter()</strong></p>\n<blockquote>\n<p>对数组的每个元素均执行函数, 筛选符合条件的元素来生成新数组.<strong>不改变原数组</strong>.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = arr.filter(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2, arr);</span><br><span class=\"line\"><span class=\"comment\">// [ 'ok', 'fine', 'you', 'bye' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.forEach()</strong></p>\n<blockquote>\n<p>对数组的每个元素均执行一次函数(回调函数)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// 该函数的参数1为数组元素,参数2为数组元素下标,参数3为该数组本身</span></span><br><span class=\"line\">arr.forEach(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  s += (val + <span class=\"string\">'/'</span> + index + <span class=\"string\">' '</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s); <span class=\"comment\">// 1/0 2/1 ok/2 fine/3 you/4 bye/5</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.reduce()</strong></p>\n<blockquote>\n<p>参数<code>total</code> 默认是数组的第一个元素, 可以设置初始值.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'bye'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.reduce(<span class=\"function\">(<span class=\"params\">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"total=\"</span>, total, val, index); <span class=\"comment\">// 从index=1开始打印</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + <span class=\"string\">'*'</span> + val;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">total= bye hi 1</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi ok 2</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi*ok fine 3</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi*ok*fine you 4</span></span><br><span class=\"line\"><span class=\"comment\">total= bye*hi*ok*fine*you bye 5</span></span><br><span class=\"line\"><span class=\"comment\">bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置total初始值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'bye'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.reduce(<span class=\"function\">(<span class=\"params\">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + <span class=\"string\">'*'</span> + val;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"this is :\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// this is :*bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.reduceRight()</strong></p>\n<blockquote>\n<p>类似于<code>Array.reduce()</code>, 只不过是从右往左遍历元素.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'bye1'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'bye2'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.reduceRight(<span class=\"function\">(<span class=\"params\">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + <span class=\"string\">'*'</span> + val;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"this is res:\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// this is res:*bye2*you*fine*ok*hi*bye1 [ 'bye1', 'hi', 'ok', 'fine', 'you', 'bye2' ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.every()</strong></p>\n<blockquote>\n<p>检查数组中的元素是否<strong>都符合条件</strong>, 都符合才返回true, 否则返回false.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有元素不符合条件 false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.every(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// false [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有元素均符合条件 true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.every(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'number'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// true [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.some()</strong></p>\n<blockquote>\n<p>检查是否<strong>有元素符合条件</strong>, 有则返回true, 没有则返回false.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有元素符合条件 true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'ok'</span>, <span class=\"string\">'fine'</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.some(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// true [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有元素均不符合条件 false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = arr.some(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val == <span class=\"string\">'string'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, arr);</span><br><span class=\"line\"><span class=\"comment\">// false [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.indexOf()</strong></p>\n<blockquote>\n<p>找到给定元素在数组中第一次出现的位置, 没有则返回-1, 找到则返回元素下标.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找不到 -1, 找到就下标</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.indexOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2 = arr.indexOf(<span class=\"string\">'how'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1, res2); <span class=\"comment\">// -1 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素多次出现 返回第一次出现的位置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2 = arr.indexOf(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res2); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定搜索位置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res2 = arr.indexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res2); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 搜索起始位置可以是负值</span></span><br><span class=\"line\"><span class=\"comment\">// 负值是从数组末尾给定位置开始搜索, 直至末尾.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.indexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">-1</span>), <span class=\"comment\">// 从倒数第一个位置开始, 搜索不到</span></span><br><span class=\"line\">    res2 = arr.indexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">-2</span>); <span class=\"comment\">// 从倒数第二个位置开始搜索, 是可以检索到的, 返回正数下标</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1, res2); <span class=\"comment\">// -1 5</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.lastIndexOf()</strong></p>\n<blockquote>\n<p>与上一个类似, 只是从数组末尾开始检索.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 出现两次Bob, 但是返回了从右往左的第一个.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.lastIndexOf(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设定搜索起始位置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'how'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.lastIndexOf(<span class=\"string\">'Bob'</span>, <span class=\"number\">-3</span>); <span class=\"comment\">// 从倒数第三个元素开始往左搜索, 返回匹配的第一个元素的下标</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.find()</strong></p>\n<blockquote>\n<p>返回符合条件的第一个元素</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'good'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.find(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val.length &gt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// good</span></span><br></pre></td></tr></table></figure>\n<p><strong>Array.findIndex()</strong></p>\n<blockquote>\n<p>返回符合条件的第一个元素<strong>下标</strong></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'hi'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'good'</span>, <span class=\"string\">'are'</span>, <span class=\"string\">'you'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'google'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = arr.findIndex(<span class=\"function\">(<span class=\"params\">val, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val.length &gt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h4><h5 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h5><p>利用键本身的不可重复性</p>\n<blockquote>\n<p>利用ES6 Set 去重 (ES6中最常用)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res); <span class=\"comment\">// [ 1, 2, 3 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简易写法</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>(arr)]</span><br></pre></td></tr></table></figure>\n<p>双层循环法 </p>\n<blockquote>\n<p>splice去重(ES5 常用)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 每一个元素都向后检查有没有与自己相同的元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有 则删除第二个元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于splice的特性 删除后 需要j-- 保证j指向被删除元素的下一个元素而不会遗漏元素</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] === arr[j]) &#123; <span class=\"comment\">// 注意使用===, 因为 null === undefined 为true</span></span><br><span class=\"line\">        arr.splice(j, <span class=\"number\">1</span>);</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">unique(arr1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'arr1:'</span>, arr1); <span class=\"comment\">// arr1: [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用 fliter+indexOf</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.filter(<span class=\"function\">(<span class=\"params\">val, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回符合条件的元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回所有第一次出现的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.indexOf(val, <span class=\"number\">0</span>) == index;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = unique(arr1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'res:'</span>, res);</span><br><span class=\"line\"><span class=\"comment\">// res: [ 1, 2, 3, null, undefined ]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Map-ES6\"><a href=\"#Map-ES6\" class=\"headerlink\" title=\"* Map (ES6)\"></a>* Map (ES6)</h3><p>解决js对象的键只能是字符串的问题, <strong>ES6标准新增</strong>的数据类型.</p>\n<h4 id=\"创建-添加-删除-是否包含\"><a href=\"#创建-添加-删除-是否包含\" class=\"headerlink\" title=\"创建/添加/删除/是否包含\"></a>创建/添加/删除/是否包含</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Michael'</span>, <span class=\"number\">90</span>], [<span class=\"string\">'Bob'</span>, <span class=\"number\">80</span>], [<span class=\"string\">'Lily'</span>, <span class=\"number\">95</span>]]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'Lily'</span>)); <span class=\"comment\">// 95</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map); <span class=\"comment\">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80, 'Lily' =&gt; 95 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个空map, 然后添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">'Michael'</span>, <span class=\"number\">90</span>); <span class=\"comment\">// 添加Key</span></span><br><span class=\"line\">map.set(<span class=\"string\">'Bob'</span>, <span class=\"number\">80</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">'Lily'</span>, <span class=\"number\">95</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map); <span class=\"comment\">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80, 'Lily' =&gt; 95 &#125;</span></span><br><span class=\"line\">map.delete(<span class=\"string\">'Lily'</span>); <span class=\"comment\">// 删除 key</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map); <span class=\"comment\">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 判断是否包含某key</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(<span class=\"string\">'hello'</span>), map.has(<span class=\"string\">'Bob'</span>)); <span class=\"comment\">// false true</span></span><br><span class=\"line\"><span class=\"comment\">// 获取值</span></span><br><span class=\"line\"><span class=\"comment\">// 一个key只对应一个value, 重复设置会覆盖之前的值</span></span><br><span class=\"line\">map.set(<span class=\"string\">'Bob'</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'Bob'</span>)); <span class=\"comment\">// 100</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Set-ES6\"><a href=\"#Set-ES6\" class=\"headerlink\" title=\"* Set (ES6)\"></a>* Set (ES6)</h3><p>一组不重复key的集合.ES6标准新增的数据类型.</p>\n<h4 id=\"创建-添加-删除-是否包含-1\"><a href=\"#创建-添加-删除-是否包含-1\" class=\"headerlink\" title=\"创建/添加/删除/是否包含\"></a>创建/添加/删除/是否包含</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组作为输入</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set1 = <span class=\"keyword\">let</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1); <span class=\"comment\">// Set &#123; 5, 6, 7, 8 &#125; 重复元素被自动过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化空Set, 再添加值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set();</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(1); // 添加元素</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(2);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(3);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(4);</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>); //Set &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">set</span>.delete(3); // 删除元素</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>); // Set &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(4); // 可以添加重复元素 但是无效</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>); // Set &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// '4' 与 4 不同</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">set</span>.has('4'), <span class=\"keyword\">set</span>.has(4)); // false true</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"* 函数\"></a>* 函数</h3><p>函数定义是一个常规的绑定,  其中绑定的值是函数. </p>\n<p>函数的第一种表示法.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 大括号必要, 末尾建议带分号</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>函数也是值的一种, 可以被赋值给多个变量/作为参数传递给函数等.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'1111'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1(); <span class=\"comment\">// 1111</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// func1 可以被绑定为其他函数</span></span><br><span class=\"line\">func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'2222'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1 <span class=\"comment\">// 2222</span></span><br></pre></td></tr></table></figure>\n<p>没有 <code>return</code> 语句或 <code>return</code> 后面没有返回值, 函数将返回 <code>undefined</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func1()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> func2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func2()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>每个局部作用域可以查看包含它的局部作用域, 所有局部作用域都能看见全局作用域.</p>\n<h4 id=\"声明表示法\"><a href=\"#声明表示法\" class=\"headerlink\" title=\"声明表示法\"></a>声明表示法</h4><p>函数的第二种表示法.</p>\n<p>声明在调用之后也能够工作, 声明在概念上被移到了作用域的顶部.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 不需要分号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><p>函数的第三种表示法. 以较简明的方式编写小型函数表达式.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两种写法相同</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> square1 = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square2 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h4><p>函数返回时必须跳回到调用它的位置, 所以计算机必须记住调用发生的上下文. 存储此上下文的位置是调用栈, 每次调用函数时, 当前上下文都存储在此栈的顶部.</p>\n<h4 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h4><p>多余参数自动忽略, 不足参数为 <code>undefined</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> square1 = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square1(<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"string\">'helloo'</span>[<span class=\"number\">2</span>, <span class=\"number\">3</span>]), square1(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2 7</span></span><br><span class=\"line\"><span class=\"comment\">// 2 undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 14 NaN</span></span><br></pre></td></tr></table></figure>\n<p>参数设定默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> square1 = <span class=\"function\">(<span class=\"params\">x, y = <span class=\"number\">3</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square1(<span class=\"number\">2</span>, <span class=\"number\">7</span>), square1(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2 7</span></span><br><span class=\"line\"><span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"comment\">// 14 6</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><p>定义了一个函数激活执行的时候, 去哪里找变量的值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunc</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> desc = <span class=\"string\">' is eating'</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eat</span> (<span class=\"params\">animal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(animal.name + desc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> eat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'dog'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> eat = createFunc();</span><br><span class=\"line\"><span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> desc = <span class=\"string\">'吃东西'</span>;</span><br><span class=\"line\">eat(dog); <span class=\"comment\">// dog is eating</span></span><br></pre></td></tr></table></figure>\n<p><code>eat</code> 函数的作用域链如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eat函数作用域[parent作用域-A]</span><br><span class=\"line\"></span><br><span class=\"line\">A = createFunc作用域[desc: <span class=\"string\">' is eating'</span>, <span class=\"attr\">eat</span>: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">func</span> 定义&gt;</span>, parent作用域-B]</span></span><br><span class=\"line\"></span><br><span class=\"line\">B = Global作用域[desc: '吃东西', createFunc: &lt;func 定义&gt;, parent作用域-null]</span><br></pre></td></tr></table></figure>\n<p>eat 函数中没有定义 <code>desc</code> 这个变量值, 就沿着作用域链去找, 在 <code>createFunc</code> 作用域中找到了 <code>desc</code> 变量的值, 于是就使用了.如果还没有找到, 就接着往上找.</p>\n<p>当执行 <code>createFunc</code> 的时候, <code>eat</code> 函数被创建, 此时 eat 函数会把外部函数的作用域链记录下来, 留到执行时使用. </p>\n<p>注意: 作用域链是<strong>函数创建时刻</strong>发生关联的, 不是运行时刻. Called <strong>静态作用域/词法作用域</strong>. 函数被创建即函数被定义.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 此处 foo 函数被创建, 与全局作用域相关联</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  func();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// foo 函数执行时直接去全局作用域找 x 变量</span></span><br><span class=\"line\">bar(foo); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>静态作用域是实现闭包的必需条件.</p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包在 JS 中就是一个以函数和以静态方式存储的父作用域的一个集合体.</p>\n<p>能够<strong>读取函数局部变量的函数</strong>就是闭包. 下面例子中, <code>func2</code>函数就是闭包.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> func2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> func = func1();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func()); <span class=\"comment\">// 999</span></span><br></pre></td></tr></table></figure>\n<p>用途: 读取函数内部变量 / 让这些变量的值始终保持在内存中.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nAdd;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">999</span>;</span><br><span class=\"line\">  nAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>,a);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> func2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> func = func1(); <span class=\"comment\">// 闭包函数</span></span><br><span class=\"line\">func(); <span class=\"comment\">// a 999</span></span><br><span class=\"line\">nAdd();</span><br><span class=\"line\">func(); <span class=\"comment\">// a 1000</span></span><br></pre></td></tr></table></figure>\n<p>证明了<code>func1</code>的局部变量<code>a</code>一直在内存中, 并没有在func1被调用后被自动清除. </p>\n<p>因为<code>func1</code>是<code>func2</code>的父函数, 而<code>func2</code>被赋予了局部变量<code>func</code>, 导致<code>func2</code>一直在内存中, 则<code>func2</code>依赖的<code>func1</code>也一直在内存中, 不会在调用结束后, 被垃圾回收机制回收.</p>\n<p>这里<code>nAdd</code>也是一个匿名函数, 也是一个闭包, 相当于一个setter, 可以在函数外部对函数内部局部变量进行操作.</p>\n<p>使用闭包的注意点:</p>\n<ol>\n<li>闭包会使函数中的局部变量在内存中, 因此会使得内存占用过多, 不能滥用. 在退出函数前, 将不使用的局部变量全部删除.</li>\n<li>闭包会在函数外部, 改变父函数内部变量的值, 注意不要随便改变.</li>\n</ol>\n<p>思考题:</p>\n<ol>\n<li><code>this</code> 在函数中而不是方法中使用时, 指向全局对象</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> object = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"My Object\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  getNameFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里直接在 vscode 中执行, 所以打出来是 undefined, 可能原本是 The Window</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(object.getNameFunc()()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this 打印出来如下</span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">Object [global] &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  global: [Circular],</span></span><br><span class=\"line\"><span class=\"comment\">  clearInterval: [Function: clearInterval],</span></span><br><span class=\"line\"><span class=\"comment\">  clearTimeout: [Function: clearTimeout],</span></span><br><span class=\"line\"><span class=\"comment\">  setInterval: [Function: setInterval],</span></span><br><span class=\"line\"><span class=\"comment\">  setTimeout: [Function: setTimeout] &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    [Symbol(nodejs.util.promisify.custom)]: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  queueMicrotask: [Function: queueMicrotask],</span></span><br><span class=\"line\"><span class=\"comment\">  clearImmediate: [Function: clearImmediate],</span></span><br><span class=\"line\"><span class=\"comment\">  setImmediate: [Function: setImmediate] &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    [Symbol(nodejs.util.promisify.custom)]: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>这里 <code>that</code> 指向整个 object.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> object = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"My Object\"</span>,</span><br><span class=\"line\">  getNameFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> that.name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(object.getNameFunc()()); <span class=\"comment\">// My Object</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h4><p>对应于传递给函数的参数的类数组对象, 是所有非箭头函数中可用的局部变量, 可以使用它来引用函数的参数.</p>\n<ol>\n<li>arguments参数可以被设置</li>\n<li>不是一个Array, 只是类似, 类型是 object</li>\n<li>只有length和索引元素功能</li>\n<li>可以被转换为真正的数组</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">a, b, c, d, e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]); <span class=\"comment\">// 2</span></span><br><span class=\"line\">  <span class=\"comment\">// 参数被设置</span></span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">4</span>][<span class=\"number\">0</span>] = <span class=\"string\">'Mary'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>], <span class=\"built_in\">arguments</span>[<span class=\"number\">4</span>]); <span class=\"comment\">// 3 [ 'Mary', 'hi', 'go' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// arguments转换为数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> args0 = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> args1 = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)</span></span><br><span class=\"line\">  <span class=\"comment\">// 注重性能 使用被忽视的Array构造函数作为一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> args = (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">1</span> ? [<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]] : <span class=\"built_in\">Array</span>.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'ES6'</span>, args0, args1, <span class=\"string\">'遍历对象构造数组'</span>, args);</span><br><span class=\"line\">  <span class=\"comment\">// ES6 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] 遍历对象构造数组 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ES2015</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> args3 = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> args4 = [...arguments];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'ES5'</span>, args3, args4);</span><br><span class=\"line\">  <span class=\"comment\">// ES5 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>); <span class=\"comment\">// object</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unique(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'hello'</span>, <span class=\"string\">'hi'</span>, <span class=\"string\">'go'</span>]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"eval-函数\"><a href=\"#eval-函数\" class=\"headerlink\" title=\"eval 函数\"></a>eval 函数</h4><p>计算某个<strong>原始字符串</strong>(不是String对象), 并执行其中的JS代码, 并返回结果(如果不存在, 则返回undefined). 是全局对象的一个函数属性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"built_in\">eval</span>(<span class=\"string\">'x+2'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res, <span class=\"built_in\">eval</span>(<span class=\"string\">'4+8'</span>)); <span class=\"comment\">// 10 12</span></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">'let a = 10, b = 9; console.log(a*b)'</span>); <span class=\"comment\">// 90</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 不是字符串的话, 原封不动返回</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>(<span class=\"number\">67</span>)); <span class=\"comment\">// 67</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"number\">777</span>))); <span class=\"comment\">// [String: '777']</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"操作符-typeof\"><a href=\"#操作符-typeof\" class=\"headerlink\" title=\"操作符 typeof\"></a>操作符 typeof</h2><h3 id=\"判断变量数据类型\"><a href=\"#判断变量数据类型\" class=\"headerlink\" title=\"判断变量数据类型\"></a>判断变量数据类型</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"comment\">// 通用数据类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"string\">'jinling'</span> + <span class=\"string\">'\\n'</span> +  <span class=\"comment\">// string</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"number\">23</span> + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// number</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> + <span class=\"string\">'\\n'</span> +  <span class=\"comment\">// boolean</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// object</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> &#123;<span class=\"attr\">k1</span>:<span class=\"string\">'v1'</span>, <span class=\"attr\">k2</span>:<span class=\"string\">'v2'</span>&#125; + <span class=\"string\">'\\n'</span> <span class=\"comment\">// object</span></span><br><span class=\"line\">  <span class=\"comment\">// 特殊字符类型</span></span><br><span class=\"line\">  <span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// object</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> + <span class=\"string\">'\\n'</span> + <span class=\"comment\">// undefined</span></span><br><span class=\"line\">\t<span class=\"keyword\">typeof</span> <span class=\"literal\">NaN</span> + <span class=\"string\">'\\n'</span> <span class=\"comment\">// number</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined与null值相同,但类型不同</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>===<span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>==<span class=\"literal\">null</span>); <span class=\"comment\">// false true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断数组可以用 Array.isArray</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(&#123;<span class=\"attr\">k1</span>:<span class=\"string\">'v1'</span>, <span class=\"attr\">k2</span>:<span class=\"string\">'v2'</span>&#125;)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"对象-Object\"><a href=\"#对象-Object\" class=\"headerlink\" title=\"对象 Object\"></a>对象 Object</h1><p>使用{}表示, 键必须是字符串.</p>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>接口与实现分离, 常称为封装. 常见在属性开头加上_表示是私有属性.</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><p>创建一个对象, 定义属性和方法, 不需要 Class.</p>\n<p>对象中的方法就是保存函数的属性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> animal = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'dog'</span>,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> eat meat`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">animal.eat(); <span class=\"comment\">// dog eat meat</span></span><br><span class=\"line\">animal.color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(animal.color); <span class=\"comment\">// red</span></span><br></pre></td></tr></table></figure>\n<p>显式修改方法的调用对象. 使用函数的 <code>call</code> 方法, 该方法将 <code>this</code> 值作为第一个参数, 其他参数为普通参数. 则此时 <code>obj</code> 是 <code>eat</code> 方法的调用者, 通过 <code>call</code> 进行了显式的调用对象的修改.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> animal = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'dog'</span>,</span><br><span class=\"line\">  eat (thing) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> eat <span class=\"subst\">$&#123;thing&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'monkey'</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// obj 成为 eat 方法的调用者</span></span><br><span class=\"line\">animal.eat.call(obj, <span class=\"string\">'carrot'</span>); <span class=\"comment\">// monkey eat carrot</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><p>对象有自己的默认属性集. <code>Object.getPrototypeOf</code> 方法返回一个对象的原型.</p>\n<p><code>Object.prototype</code> 提供在所有对象中显示的方法, 是最根部的原型.</p>\n<p>函数派生自 <code>Function.prototype</code>, 数组派生自 <code>Array.prototype</code>, 他们具有不同的默认属性集.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString); <span class=\"comment\">// [Function: toString]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString()); <span class=\"comment\">// [object Object]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__); <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空对象的原型是 Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(&#123;&#125;) == <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.prototype 原型为 null</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h3><p>使用 <code>Object.create</code> 创建具有特定原型的对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> protoDog = &#123;</span><br><span class=\"line\">  speak(word)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking '</span> + word);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"built_in\">Object</span>.create(protoDog);</span><br><span class=\"line\">dog.name = <span class=\"string\">'doggi'</span>; <span class=\"comment\">// dog 对象此时仅包含自身属性 name</span></span><br><span class=\"line\"><span class=\"comment\">// speak 方法来自原型</span></span><br><span class=\"line\">dog.speak(<span class=\"string\">'hello'</span>); <span class=\"comment\">// doggi is speaking hello</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__ 属性\"></a>__proto__ 属性</h3><p>继承是让两个对象产生关联, 使用 __proto__, 这个属性每个对象都有. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> animal = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'animal'</span>,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> eat meat`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 属性覆盖 方法不覆盖</span></span><br><span class=\"line\"><span class=\"comment\">// 对象 dog 的原型是 animal</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'dog'</span>,</span><br><span class=\"line\">  __proto__: animal <span class=\"comment\">// 指向animal对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象 cat 的原型是 animal</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cat'</span>,</span><br><span class=\"line\">  __proto__: animal <span class=\"comment\">// 指向animal对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dog.eat(); <span class=\"comment\">// dog eat meat</span></span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// cat eat meat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单纯关联 不做属性或者方法覆盖</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  __proto__: animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = &#123;</span><br><span class=\"line\">  __proto__: animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.name, cat.name); <span class=\"comment\">// animal animal</span></span><br><span class=\"line\">dog.eat(); <span class=\"comment\">// animal eat meat</span></span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// animal eat meat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法覆盖 属性不覆盖</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  __proto__: animal,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'dog is eating'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = &#123;</span><br><span class=\"line\">  __proto__: animal,</span><br><span class=\"line\">  eat () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'cat is eating'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.name, cat.name); <span class=\"comment\">// animal animal</span></span><br><span class=\"line\">dog.eat(); <span class=\"comment\">// dog is eating</span></span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// cat is eating</span></span><br></pre></td></tr></table></figure>\n<p>如下所示, 对象 <code>dog</code> 和 <code>cat</code> 的原型均是 <code>animal</code>, 但是均没有定义 <code>eat</code> 方法. 在执行 <code>eat</code> 方法时, 会到其原型中去寻找, 如果找到则执行, 没有则继续去原型的原型中去寻找, 直至找到或者为<code>null</code>. 不断寻找原型的过程依赖于__proto__建立的原型链.</p>\n<p>可以看出, 尽管执行的是原型中的方法, 但是方法中的<code>this</code>仍然指的是调用该方法的上级对象, 由于是<code>dog</code>和<code>cat</code>这两个对象进行调用的, 所以 this 指向的就是这两个对象而不是 animal.</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>但是 JS 也可以通过 <code>new</code> 关键字来创建对象, 是给不理解原型链又需要创建对象的程序员使用的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模仿 java 中的 Class 而提供的构造函数</span></span><br><span class=\"line\"><span class=\"comment\">// Student 的首字母大写</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> lily = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"lily\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> mary = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"mary\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">lily.sayHello(); <span class=\"comment\">// hello lily</span></span><br><span class=\"line\">mary.sayHello(); <span class=\"comment\">// hello mary</span></span><br></pre></td></tr></table></figure>\n<p>这样有个问题就是, 每个对象都会有一个 <code>sayHello</code> 函数, 太重复, 而 java 中函数是定义在 <code>class</code> 中的.</p>\n<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><p>JS  使用更加高效的方式, 创建一个原型对象 A, 将方法都放在这个原型对象 A 中, 而通过同一个构造函数创建的对象的原型, 都是这个原型对象 A, 这样对象找不到方法时, 就会去其原型即 A 中寻找.</p>\n<p>达到这样的效果,  则需要将构造函数与原型对象 A 关联起来, 将 A 赋值给构造函数的 <code>prototype</code> 属性, 则 A 就会成为这个构造函数创建的对象的原型.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原型对象</span></span><br><span class=\"line\">Student.prototype = &#123;</span><br><span class=\"line\">  sayHello () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> lily = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"lily\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> mary = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"mary\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">lily.sayHello(); <span class=\"comment\">// hello lily</span></span><br><span class=\"line\">mary.sayHello(); <span class=\"comment\">// hello mary</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"语法糖-Class\"><a href=\"#语法糖-Class\" class=\"headerlink\" title=\"语法糖 Class\"></a>语法糖 Class</h3><p>上述语法有点复杂, JS 推出语法糖, 将构造函数与原型对象的函数写在一个 <code>class</code> 中.</p>\n<p>上述写法等同于下面这种.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造函数的 prototype</span></span><br><span class=\"line\">  <span class=\"comment\">// 原型对象</span></span><br><span class=\"line\">  <span class=\"comment\">// 作为对象的方法, this 指向的是 调用该方法的对象</span></span><br><span class=\"line\">  sayHello = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mary = <span class=\"keyword\">new</span> Student(<span class=\"string\">'mary'</span>);</span><br><span class=\"line\"><span class=\"comment\">// mary 对象调用其原型(__proto__)的方法 sayHello</span></span><br><span class=\"line\"><span class=\"comment\">// 此时方法中的 this 指向 mary 对象</span></span><br><span class=\"line\">mary.sayHello(); <span class=\"comment\">// hello mary</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"类-Class\"><a href=\"#类-Class\" class=\"headerlink\" title=\"类 Class\"></a>类 Class</h2><p>一种语法糖, 特殊的函数, 由<strong>类表达式</strong>和<strong>类声明</strong>组成. 类定义了一种对象的形状, 具有哪些属性与方法. 而这种对象称之为类的实例.</p>\n<p>JS 类就是带有 prototype 属性的构造函数. 类中的方法, 都是构造函数原型对象中的方法. 类中的<code>constructor</code>方法是实际的构造函数, 并被绑定名称 <code>Animal</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 目前只支持将函数添加进构造函数原型中 </span></span><br><span class=\"line\">  <span class=\"comment\">// 不支持其他类型</span></span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h3><ol>\n<li><p>类声明 带有<code>class</code>关键字</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类需要先声明 再使用 不像函数声明会提升</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hello</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类表达式 可以具名或者匿名</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匿名类</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello.name); <span class=\"comment\">// hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具名类</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hello2</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello.name); <span class=\"comment\">// hello2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传统的基于函数的类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.speak = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' makes a noise.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.speak();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' barks.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Dog(<span class=\"string\">'cookie'</span>)</span><br><span class=\"line\">d.speak(); </span><br><span class=\"line\"><span class=\"comment\">// cookie makes a noise.</span></span><br><span class=\"line\"><span class=\"comment\">// cookie barks.</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类体和方法定义\"><a href=\"#类体和方法定义\" class=\"headerlink\" title=\"类体和方法定义\"></a>类体和方法定义</h3><p><code>constructor</code> </p>\n<p>构造函数, 一种特殊方法, 创建和初始化一个由 <code>class</code> 创建的对象. </p>\n<p>构造函数可以使用<code>super</code>调用父类的构造函数.</p>\n<h3 id=\"覆盖派生属性\"><a href=\"#覆盖派生属性\" class=\"headerlink\" title=\"覆盖派生属性\"></a>覆盖派生属性</h3><p>向对象中添加属性, 属性被添加到对象本身, 原型中的此属性将不再影响该对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给构造函数的原型对象添加属性</span></span><br><span class=\"line\">Animal.prototype.age = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\">dog.age = <span class=\"number\">10</span>; <span class=\"comment\">// 覆盖原型属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.age); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.age); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(dog).age); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>数组原型提供的 <code>toString</code> 方法与基本原型对象提供的有所差别, 这样对原型属性的覆盖有利于更通用的对象类中表达异常属性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.toString == <span class=\"built_in\">Object</span>.prototype.toString); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].toString()); <span class=\"comment\">// 1,2,3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.prototype.toString 并不知道数组的信息, 只是将 object 与调用对象的类型名称放在[]中</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString.call([<span class=\"number\">1</span>, <span class=\"number\">2</span>]), <span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">4</span>)); </span><br><span class=\"line\"><span class=\"comment\">// [object Array] [object Number]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>对原型方法的覆盖, 以实现实例的特殊化需求. <code>String</code> 实际调用的仍然是 <code>toString</code> 方法.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(dog)); <span class=\"comment\">// [object Object]</span></span><br><span class=\"line\">Animal.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'This is '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(dog)); <span class=\"comment\">// This is dog</span></span><br></pre></td></tr></table></figure>\n<p>任何支持 <code>toString</code> 方法的对象都可以使用它.</p>\n<p><strong>多态</strong>: 多态代码可以支持不同类型的值, 只要这些值支持它指定的接口. 比如 toString 方法, 所有值都支持该接口, 则所有值都能使用该方法.</p>\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>普通对象派生自 <code>Object.prototype</code> , 含有祖先原型的所有属性, 在一些实际场景下, 这些属性可能显得多余. </p>\n<p>→ 可以创建没有原型的对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传递 null 生成的对象不会从 Object.prototype 派生</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> &#123;&#125;); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>而且普通对象要求键值必须为字符串.</p>\n<p>→ 使用 Map 类, 存储映射并可以使用任何类型的 key.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ages = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">ages.set(<span class=\"string\">'Bob'</span>, <span class=\"number\">23</span>);</span><br><span class=\"line\">ages.set(<span class=\"string\">'Mary'</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ages.get(<span class=\"string\">'Bob'</span>)); <span class=\"comment\">// 23</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ages.has(<span class=\"string\">'Mary'</span>), ages.has(<span class=\"string\">'toString'</span>)); <span class=\"comment\">// true false</span></span><br></pre></td></tr></table></figure>\n<p>set get has 是 Map 对象接口的一部分.</p>\n<p>某种情况下,  如果确实需要使用普通对象来作为映射, 则 <code>Object.keys</code> 只返回一个<strong>对象自己的键,</strong> 而不包括其原型中的那些属性. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'is speaking'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(dog)); <span class=\"comment\">// [ 'name', 'age' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给原型添加属性</span></span><br><span class=\"line\">dog.__proto__.type = <span class=\"string\">'animal'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Object.keys(dog) 仍然只显示自己的属性, 不包括原型中的属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(dog), <span class=\"built_in\">Object</span>.keys(dog.__proto__)); <span class=\"comment\">// [ 'name', 'age' ] [ 'type' ]</span></span><br></pre></td></tr></table></figure>\n<p><code>hasOwnProperty</code> 方法也只判断某键<strong>是不是该对象自己的</strong>, 没找到也不会去搜索其原型对象. 与关键字 <code>in</code> 不同.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.hasOwnProperty(<span class=\"string\">'name'</span>), dog.hasOwnProperty(<span class=\"string\">'speak'</span>)); <span class=\"comment\">// true false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'name'</span> <span class=\"keyword\">in</span> dog, <span class=\"string\">'speak'</span> <span class=\"keyword\">in</span> dog); <span class=\"comment\">// true true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"extends-创建子类\"><a href=\"#extends-创建子类\" class=\"headerlink\" title=\"extends 创建子类\"></a>extends 创建子类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, sex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用超类构造函数并传入name参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 必须先super 然后才能使用this</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.sex&#125;</span> and barks`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Dog1(<span class=\"string\">'cookie'</span>, <span class=\"string\">'girl'</span>);</span><br><span class=\"line\">d.speak(); <span class=\"comment\">// cookie is girl and barks</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"instanceof-运算符\"><a href=\"#instanceof-运算符\" class=\"headerlink\" title=\"instanceof 运算符\"></a>instanceof 运算符</h3><p>判断一个对象是否来自某一个类.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 目前只支持将函数添加进构造函数原型中 </span></span><br><span class=\"line\">  <span class=\"comment\">// 不支持其他类型</span></span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is speaking!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog <span class=\"keyword\">instanceof</span> Animal, dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">// true true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TO DO </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// TypeError: Right-hand side of 'instanceof' is not callable</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><blockquote>\n<p>部署在object对象自身的方法</p>\n</blockquote>\n<p><code>Object.values</code> 获取对象的所有key, 输出类型为数组</p>\n<p><code>Object.keys</code> 获取对象的所有value, 输出类型为数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">key1</span>:<span class=\"string\">'val1'</span>, <span class=\"attr\">key2</span>:<span class=\"string\">'val2'</span>, <span class=\"attr\">key3</span>:<span class=\"string\">'val3'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.values(obj)); <span class=\"comment\">// [ 'val1', 'val2', 'val3' ]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.getOwnPropertyNames</code> 也是返回对象的所有属性名, 但是还会返回不可枚举的属性; 可枚举属性方面, 与<code>Object.keys</code>相同</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不可枚举属性 二者不同</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = [<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>, <span class=\"string\">'jinling'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj1)); <span class=\"comment\">// [ '0', '1', '2' ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj1)); <span class=\"comment\">// [ '0', '1', '2', 'length' ] 包含不可枚举属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可枚举属性 二者相同</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">key1</span>:<span class=\"string\">'val1'</span>, <span class=\"attr\">key2</span>:<span class=\"string\">'val2'</span>, <span class=\"attr\">key3</span>:<span class=\"string\">'val3'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj)); <span class=\"comment\">// [ 'key1', 'key2', 'key3' ]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><p><code>Object.hasOwnProperty</code>判断对象是否拥有某项属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">key1</span>:<span class=\"string\">'val1'</span>, <span class=\"attr\">key2</span>:<span class=\"string\">'val2'</span>, <span class=\"attr\">key3</span>:<span class=\"string\">'val3'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.hasOwnProperty(<span class=\"string\">'key2'</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><p>摩尔定律失效, 多核时代来临, 函数式编程能够很好地为并发编程服务, 具有 没有 side effect/ 不共享变量/安全调度到任何一个CPU core 上运行/没有加锁问题…等诸多优点.</p>\n<h2 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h2><ol>\n<li>对于相同的输入, 永远有相同的输出. 没有可观察的副作用, 不依赖外部条件.</li>\n<li>不能修改传递给函数的参数</li>\n<li>不能修改全局变量</li>\n</ol>\n<p>比如数组操作中, 对于给定的数组, slice就是纯的, splice就是不纯的.</p>\n<p>纯函数可以有效降低系统复杂性, 还有很多其他的优秀特性, 例如可缓存性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> _ <span class=\"keyword\">from</span> <span class=\"string\">'lodash'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sin = _.memorize(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">Math</span>.sin(x));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一次计算的时候会稍慢一点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = sin(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二次有了缓存，速度极快</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = sin(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用递归而非迭代\"><a href=\"#使用递归而非迭代\" class=\"headerlink\" title=\"使用递归而非迭代\"></a>使用递归而非迭代</h2><p>使用尾递归, 保证不溢出.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代不被允许</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"number\">0</span>; <span class=\"comment\">// result 不能改变</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr)&#123;</span><br><span class=\"line\">  result += i; <span class=\"comment\">// i 不能改变</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> rest = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">arr, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> sum(rest(arr), res + first(arr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr, <span class=\"number\">0</span>)); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>很多函数大体相同, 重复代码很多, 只有一些细节不一样, 于是产生高阶函数.</p>\n<p>高阶函数: 让函数来产生函数, 共用的部分抽取出来, 不共用的部分与共用的部分能组合起来.</p>\n<p>比如 JS 中的 <code>map/filter/forEach/...</code> 函数都是高阶函数, 能快速操作集合数据.</p>\n<h3 id=\"函数的柯里化\"><a href=\"#函数的柯里化\" class=\"headerlink\" title=\"函数的柯里化\"></a>函数的柯里化</h3><p>curry: 传递给函数一部分的参数来调用它, 让他返回一个函数去处理剩下的参数.</p>\n<p>就是传递一部分的参数, 形成固定模式的函数(部分参数数值已经固定), 得到已经记住参数的新函数. 这样对应固定的输入, 就得到固定的输出.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> check = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> y &gt; x);</span><br><span class=\"line\"><span class=\"keyword\">let</span> check7 = check(<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(check7(<span class=\"number\">10</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数组合\"><a href=\"#函数组合\" class=\"headerlink\" title=\"函数组合\"></a>函数组合</h3><p>包菜式代码  <code>h(g(f(x)))</code> =&gt; 更优雅 函数组合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传的是g函数需要的参数</span></span><br><span class=\"line\"><span class=\"comment\">// 将任何两个纯函数结合在一起, 组合函数式的代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> (<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add1 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> mul5 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> res = compose(add1, mul5);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res(<span class=\"number\">2</span>)); <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> reverse = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr.reverse();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(first, reverse);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(last([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"惰性求值\"><a href=\"#惰性求值\" class=\"headerlink\" title=\"惰性求值\"></a>惰性求值</h2><p>待补充</p>\n<h2 id=\"宏-macro\"><a href=\"#宏-macro\" class=\"headerlink\" title=\"宏(macro)\"></a>宏(macro)</h2><p>待补充</p>\n<h2 id=\"Point-Free\"><a href=\"#Point-Free\" class=\"headerlink\" title=\"Point Free\"></a>Point Free</h2><p>减少对不必要的中间变量的命名</p>\n<h2 id=\"声明式与命令式代码\"><a href=\"#声明式与命令式代码\" class=\"headerlink\" title=\"声明式与命令式代码\"></a>声明式与命令式代码</h2><p><strong>命令式</strong>: 写出一条一条指令让计算机执行, 一般会涉及到很多繁琐的细节. <strong>既说做什么, 也说怎么做</strong>.</p>\n<p><strong>声明式</strong>: 写表达式表明自己想做的事情, 而不是一步一步的指示. 隐藏细节.  <strong>只说做什么, 不说怎么做</strong>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//命令式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CEOs = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; companies.length; i++)&#123;</span><br><span class=\"line\">    CEOs.push(companies[i].CEO)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CEOs = companies.map(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c.CEO);</span><br></pre></td></tr></table></figure>\n<p>函数式编程一个优点就是声明式代码以及纯函数. 工作时专注于业务代码, 优化时专注于函数内部. 还有其他的特点, 比如高阶函数/函数没有side effect/只有值没有变量/用递归而不是用迭代等.</p>\n<h1 id=\"遍历器与-for…of\"><a href=\"#遍历器与-for…of\" class=\"headerlink\" title=\"遍历器与 for…of\"></a>遍历器与 for…of</h1><h2 id=\"遍历器概念\"><a href=\"#遍历器概念\" class=\"headerlink\" title=\"遍历器概念\"></a>遍历器概念</h2><p>是用来处理可遍历数据结构的统一接口, 只要部署 <code>iterator</code> 接口, 就可以进行遍历操作.</p>\n<p>作用: 提供统一的访问接口/数据结构的成员按照某种顺序排列/为ES6新增的<code>for...of</code>服务</p>\n<p>数据结构有遍历器接口, 就称为该数据结构是可遍历的/可迭代的.</p>\n<h2 id=\"JS-默认遍历器接口\"><a href=\"#JS-默认遍历器接口\" class=\"headerlink\" title=\"JS 默认遍历器接口\"></a>JS 默认遍历器接口</h2><p>JS中默认的遍历器接口, 即数据结构的原型对象有 <code>Symbol.iterator</code> 属性, 该属性对应的函数返回一个遍历器对象, 调用对象的<code>next</code>方法, 即可返回数据结构的下一个数据..</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> it = arr[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next(), it.next(), it.next(), it.next());</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 3, done: false &#125; &#123; value: 4, done: false &#125; &#123; value: 5, done: false &#125; &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// done 表示是否遍历结束</span></span><br></pre></td></tr></table></figure>\n<p>原生具备 Iterator 接口的数据结构如下。</p>\n<ul>\n<li><p>Array</p>\n</li>\n<li><p>Map</p>\n</li>\n<li><p>Set</p>\n</li>\n<li><p>String</p>\n</li>\n<li><p>TypedArray</p>\n</li>\n<li><p>函数的 arguments 对象</p>\n</li>\n<li><p>NodeList 对象</p>\n</li>\n</ul>\n<p>上述数据结构不用自己写遍历器函数, <code>for...of</code>循环会自动进行遍历.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>没有遍历器函数的数据结构, 可以根据实际需求进行手动部署, 即在<code>Symbol.iterator</code>属性上手写遍历器对象生成函数.</p>\n<h1 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h1><p>针对数组或者对象进行模式匹配, 然后对其中的变量进行赋值. 解构目标 = 解构源.</p>\n<h2 id=\"数组的解构\"><a href=\"#数组的解构\" class=\"headerlink\" title=\"数组的解构\"></a>数组的解构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 嵌套</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, [[b], c]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可忽略</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, , c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, c); <span class=\"comment\">// 1 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 剩余运算符</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, ...b] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 1 [2, 3]</span></span><br></pre></td></tr></table></figure>\n<p>数组解构中, 若解构目标为可遍历对象(实现iterator接口的数据), 都可以进行解构赋值.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c, ...d] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c, d); <span class=\"comment\">// h e l [ 'l', 'o' ]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"解构默认值\"><a href=\"#解构默认值\" class=\"headerlink\" title=\"解构默认值\"></a>解构默认值</h3><p>解构匹配到<code>undefined</code>, 触发默认值作为返回结果.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 均匹配到 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">2</span>] = [<span class=\"literal\">undefined</span>]; <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">3</span>, b = a] = []; <span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 3 3</span></span><br><span class=\"line\"><span class=\"comment\">// b 匹配到 undefined, 触发默认值 b=a=1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">3</span>, b = a] = [<span class=\"number\">1</span>]; <span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 1 1</span></span><br><span class=\"line\"><span class=\"comment\">// 正常解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">3</span>, b = a] = [<span class=\"number\">1</span>, <span class=\"number\">9</span>]; <span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// 1 9</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"对象的解构\"><a href=\"#对象的解构\" class=\"headerlink\" title=\"对象的解构\"></a>对象的解构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// undefined undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">a</span>: b &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b); <span class=\"comment\">// ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 正确使用 解构目标必须与key一致 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello, apple &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello, apple); <span class=\"comment\">// aaa bbb</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">hello</span>: b &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// aaa</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello); <span class=\"comment\">// aaa</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 剩余运算符 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b, ...rest &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">30</span>, <span class=\"attr\">d</span>: <span class=\"number\">40</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, rest); <span class=\"comment\">// 10 20 &#123; c: 30, d: 40 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 解构默认值 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello = <span class=\"number\">3</span>, apple = <span class=\"number\">5</span> &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">apple</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello, apple); <span class=\"comment\">// aaa bbb</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apple 匹配到 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; hello = <span class=\"number\">3</span>, apple = <span class=\"number\">5</span> &#125; = &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'aaa'</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello, apple); <span class=\"comment\">// aaa 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">hello</span>: aa = <span class=\"number\">3</span>, <span class=\"attr\">apple</span>: bb = <span class=\"number\">5</span> &#125; = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(aa, bb); <span class=\"comment\">// 3 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">hello</span>: aa = <span class=\"number\">3</span>, <span class=\"attr\">apple</span>: bb = <span class=\"number\">5</span> &#125; = &#123; <span class=\"attr\">apple</span>: <span class=\"string\">'aaa'</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(aa, bb); <span class=\"comment\">// 3 aaa</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"关键字-this\"><a href=\"#关键字-this\" class=\"headerlink\" title=\"关键字 this\"></a>关键字 this</h1><p>js中<code>this</code>随着执行环境的变化而变化, 是函数运行时, 在函数体内部自动生成的一个对象, 只能在函数体内部使用. 即, <strong>this 是函数运行时所在的环境对象</strong>. 箭头函数不绑定自己的 <code>this</code> .</p>\n<h2 id=\"单独使用\"><a href=\"#单独使用\" class=\"headerlink\" title=\"单独使用\"></a>单独使用</h2><p>无论有无严格模式, <code>this</code>始终指向全局对象. 浏览器中, 全局对象为<code>[object Window]</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 'use strict'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"纯粹的函数调用\"><a href=\"#纯粹的函数调用\" class=\"headerlink\" title=\"纯粹的函数调用\"></a>纯粹的函数调用</h2><p>函数中, 默认<code>this</code>指向全局对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(); <span class=\"comment\">// ok</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fun()); <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>严格模式下不允许默认绑定, 所以函数中的<code>this</code>为<code>undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 严格模式</span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myFunction()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数作为对象方法\"><a href=\"#函数作为对象方法\" class=\"headerlink\" title=\"函数作为对象方法\"></a>函数作为对象方法</h2><p>指向上级对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\tsize : <span class=\"number\">14</span>,</span><br><span class=\"line\">\tcolor: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">\tgetColor: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">'颜色是'</span> + <span class=\"keyword\">this</span>.color</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 该实例中, this指向getColor方法所在的对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getColor) <span class=\"comment\">// [Function: getColor]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getColor()) <span class=\"comment\">// 颜色是red (加括号表示调用方法)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法中的this单独打印, 会打印出所属对象的内容</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  firstName  : <span class=\"string\">\"John\"</span>,</span><br><span class=\"line\">  lastName   : <span class=\"string\">\"Doe\"</span>,</span><br><span class=\"line\">  id         : <span class=\"number\">5566</span>,</span><br><span class=\"line\">  myFunction : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.myFunction()); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  firstName: 'John',</span></span><br><span class=\"line\"><span class=\"comment\">  lastName: 'Doe',</span></span><br><span class=\"line\"><span class=\"comment\">  id: 5566,</span></span><br><span class=\"line\"><span class=\"comment\">  myFunction: [Function: myFunction]</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类方法中的-this-指向\"><a href=\"#类方法中的-this-指向\" class=\"headerlink\" title=\"类方法中的 this 指向\"></a>类方法中的 <code>this</code> 指向</h3><p><code>speak</code> 方法中的 <code>this</code> 从打印结果来看, 指的是<strong>构造函数生成的新对象</strong>, 并未打印<code>speak</code>方法.</p>\n<p>但是 <code>this.speak</code> 却能够调用, 说明<code>this</code>不仅指向的是构造函数对应的对象, 而且在行为上也与构造函数的对象一致, 就是对象中找不到方法, 就去对象的原型中去找.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  speak () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.speak, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"comment\">// 此时 speak 中的this指的是它的调用对象, 也就是 dog</span></span><br><span class=\"line\"><span class=\"comment\">// speak 在打印 this.speak 时, 相当于打印 dog.speak, 但是 dog 本身是没有 speak 函数的</span></span><br><span class=\"line\"><span class=\"comment\">// 只能去 dog 原型对象里去找, 最后找到了 speak 函数, 其实打印的是 dog 原型的 speak 函数</span></span><br><span class=\"line\">dog.speak();</span><br><span class=\"line\"><span class=\"comment\">// [Function: speak] Animal &#123; name: undefined &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eat 中的 this 与 speak 中的 this 一样</span></span><br><span class=\"line\"><span class=\"comment\">// 均是指构造函数对应的对象</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面 eat 在执行时, 均是指向调用 eat 方法的类的实例</span></span><br><span class=\"line\"><span class=\"comment\">// 即 panda 和 cat</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> panda = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'panda'</span>);</span><br><span class=\"line\">panda.eat(); <span class=\"comment\">// Animal &#123; name: 'panda' &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);</span><br><span class=\"line\">cat.eat(); <span class=\"comment\">// Animal &#123; name: 'cat' &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数作为构造函数\"><a href=\"#函数作为构造函数\" class=\"headerlink\" title=\"函数作为构造函数\"></a>函数作为构造函数</h2><p>构造函数就是, 通过这个函数, 能够生成一个新对象. 此时, <code>this</code> 指向这个新对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.x); <span class=\"comment\">// hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// ok 此时全局变量x的值没有变化, 说明 this 不是全局对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"apply-调用\"><a href=\"#apply-调用\" class=\"headerlink\" title=\"apply 调用\"></a>apply 调用</h2><p><code>apply()</code>是函数的一个方法, 作用是改变函数的调用对象. 第一个参数表示改变后的调用这个函数的对象, 此时 <code>this</code> 指向这个参数.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.x = <span class=\"string\">'hi'</span>;</span><br><span class=\"line\">obj.method= test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数为空时, 默认 obj.method 这个方法的调用者修改为 全局对象.</span></span><br><span class=\"line\">obj.method.apply(); <span class=\"comment\">// o.apply(); // ok</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改 obj.method 这个方法的调用者为 obj, 则此时 obj.method 作为对象方法被调用</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向 obj</span></span><br><span class=\"line\">obj.method.apply(obj); <span class=\"comment\">// hi</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>ES6之前使用 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。</p>\n<p>ES6 引入了模块化，在编译时就能确定模块的依赖关系 + 输入和输出的变量。</p>\n<p>ES6 的模块化 = 导出（export） 与导入（import）两个模块。</p>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>自动开启严格模式</p>\n<p>模块中可以导入导出各种类型的变量, 如函数/对象/字符串/布尔值/类等.</p>\n<p>每个模块都有自己的上下文, 模块内声明的变量都是局部变量.</p>\n<p>每个模块只加载一次, 再去加载该模块, 则直接从内存中读取.</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 </p>\n<p>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</p>\n<p>import 命令会提升到整个模块的头部，首先执行。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----export [test.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myAge = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myfn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"My name is\"</span> + myName + <span class=\"string\">\"! I'm '\"</span> + myAge + <span class=\"string\">\"years old.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myClass =  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> a = <span class=\"string\">\"yeah!\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class=\"line\"><span class=\"comment\">// 建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口</span></span><br><span class=\"line\"><span class=\"comment\">// 函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----import [xxx.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myfn());<span class=\"comment\">// My name is Tom! I'm 20 years old.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myAge);<span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myName);<span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myClass.a );<span class=\"comment\">// yeah!</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"as-的用法\"><a href=\"#as-的用法\" class=\"headerlink\" title=\"as 的用法\"></a>as 的用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----export [test.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName <span class=\"keyword\">as</span> exportName &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/*-----import [xxx.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; exportName &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(exportName);<span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"comment\">// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----export [test1.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----export [test2.js]-----*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Jerry\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; myName &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----import [xxx.js]-----*/</span></span><br><span class=\"line\"><span class=\"comment\">// 不同模块导出接口名称命名重复， 使用 as 重新定义变量名。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; myName <span class=\"keyword\">as</span> name1 &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test1.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; myName <span class=\"keyword\">as</span> name2 &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./test2.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name1);<span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name2);<span class=\"comment\">// Jerry</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"import-命令的特点\"><a href=\"#import-命令的特点\" class=\"headerlink\" title=\"import 命令的特点\"></a>import 命令的特点</h3><h4 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h4><h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于 import &#123; a &#125; \"./xxx.js\"; 只执行一次</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; b &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./xxx.js\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于 import &#123; a, b &#125; from \"./xxx.js\"; 只执行一次</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"静态执行特性\"><a href=\"#静态执行特性\" class=\"headerlink\" title=\"静态执行特性\"></a>静态执行特性</h4><p><code>import</code> 静态执行, 不能使用表达式和变量.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"string\">\"f\"</span> + <span class=\"string\">\"oo\"</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"methods\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 表达式 error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">module</span> = <span class=\"string\">\"methods\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"built_in\">module</span>;</span><br><span class=\"line\"><span class=\"comment\">// 变量 error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"method1\"</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"method2\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"export-default-命令\"><a href=\"#export-default-命令\" class=\"headerlink\" title=\"export default 命令\"></a>export default 命令</h3><p>在一个文件或者模块中, export/import可以有多个, export default 仅有一个。</p>\n<p>导出时不需要加{}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"My name is Tom!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> a; <span class=\"comment\">// 仅有一个 不需要加&#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">var</span> c = <span class=\"string\">\"error\"</span>; </span><br><span class=\"line\"><span class=\"comment\">// error，default 已经是对应的导出变量，不能跟着变量声明语句</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> b <span class=\"keyword\">from</span> <span class=\"string\">\"./xxx.js\"</span>; <span class=\"comment\">// 不需要加&#123;&#125;， 使用任意变量接收</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><ol>\n<li><p>避免使用 全局变量 <code>new</code> <code>===</code> <code>eval()</code></p>\n</li>\n<li><p>所有声明放在脚本或者函数的顶部, <strong>顶部声明, 稍后使用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在顶部声明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstName, lastName, price, discount, fullPrice;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 稍后使用</span></span><br><span class=\"line\">firstName = <span class=\"string\">\"Bill\"</span>;</span><br><span class=\"line\">lastName = <span class=\"string\">\"Gates\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">price = <span class=\"number\">19.90</span>;</span><br><span class=\"line\">discount = <span class=\"number\">0.10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">fullPrice = price * <span class=\"number\">100</span> / discount;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>声明变量时同时初始化</p>\n</li>\n<li><p>将数值/字符串/布尔值声明为原始值而非对象, 否则会拖慢速度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"string\">'bill'</span> <span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'bill'</span>) <span class=\"comment\">// 对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x===y); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请勿使用 new Object()</p>\n</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">推荐使用</th>\n<th style=\"text-align:center\">不建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">{}</td>\n<td style=\"text-align:center\">new Object()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[]</td>\n<td style=\"text-align:center\">new Array()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">function (){}</td>\n<td style=\"text-align:center\">new Function()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">“”</td>\n<td style=\"text-align:center\">new String()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">new Number()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">new Boolean()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/()/</td>\n<td style=\"text-align:center\">new RegExp()</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li><p>意识到自动类型转换, 变量可以通过赋值改变其数据类型, 变量可包含不同的数据类型.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"string\">'hello'</span></span><br><span class=\"line\">a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">// number</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为函数中的参数设置默认值, <code>undefined</code> 会破坏代码</p>\n</li>\n<li><p>用<code>default</code>来结束<code>switch</code>.</p>\n</li>\n</ol>\n<h1 id=\"缺陷与错误\"><a href=\"#缺陷与错误\" class=\"headerlink\" title=\"缺陷与错误\"></a>缺陷与错误</h1><h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><blockquote>\n<p>原因</p>\n</blockquote>\n<p>js代码中会出现错误, 由于编写代码/编译/用户输入等各种各样的原因.</p>\n<blockquote>\n<p>处理</p>\n</blockquote>\n<p>发生错误时, js引擎会停止并生成一个错误消息.</p>\n<p>try与catch成对出现, finally是最后一定会执行的语句(可以没有).</p>\n<p>throw抛出错误, 实际上就是抛出一个表示错误信息的字符串s, 因此可以自定义错误.</p>\n<p>在catch中可以捕获s,实际上就是可以获得s的值并打印出来.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"string\">''</span>) <span class=\"keyword\">throw</span> <span class=\"string\">'is kong'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"string\">'1'</span>) <span class=\"keyword\">throw</span> <span class=\"string\">'is 1'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"string\">'2'</span>) <span class=\"keyword\">throw</span> <span class=\"string\">'is 2'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"string\">'1'</span>); <span class=\"comment\">// is 1</span></span><br><span class=\"line\">test(<span class=\"string\">''</span>); <span class=\"comment\">// is kong</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><blockquote>\n<p>操作</p>\n</blockquote>\n<p>设置断点, 检查变量值, 浏览器内置调试器(按下F12, 选择<code>console</code>)</p>\n<blockquote>\n<p><code>debugger</code>关键字</p>\n</blockquote>\n<p>代码会在<code>debugger</code>行停下, 并执行调试函数. 没有调试函数则不起作用.</p>\n<p>与在调试工具中设置断点效果一样.</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><blockquote>\n<p>原因</p>\n</blockquote>\n<p><code>use strict</code> </p>\n<p>消除js语法的不合理之处, 保证代码安全; 增加编译效率;</p>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<p>只能放在脚本或者函数的开头</p>\n<blockquote>\n<p>具体内容</p>\n</blockquote>\n<ul>\n<li>禁止使用未定义/声明的变量</li>\n<li>禁止删除变量/函数</li>\n<li>禁止变量重名</li>\n<li>禁止使用八进制/转义字符</li>\n<li>禁止对只读属性赋值</li>\n<li>禁止删除不能删除的属性, 比如prototype</li>\n<li>禁止变量名为eval/arguments</li>\n<li>禁止使用右侧类似语句 with (Math){x = cos(2)};</li>\n<li>禁止在作用域eval创建的变量被使用</li>\n<li>禁止this指向全局对象</li>\n</ul>"},{"title":"Hello World","abbrlink":"4a17b156","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nabbrlink: 4a17b156\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-07-28T10:22:25.188Z","updated":"2020-07-28T15:24:05.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw5fag1000xmm9hflli9fy8","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/Linked-list/image.png","slug":"image.png","post":"ckgw5fafs000emm9h8gd5hs0n","modified":0,"renderable":0},{"_id":"source/_posts/Backtracking/bitmask4.png","slug":"bitmask4.png","post":"ckgw5fafk0005mm9ha375cu8a","modified":0,"renderable":0},{"_id":"source/_posts/Binary-Tree/二叉树.png","slug":"二叉树.png","post":"ckgw5fafl0006mm9h2wdv4ddv","modified":0,"renderable":0},{"_id":"source/_posts/Binary-Search/binary-search.png","slug":"binary-search.png","post":"ckgw5fafo0009mm9hhv9fcqxb","modified":0,"renderable":0},{"_id":"source/_posts/JavaScript-Notes/htmltree.jpg","slug":"htmltree.jpg","post":"ckgw5fag0000smm9h51e8gb85","modified":0,"renderable":0},{"_id":"source/_posts/Greedy-Algorithm/45_fig1.png","slug":"45_fig1.png","post":"ckgw5fafq000bmm9h2zzw2zia","modified":0,"renderable":0},{"_id":"source/_posts/Greedy-Algorithm/largen-reach.png","slug":"largen-reach.png","post":"ckgw5fafq000bmm9h2zzw2zia","modified":0,"renderable":0},{"_id":"source/_posts/Linked-list/image1.png","slug":"image1.png","post":"ckgw5fafs000emm9h8gd5hs0n","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckgw5fafk0005mm9ha375cu8a","category_id":"ckgw5fafm0007mm9h1y8qdspx","_id":"ckgw5fafu000hmm9hdwmc74bf"},{"post_id":"ckgw5fafq000bmm9h2zzw2zia","category_id":"ckgw5fafm0007mm9h1y8qdspx","_id":"ckgw5fafv000kmm9hgwhw0593"},{"post_id":"ckgw5fafo0009mm9hhv9fcqxb","category_id":"ckgw5fafm0007mm9h1y8qdspx","_id":"ckgw5fafx000nmm9h7upybbbr"},{"post_id":"ckgw5fafv000jmm9h761pgo71","category_id":"ckgw5fafm0007mm9h1y8qdspx","_id":"ckgw5fag0000tmm9h9mjzevil"},{"post_id":"ckgw5fafw000mmm9h2bipbryl","category_id":"ckgw5fafm0007mm9h1y8qdspx","_id":"ckgw5fag2000ymm9h2q4967p7"},{"post_id":"ckgw5fafy000qmm9h066narly","category_id":"ckgw5fag1000wmm9h2xlhemsv","_id":"ckgw5fag30012mm9h6exd0hzk"}],"PostTag":[{"post_id":"ckgw5fafq000bmm9h2zzw2zia","tag_id":"ckgw5fafn0008mm9ha4ah0guw","_id":"ckgw5faft000fmm9h133fgs76"},{"post_id":"ckgw5fafk0005mm9ha375cu8a","tag_id":"ckgw5fafn0008mm9ha4ah0guw","_id":"ckgw5fafw000lmm9h67x51c6f"},{"post_id":"ckgw5fafk0005mm9ha375cu8a","tag_id":"ckgw5fafq000dmm9he2dd8gx9","_id":"ckgw5fafx000omm9hgv4080ot"},{"post_id":"ckgw5fafv000jmm9h761pgo71","tag_id":"ckgw5fafn0008mm9ha4ah0guw","_id":"ckgw5fafy000rmm9h4tmehtrn"},{"post_id":"ckgw5fafo0009mm9hhv9fcqxb","tag_id":"ckgw5fafn0008mm9ha4ah0guw","_id":"ckgw5fag0000umm9hdzmn9ap1"},{"post_id":"ckgw5fafp000amm9hhxmi89rn","tag_id":"ckgw5fafn0008mm9ha4ah0guw","_id":"ckgw5fag30010mm9h56ctded3"},{"post_id":"ckgw5fafp000amm9hhxmi89rn","tag_id":"ckgw5fafx000pmm9hawvz3ghr","_id":"ckgw5fag30011mm9h2xg54466"},{"post_id":"ckgw5fafp000amm9hhxmi89rn","tag_id":"ckgw5fag1000vmm9heheaf0co","_id":"ckgw5fag30014mm9h1ixf1ard"},{"post_id":"ckgw5fafw000mmm9h2bipbryl","tag_id":"ckgw5fafn0008mm9ha4ah0guw","_id":"ckgw5fag40016mm9hf2veb2ar"},{"post_id":"ckgw5fafw000mmm9h2bipbryl","tag_id":"ckgw5fag2000zmm9hb1y66685","_id":"ckgw5fag40017mm9h7x7wg6o9"},{"post_id":"ckgw5fafw000mmm9h2bipbryl","tag_id":"ckgw5fag30013mm9h36ih18l8","_id":"ckgw5fag50019mm9hckpj9ees"},{"post_id":"ckgw5fafy000qmm9h066narly","tag_id":"ckgw5fag40015mm9h95e89g1d","_id":"ckgw5fag6001bmm9hhth34haj"},{"post_id":"ckgw5fafy000qmm9h066narly","tag_id":"ckgw5fag50018mm9h698u8wjc","_id":"ckgw5fag6001cmm9h8tgb3ilr"},{"post_id":"ckgw5fag0000smm9h51e8gb85","tag_id":"ckgw5fag5001amm9h0hwm5mku","_id":"ckgw5fag6001dmm9h1ie27zcq"}],"Tag":[{"name":"LeetCode","_id":"ckgw5fafn0008mm9ha4ah0guw"},{"name":"Backtracking","_id":"ckgw5fafq000dmm9he2dd8gx9"},{"name":"Array","_id":"ckgw5fafx000pmm9hawvz3ghr"},{"name":"Dynamic-Programming","_id":"ckgw5fag1000vmm9heheaf0co"},{"name":"array","_id":"ckgw5fag2000zmm9hb1y66685"},{"name":"two-pointers","_id":"ckgw5fag30013mm9h36ih18l8"},{"name":"Vue","_id":"ckgw5fag40015mm9h95e89g1d"},{"name":"js","_id":"ckgw5fag50018mm9h698u8wjc"},{"name":"-JavaScript","_id":"ckgw5fag5001amm9h0hwm5mku"}]}}